{"meta":{"title":"jhmarryme's blog","subtitle":null,"description":"blog","author":"Jiahao Wang","url":"https://wangdaye7.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-02-26T23:04:48.000Z","updated":"2019-02-26T15:05:24.791Z","comments":true,"path":"categories/index.html","permalink":"https://wangdaye7.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-26T23:12:23.000Z","updated":"2019-02-26T15:12:51.696Z","comments":true,"path":"tags/index.html","permalink":"https://wangdaye7.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"疑问","slug":"note/temp/疑问","date":"2019-09-15T23:41:21.000Z","updated":"2019-09-15T15:41:52.907Z","comments":true,"path":"2019/09/16/note/temp/疑问/","link":"","permalink":"https://wangdaye7.github.io/2019/09/16/note/temp/疑问/","excerpt":"","text":"ArrayList 与 List equals与==== 比较对象地址, equals比较值","categories":[{"name":"待整理","slug":"待整理","permalink":"https://wangdaye7.github.io/categories/待整理/"}],"tags":[]},{"title":"计算机网络思维导图","slug":"offer/计算机网络","date":"2019-09-12T14:26:24.000Z","updated":"2019-09-12T06:51:09.793Z","comments":true,"path":"2019/09/12/offer/计算机网络/","link":"","permalink":"https://wangdaye7.github.io/2019/09/12/offer/计算机网络/","excerpt":"","text":"思维导图 OSI七层模型 思维导图因为在之前的课程上学过计算机网络, 学的不深, 也做过一些笔记, 没事的时候复习一下 OSI七层模型从网上找来的图…","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wangdaye7.github.io/categories/计算机网络/"}],"tags":[]},{"title":"Java内存模型常见问题","slug":"offer/Java内存模型常见问题","date":"2019-09-11T14:55:08.000Z","updated":"2019-09-12T05:58:55.880Z","comments":true,"path":"2019/09/11/offer/Java内存模型常见问题/","link":"","permalink":"https://wangdaye7.github.io/2019/09/11/offer/Java内存模型常见问题/","excerpt":"","text":"1. 思维导图 2. JVM三大性能调优参数 3. Java内存模型中堆和栈的区别 4. 不同JDK下intern方法的表现 1. 思维导图 2. JVM三大性能调优参数 java -Xms128m -Xmx128m -Xss256k -jar xxxx.jar Xss 每个线程虚拟机栈(堆栈)的大小(影响此进程中并发线程数的大小) Xms 堆的初始值 Xmx 堆能达到的最大值 3. Java内存模型中堆和栈的区别 内存分配策略 静态存储 编译时确定每个数据目标在运行时的存储空间需求 栈式存储 数据区需求在编译时未知, 运行时模块入口前确定 堆式存储 编译时或运行时模块入口都无法确定, 动态分配 联系 引用对象, 数组时, 栈里定义变量保存堆中目标的首地址 区别 管理方式栈自动释放, 堆需要GC 空间大小栈比堆小 碎片相关栈产生更少的碎片 分配方式栈支持静态/动态分配, 堆仅支持动态分配 效率栈的效率比堆高 4. 不同JDK下intern方法的表现12345678910111213141516171819202122232425262728293031323334package imooc.javaBasic.jvm.model;/** * * 比较JDK1.6 与之后版本String的intern方法的区别 * @author jhmarryme.cn * @date 2019/9/12 13:17 */public class InternDifference &#123; // 1.7之后的版本 public static void main(String[] args) &#123; // 首先将 a 放入常量池中, new String时,. 会在堆区也放入a String str1 = new String(\"a\"); // 此时将堆区中的a试图放入常量池, 发现已经有了a 所以失败了. str1.intern(); String str2 = \"a\"; // 这里比较的其实是堆区中的a 与 常量池中的a System.out.println(str1 == str2); //newString时放入堆区的是aa 而在常量池中的是a String str3 = new String(\"a\") + new String(\"a\"); // 在1.6的版本中, 如果常量池中已经存在, 则返回该引用, 如果不存在则将字符串对象添加到常量池并返回引用 // 区别于1.7之前的版本, 首先判断常量池中有没有该字符串, 发现没有, 再看java堆中是否存在 // 如果存在, 则将字符串对象的引用放入常量池, 并返回该引用. // 如果不存在 则创建字符串对象并返回引用 str3.intern(); String str4 = \"aa\"; // 如果是1.6版本则为false, 因为一个是堆区的对象, 一个是常量池 // 1.7以后则为true System.out.println(str3 == str4); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"Java内存模型和简单分析一次add方法执行的过程","slug":"offer/Java内存模型","date":"2019-09-09T19:01:25.000Z","updated":"2019-09-12T05:59:51.782Z","comments":true,"path":"2019/09/10/offer/Java内存模型/","link":"","permalink":"https://wangdaye7.github.io/2019/09/10/offer/Java内存模型/","excerpt":"","text":"1. 思维导图 2. JVM架构图 3. Java的内存模型 4. 分析依次add方法的执行过程 5. 可能会出现的问题 6. 内存相关的概念 1. 思维导图 2. JVM架构图 3. Java的内存模型 Java的内存模型指的就是上图中的Runtime Data Area 区域 程序计数器 java虚拟机栈 虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型），它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 局部变量与操作数栈之间的交换变量指令操作通过字节码频繁执行 本地方法栈 元空间 避免永久代内存溢出的问题. 在 JDK1.7之前，HotSpot 使用永久代实现方法区；HotSpot 使用 GC 分代实现方法区带来了很大便利； 从 JDK1.7 开始HotSpot 开始移除永久代。其中符号引用（Symbols）被移动到 Native Heap中，字符串常量和类引用被移动到 Java Heap中。 在 JDK1.8 中，永久代已完全被元空间(Meatspace)所取代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。 堆 被所有线程共享，在虚拟机启动时创建，用来存放对象实例，几乎所有的对象实例都在这里分配内存。对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；新生代又有Eden空间、From Survivor空间、To Survivor空间三部分。 Java 堆不需要连续内存，并且可以通过动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 4. 分析依次add方法的执行过程123456789101112package imooc.javaBasic.jvm.mode;/** * @author jhmarryme.cn * @date 2019/9/9 19:49 */public class ByteCodeSample &#123; public static int add(int a, int b)&#123; int c = 0; c = a + b; return c; &#125;&#125; 先编译javac ByteCodeSample.java 再反编译(-verbose 口语化)javap -verbose ByteCodeSample.class 下面是部分反编译代码: 分析执行add的过程: 一个长条代表一个栈帧, 共有七个栈帧, 虚拟机栈会按照程序计数器大小依次压入, 然后从小到大去执行iconst_0将int值0压入操作数栈, istore_2将操作数栈中的数据弹出, 存入局部变量表第2号位置, iload_0将表中第0号位置数据压入操作数栈中….store 将操作数栈数据弹出, load将数据压入操作数栈 5. 可能会出现的问题 递归为什么会引发java.lang.StackOverFlowError异常 递归过深, 栈帧数超过虚拟栈深度 比如将斐波那契函数递归到1000000层. 虚拟机栈过多会引发java.lang.OutOfMemoryError异常 会导致死机, 需谨慎操作 6. 内存相关的概念","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"IDEA的快捷键","slug":"note/summary/idea","date":"2019-09-09T10:34:03.000Z","updated":"2019-09-09T02:33:30.368Z","comments":true,"path":"2019/09/09/note/summary/idea/","link":"","permalink":"https://wangdaye7.github.io/2019/09/09/note/summary/idea/","excerpt":"","text":"JSON字符串中写json: Alt+Enter 选择 injecti language of reference 选择JSON 再次A+E 开始Edit 快捷键 弹出类结构Ctrl+F12 vue文件支持安装插件后 setting-&gt;file types-&gt; 下面+号添加*.vue 查看类的继承关系Ctrl+H 快速打印变量soutv 抽取方法Ctrl+shift+m 批量修改变量名shift F6 或者 点击变量-&gt;右键-&gt;Refactor-&gt;Rename 大小写切换快捷键ctr+shift+u 快速搜索double shift 搜索所有 查找类或方法在哪被使用Alt+F7 查看子类方法实现Ctrl+Alt+B 查看接口的实现类格 ctrl + alt +B 或者 Ctrl+Alt+鼠标左键 idea的debug基本用法&amp;快捷键Alt + F8：计算表达式idea","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://wangdaye7.github.io/categories/IDEA/"}],"tags":[]},{"title":"链表与双指针的练习","slug":"offer/链表与双指针的练习","date":"2019-08-26T20:34:03.000Z","updated":"2019-09-15T15:40:47.777Z","comments":true,"path":"2019/08/27/offer/链表与双指针的练习/","link":"","permalink":"https://wangdaye7.github.io/2019/08/27/offer/链表与双指针的练习/","excerpt":"","text":"链表与双指针的练习双指针快慢首尾 可以用在有序的数组中, 很方便的处理求指定和的情况 也可以在中点使用, 目的是在两端往中间逼近先后走 让一个指针先走指定的步数 可用于求倒数第N个数的时候谁小动谁 双指针练习题目167. 有序数组的 Two Sum633. 两数平方和345. 反转字符串中的元音字符680. 回文字符串88. 归并两个有序数组141. 判断链表是否存在环524. 最长子序列哑结点 为头结点添加一个前驱节点, 有效的应对需要处理头结点的各种情况 空指针的预防用最远的节点作为判断条件比如fast和slow指针, 用fast.next fast.next.next fast 作为空判断的条件 链表两种单链表寻找交点的办法 两次遍历 得到两个链表的长度差 让长的先走差值 不为空之前相遇则是交点 另一种方法 设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。 在走完a和c的距离之后, 再从b开始走, 如果有交点则会相遇, 没有就会走到空 先遍历完A链表, 指针回到B重新开始遍历递归在链表中的应用 链表反转 将末尾节点依次向上返回 归并两个有序的链表 将当前节点返回 链表练习题目160. 找出两个链表的交点206. 链表反转 递归处理 这里我理解的思路是首先确定递归完成的条件 -&gt; 最后一个节点 123if (head == null || head.next == null) &#123; return head;&#125; 递归的过程中, 返回的结果是逆序后的头结点, 也就是原序中的尾结点. 将该节点一直向上返回即可, 然后是顺序的调整. 在每次递归中, 调整链表的顺序. 12345ListNode next = head.next;ListNode newHead = reverseList(next);next.next = head;head.next = null;return newHead; 头插法 利用前置节点, 当前节点, 下一节点 完成 21. 归并两个有序的链表 递归处理 递归完成的条件 -&gt; 直到两个链表都为空 12if (l1 == null) return l2;if (l2 == null) return l1; 接着将下一个节点设置为正确的节点即可, 因为每次递归返回的都是当前位置相应最小的节点 1234567if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1;&#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2;&#125; 83. 从有序链表中删除重复节点19. 删除链表的倒数第 n 个节点两个指针fast, slow让fast 先走n步, 接着slow开始走, 当fast.next等于null时, 代表走到了最后一个节点, 此时slow停在的位置, 就是需要删除的节点的前一个位置, 处理完即可需要注意的是, 当删除的是头结点时, fast先走n步, 此时fast就为null了, 需要提前处理这种情况 24. 交换链表中的相邻结点借用哑结点的帮助, 思路与链表逆序相同, 只是需要多一个临时变量. 首先让哑结点指向正确的顺序, 再调整其他的位置. 445. 链表求和234. 回文链表725. 分隔链表328. 链表元素按奇偶聚集","categories":[{"name":"剑指offer笔记","slug":"剑指offer笔记","permalink":"https://wangdaye7.github.io/categories/剑指offer笔记/"}],"tags":[]},{"title":"JVM学习","slug":"offer/refAndClassLoader","date":"2019-08-24T20:34:03.000Z","updated":"2019-09-10T01:54:52.980Z","comments":true,"path":"2019/08/25/offer/refAndClassLoader/","link":"","permalink":"https://wangdaye7.github.io/2019/08/25/offer/refAndClassLoader/","excerpt":"","text":"查看字节码 通过javap命令对.class文件进行反汇编. 123456# 编译成字节码文件javac imooc\\javaBasic\\ByteCodeSample.java# 对代码进行反汇编javap -c imooc.javaBasic.ByteCodeSample# 运行java imooc.javaBasic.ByteCodeSample JVM架构图 Class.forName方法的使用 通过Class.forName方法练习反射, 在运行期间动态加载类 实体类: 12345678910111213141516171819package imooc.reflect;/** * @author jhmarryme.cn * @date 2019/7/24 19:15 */public class Rebot &#123; private String name; public void sayHi(String helloSentence)&#123; System.out.println(helloSentence + \" \" + name); &#125; private String throwHello(String tag)&#123; return \"Hello \" + tag; &#125; static &#123; System.out.println(\"Hello Robot\"); &#125;&#125; 测试类: 123456789101112131415161718192021222324252627282930313233343536373839404142package imooc.reflect;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author jhmarryme.cn * @date 2019/7/24 19:27 */public class ReflectDemo &#123; /** * Class.forName的使用练习 * 通过反射动态获取 对象 属性 方法 * @param args */ public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException, InstantiationException &#123; Class&lt;?&gt; rc = Class.forName(\"imooc.reflect.Rebot\"); Rebot r = (Rebot) rc.newInstance(); //getDeclaredMethod可以获取到包括私有, 但是不包括继承来的所有方法 Method throwHello = rc.getDeclaredMethod(\"throwHello\", String.class); //私有的方法或字段, 需要设置 throwHello.setAccessible(true); //需要传入的参数为r Object str = throwHello.invoke(r, \"王家豪\"); System.out.println(\"throwHello 's result is \" + str); //getMethod不能获取到私有的方法, 但是可以获取到继承的方法 Method sayHi = rc.getMethod(\"sayHi\", String.class); sayHi.invoke(r, \"你好啊\"); //获取私有的字段 Field name = rc.getDeclaredField(\"name\"); name.setAccessible(true); name.set(r, \"江航\"); sayHi.invoke(r, \"你好啊\"); &#125;&#125; classLoader 类从编译到执行的过程 ClassLoader作用 ClassLoader种类 自定义ClassLoaderMyClassLoader: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package imooc.reflect;import java.io.*;/** * 自定义的类加载器, 用于加载自定义位置的类 * 通过重写findClass方法 达到效果 * 重写的是findClass方法, 但使用时调用的是loadClass方法 * @author jhmarryme.cn * @date 2019/7/24 20:14 */public class MyClassLoader extends ClassLoader &#123; //类所在的路径 private String path; //随意取名 private String classLoaderName; public MyClassLoader(String path, String classLoaderName) &#123; this.path = path; this.classLoaderName = classLoaderName; &#125; /** * 用于寻找类文件 * @param name * @return */ @Override public Class findClass(String name)&#123; //先加载类的二进制流 byte[] b = loadClassData(name); //通过defineClass方法创建类 return defineClass(name, b, 0, b.length); &#125; //用于加载类文件 private byte[] loadClassData(String name) &#123; //找到类文件 name = path + \"/\" + name + \".class\"; try ( InputStream in = new FileInputStream(new File(name)); ByteArrayOutputStream out = new ByteArrayOutputStream(); )&#123; int i = 0; while ((i = in.read()) != -1)&#123; out.write(i); &#125; return out.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 测试类: 12345678910111213141516171819package imooc.reflect;/** * 测试自定义类加载器 * @author jhmarryme.cn * @date 2019/7/24 20:23 */public class MyClassLoaderChecker &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; MyClassLoader classLoader = new MyClassLoader(\"D:/develop/folderForDevelop/\", \"myClassLoader\"); //调用的是loadClass方法加载类 Class&lt;?&gt; waLi = classLoader.loadClass(\"WaLi\"); System.out.println(waLi.getClassLoader()); waLi.newInstance(); &#125;&#125; ClassLoader的双亲委派机制 避免多份同样字节码的加载 类的加载加载方式 显式记载 new 隐式加载 forName loadClass 加载过程 主要分成三步 loadClass和forName的区别 为了配合Spring中使用的延迟加载的技术, loadClass只完成加载的操作, 不涉及链接和初始化, 提高了Spring的加载速度.forName得到的class是已经初始化完成的.通过static代码块可以进行验证. 简单的代码练习 123456789101112131415161718192021222324import java.lang.reflect.Method;/** * @author jhmarryme.cn * @date 2019/9/9 18:47 */public class LoadClassDifference &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; // 通过loadClass方法加载的类不会进行, 链接接和初始化, 不会执行static代码块 ClassLoader cl = Rebot.class.getClassLoader(); Class&lt;?&gt; r = cl.loadClass(\"imooc.reflect.Rebot\"); Rebot rebot = (Rebot) r.newInstance(); // 通过forName方法加载的类会进行初始化 final Class&lt;?&gt; rc = Class.forName(\"imooc.reflect.Rebot\"); Rebot rebot1 = (Rebot) rc.newInstance(); rebot.sayHi(\"ss\"); final Method throwHello = rc.getDeclaredMethod(\"throwHello\", String.class); throwHello.setAccessible(true); throwHello.invoke(rebot1, \"sss\"); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"牛客算法学习2","slug":"note/algorithm/牛客算法学习2","date":"2019-07-28T19:34:47.000Z","updated":"2019-09-08T14:21:58.182Z","comments":true,"path":"2019/07/29/note/algorithm/牛客算法学习2/","link":"","permalink":"https://wangdaye7.github.io/2019/07/29/note/algorithm/牛客算法学习2/","excerpt":"","text":"part2栈队列一个特殊的栈 在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。1．pop、push、getMin操作的时间复杂度都是O(1)。2．设计的栈类型可以使用现成的栈结构 栈和队列的转换实现用栈实现队列 因为栈是先进后出的, 假设现有push栈, 先创建一个辅助栈pop逆序存入push中的值, 只需要弹出pop栈顶的值即可, 只有当pop栈为空的时候才存入push中所有的数据, 而且必须一次性存入. 用队列实现栈 队列是先进先出的, 假设有队列queue, 创建一个辅助队列help, 当需要弹出时, 首先将queue弹出到只剩一个值, 并且将弹出的值依次放入help中, 这时候queue中剩下的数据就是最后进来的那个数据, 弹出即可. 此时help中还是维持着queue中原来的顺序, 而queue队列已经空了, 只需要将help与queue队列互换一下就可以了. 猫狗队列哈希哈希函数 哈希函数的输入认为是无穷的, 而输出是有限的 相同的输入, 一定是相同的输出 same input same output 不同的输入也可能导致相同的输出 dif input maybe same output, 这就叫哈希碰撞 离散性, 整个S域上基本均匀分布.","categories":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/categories/算法/"}],"tags":[]},{"title":"方法引用","slug":"note/cyc2018/stream/方法引用","date":"2019-07-24T14:19:23.000Z","updated":"2019-07-24T06:24:44.427Z","comments":true,"path":"2019/07/24/note/cyc2018/stream/方法引用/","link":"","permalink":"https://wangdaye7.github.io/2019/07/24/note/cyc2018/stream/方法引用/","excerpt":"","text":"1. 思维导图 2. 方法引用 2.1. 概念 2.1.1. 目的 2.1.2. 使用场景 2.2. 如何引用 2.2.1. 通过对象名引用成员方法 2.2.2. 通过类名称引用静态方法 2.2.3. 通过super引用成员方法 2.2.4. 通过this引用成员方法 2.2.5. 类的构造器引用 2.2.6. 数组的构造器引用 2.3. 方法引用练习 1. 思维导图 2. 方法引用2.1. 概念 双冒号::为引用运算符，它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 2.1.1. 目的 简化代码, 避免写重复逻辑 2.1.2. 使用场景 如果lambda所要表达的函数方案已经存在与某个方法的实现中, 则可以通过双冒号来引用该方法作为Lambda的替代者. 其实你想表达的lambda已经有人帮你实现了, 就没有必要自己再写一遍, 直接引用即可 2.2. 如何引用2.2.1. 通过对象名引用成员方法12345public class MethodRefObject &#123; public void printUpperCase(String str) &#123; System.out.println(str.toUpperCase()); &#125;&#125; 函数式接口： 1234@FunctionalInterfacepublic interface Printable &#123; void print(String str);&#125; 12345678910public class Demo04MethodRef &#123; private static void printString(Printable lambda) &#123; lambda.print(\"Hello\"); &#125; public static void main(String[] args) &#123; MethodRefObject obj = new MethodRefObject(); printString(obj::printUpperCase); &#125;&#125; 2.2.2. 通过类名称引用静态方法2.2.3. 通过super引用成员方法1234@FunctionalInterfacepublic interface Greetable &#123; void greet();&#125; 12345public class Human &#123; public void sayHello() &#123; System.out.println(\"Hello!\"); &#125;&#125; 123456789101112131415public class Man extends Human &#123; @Override public void sayHello() &#123; System.out.println(\"大家好,我是Man!\"); &#125; //定义方法method,参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; method(super::sayHello); &#125;&#125; 2.2.4. 通过this引用成员方法2.2.5. 类的构造器引用2.2.6. 数组的构造器引用2.3. 方法引用练习","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"stream与函数式接口","slug":"note/cyc2018/stream/stream与函数式接口","date":"2019-07-24T14:03:02.000Z","updated":"2019-09-11T16:07:40.816Z","comments":true,"path":"2019/07/24/note/cyc2018/stream/stream与函数式接口/","link":"","permalink":"https://wangdaye7.github.io/2019/07/24/note/cyc2018/stream/stream与函数式接口/","excerpt":"","text":"1. 思维导图 2. Stream 与函数式接口 2.1. 获取流 2.2. 流的方法 2.2.1. forEach 2.2.2. filter 2.2.3. map 2.2.4. count 2.2.5. limit 2.2.6. skip 2.2.7. concat 2.3. collect 的使用 2.3.1. 转换为 list 2.3.2. 转换为 map 2.4. 流的方法练习 2.5. 函数式接口 2.5.1. Supplier 2.5.2. Consumer 2.5.3. Predicate 2.5.4. Function&lt;T,R&gt; 2.6. 函数式接口方法练习 2.6.1. 比较器 2.6.2. consumer 2.6.3. supplier 2.6.4. function 2.6.5. predicate 2.6.6. lambda延迟加载 1. 思维导图 2. Stream 与函数式接口2.1. 获取流 所有的 Collection 集合都可以通过 stream 默认方法获取流 Stream 接口的静态方法 of 可以获取数组对应的流 Map 不是集合类型，需要根据 key, value, entry 分别获取相应的流 2.2. 流的方法2.2.1. forEach void forEach(Consumer&lt;? super T&gt; action); 2.2.2. filter Stream filter(Predicate&lt;? super T&gt; predicate); 2.2.3. map 将流中的元素映射到另一个流中，通常是用来转换成另一个类型 Stream map(Function&lt;? super T, ? extends R&gt; mapper); 2.2.4. count long count(); 2.2.5. limit Stream limit(long maxSize); 2.2.6. skip Stream skip(long n); 2.2.7. concat static Stream concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 2.3. collect 的使用2.3.1. 转换为 list collect.() 2.3.2. 转换为 map 传入 key, value 即可 public static &lt;T,K,U&gt; Collector&lt;T,?,Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper,Function&lt;? super T,? extends U&gt; valueMapper) 例如：Stream.concat(one.stream(), two.stream()).collect(Collectors.toMap(s -&gt; s, s -&gt; new Person(s))); 2.4. 流的方法练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package javaBase.Stream;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.Stream;/** * @author jhmarryme.cn * @date 2019/7/24 11:21 */public class StreamAndFunctionalInterface &#123; /** * 测试流的各种方法结合常用函数式接口的使用 * @param args */ public static void main(String[] args) &#123; ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); one.add(\"迪丽热巴\"); one.add(\"宋远桥\"); one.add(\"苏星河\"); one.add(\"石破天\"); one.add(\"石中玉\"); one.add(\"老子\"); one.add(\"庄子\"); one.add(\"洪七公\"); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); two.add(\"古力娜扎\"); two.add(\"张无忌\"); two.add(\"赵丽颖\"); two.add(\"张三丰\"); two.add(\"尼古拉斯赵四\"); two.add(\"张天爱\"); two.add(\"张二狗\");// 1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 one.stream().filter(s -&gt; s.length() == 3).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 one.stream().limit(3).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。 two.stream().filter(s -&gt; s.startsWith(\"张\")).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 two.stream().skip(2).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 5. 将两个队伍合并为一个队伍；存储到一个新集合中。 Stream&lt;String&gt; stream = Stream.concat(one.stream(), two.stream());// stream.collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 6. 根据姓名创建`Person`对象；存储到一个新集合中。// 7. 打印整个队伍的Person对象信息。 stream.map(s -&gt; &#123; return new Person(s); &#125;).collect(Collectors.toList()).forEach(person -&gt; System.out.println(person.toString())); //8. 补充, 将list映射为map final Map&lt;String, Person&gt; map = Stream.concat(one.stream(), two.stream()).collect(Collectors.toMap(s -&gt; s, s -&gt; new Person(s))); final Set&lt;Map.Entry&lt;String, Person&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;String, Person&gt; entry : entries) &#123; System.out.print(entry.getKey()); System.out.println(\" : \" + entry.getValue().toString()); &#125; //将int数组转换为list int[] arr = &#123;1,2,3,2,2,2,5,4,2&#125;; //boxed装箱 final List&lt;Integer&gt; collect = Arrays.stream(arr).boxed().collect(Collectors.toList()); final Iterator&lt;Integer&gt; iterator = collect.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next() + \" \"); &#125; //将list转换为int[], 因为int不是包装类型, 需要做转换 final int[] array = collect.stream().mapToInt(Integer::intValue).toArray(); for (int i : array) &#123; System.out.print(i + \" \"); &#125; &#125;&#125; 2.5. 函数式接口 有且仅有一个抽象方法的接口 2.5.1. Supplier 生产一个数据 T get() 2.5.2. Consumer 是消费一个数据 void accept(T t) 默认方法：andThen 2.5.3. Predicate 对某种类型的数据进行判断 boolean test(T t) 默认方法：and or negate 2.5.4. Function&lt;T,R&gt; 根据一个类型的数据得到另一个类型的数据 R apply(T t) 默认方法：andThen 2.6. 函数式接口方法练习2.6.1. 比较器123456789101112131415161718192021package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.Arrays;/** * 通过lambda表达式 作为比较器 * @author jhmarryme.cn * @date 2019/7/22 9:43 */public class LambdaForComparatorDemo &#123; public static void main(String[] args) &#123; String[] array = &#123; \"abc\", \"ab\", \"abcd\" &#125;; System.out.println(Arrays.toString(array)); Arrays.sort(array, (a, b) -&gt; &#123; return a.length() - b.length(); &#125;); System.out.println(Arrays.toString(array)); &#125;&#125; 2.6.2. consumer1234567891011121314151617181920212223242526272829303132package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.function.Consumer;/** * 测试Consumer接口 * 消费一个指定泛型的数据, 无返回值 * 可通过andThen组合操作 * @author jhmarryme.cn * @date 2019/7/22 11:21 */public class LambdaForConsumerDemo &#123; public static void consumerString(String[] info, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2, Consumer&lt;String&gt; con3)&#123; for (String s : info) &#123; con1.andThen(con2).andThen(con3).accept(s); &#125; &#125; public static void main(String[] args) &#123; String[] array = &#123; \"迪丽热巴,女, 14\", \"古力娜扎,女, 12\", \"马尔扎哈,男, 121\" &#125;; consumerString(array, s -&gt; System.out.print(\"姓名: \" + s.split(\",\")[0]), s -&gt; System.out.print(\"性别: \" + s.split(\",\")[1]), s -&gt; System.out.println(\"年龄: \" + s.split(\",\")[2]) ); &#125;&#125; 2.6.3. supplier1234567891011121314151617181920212223242526272829303132333435363738394041424344package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.function.Supplier;/** * 测试Supplier接口 * 包含一个无参的方法, 用来获取一个泛型参数指定类型的对象数据 * @author jhmarryme.cn * @date 2019/7/22 9:52 */public class LambdaForSupplierDemo &#123; public static void main(String[] args) &#123; /*String msgA = \"Hello\"; String msgB = \"World\"; System.out.println(getString(() -&gt; msgA + msgB));*/ int arr[] = &#123;2,3,4,52,333,23&#125;; System.out.println(getMax(() -&gt; &#123; int max = arr[0]; for (int i : arr) &#123; max = i &gt; max ? i : max; &#125; return max; &#125;)); &#125; public static int getMax(Supplier&lt;Integer&gt; integerSupplier)&#123; return integerSupplier.get(); &#125; public static String getString(Supplier&lt;String&gt; stringSupplier)&#123; return stringSupplier.get(); &#125;&#125; 2.6.4. function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.function.Function;/** * 通过函数式结构练习function接口 * 根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件 * @author jhmarryme.cn * @date 2019/7/22 13:15 */public class LambdaForFunctionDemo &#123; /** * 根据接口的泛型 * apply方法中参数类型为String, 返回Integer * @param integerFunction */ public static void method(Function&lt;String, Integer&gt; integerFunction)&#123; final Integer apply = integerFunction.apply(\"5\"); System.out.println(apply + 20); &#125; /** * 在前一个function的基础上再进行处理 * 第二个function的第一个泛型必须为前一个function的后一个泛型 * 相当于前一个的结果为Integer, 后一个就必须用Integer接收 * @param f1 * @param f2 */ public static void methood(Function&lt;String, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)&#123; final Integer apply = f1.andThen(f2).apply(\"1\"); System.out.println(apply); &#125; /** * 截取数字部分, 得到的结果加上100返回 * @param str * @param f1 * @param f2 * @return */ public static Integer getAgeNum(String str, Function&lt;String, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)&#123; return f1.andThen(f2).apply(str); &#125; public static void main(String[] args) &#123;// method((s) -&gt; Integer.parseInt(s));// methood(s -&gt; Integer.parseInt(s)+1, i -&gt; i = ((int)Math.pow(i, 10))); String str = \"赵丽颖,20\"; final Integer ageNum = getAgeNum(str, s -&gt; Integer.parseInt(s.split(\",\")[1]), i -&gt; i = i + 100 ); System.out.println(ageNum); &#125;&#125; 2.6.5. predicate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;/** * 通过函数式接口练习predicate相关的方法 * 对泛型指定数据类型进行判断, 得到一个布尔值. * 包含与或非and, or, negate * @author jhmarryme.cn * @date 2019/7/22 12:54 */public class LambdaForPredicateDemo &#123; public static Boolean method( Predicate&lt;String&gt; stringPredicate)&#123; return stringPredicate.test(\"helloWorld\"); &#125; public static void method(Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2)&#123; final boolean helloWorld = p1.or(p2).test(\"HelloWorld\"); System.out.println(helloWorld); &#125; public static ArrayList&lt;String&gt; filterString(String[] arr, Predicate&lt;String&gt; stringPredicate)&#123; final ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String s : arr) &#123; if (stringPredicate.test(s)) &#123; list.add(s); &#125; &#125; return list; &#125; public static void main(String[] args) &#123; /*System.out.println(method(s -&gt; &#123; return s.length() &gt; 5; &#125;));*/// method(s -&gt; s.contains(\"el\"), s -&gt; s.length() &gt; 10); /** * 筛选条件: * 必须为女生； * 姓名为4个字。 */ String[] array = &#123; \"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\", \"赵丽颖,女\" &#125;; final ArrayList&lt;String&gt; arrayList = filterString(array, s -&gt; &#123; return s.split(\",\")[1].equals(\"女\") &amp;&amp; s.split(\",\")[0].length() == 4; &#125;); for (String s : arrayList) &#123; System.out.println(s); &#125; &#125;&#125; 2.6.6. lambda延迟加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546package javaBase.functionalInterface.DelayForLambda;import static javaBase.functionalInterface.DelayForLambda.MessageBuilder.MAX_NUM;/** * 测试lambda表达式的延迟执行 * 优化性能, 在不符合条件时, 不会执行lambda的内容 * @author jhmarryme.cn * @date 2019/7/22 9:32 */public class DelayForLambdaDemo &#123; public static void log(int level, MessageBuilder builder)&#123; if (level == 1) &#123; System.out.println(builder.messageBuilder()); &#125; &#125; public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; //这里的拼接字符串 在条件不成立时不会执行 log(1, () -&gt; msgA + msgB + msgC ); &#125;&#125;package javaBase.functionalInterface.DelayForLambda;/** * @author jhmarryme.cn * @date 2019/7/22 9:33 */@FunctionalInterfacepublic interface MessageBuilder &#123; int MAX_NUM = 97; /** * 测试lambda延迟加载 * @return */ String messageBuilder();&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"socket网络编程","slug":"note/cyc2018/socket/socket网络编程","date":"2019-07-21T19:37:33.000Z","updated":"2019-07-21T14:05:39.825Z","comments":true,"path":"2019/07/22/note/cyc2018/socket/socket网络编程/","link":"","permalink":"https://wangdaye7.github.io/2019/07/22/note/cyc2018/socket/socket网络编程/","excerpt":"","text":"1. socket编程 1.1. 面向TCP的网络编程 1.2. 简单的本地通信 1.3. 简单的文件上传 2. 总结 1. socket编程1.1. 面向TCP的网络编程今天学完socket编程, 发现其实java中的socket编程是非常简单的, 当然今天只接触了本地通信, 没有涉及到远端通信的问题. 不知道会不会牵扯到更多的东西. 其实只要把步骤理解清楚, 是非常容易的. 今天也没有接触到更深的关于tcp的东西, 所以学起来很简单. 主要记录的也是编程的一些步骤, 具体查阅API即可. 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 1.2. 简单的本地通信为了方便, 在这里把客户端服务端写到了一起, 两个线程启用. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package javaBase.socket;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;/** * @author jhmarryme.cn * @date 2019/7/21 20:01 */public class TcpCommunication &#123; static int count = 0; public static void main(String[] args) &#123; //创建服务端线程 new Thread(() -&gt; &#123; System.out.print(++count); System.out.println(\"服务器正在启动, 等待连接中\"); try &#123; //1. 创建serverSocket对象, 等待连接 ServerSocket serverSocket = new ServerSocket(6666); //2. 连接成功, 返回Socket对象 Socket accept = serverSocket.accept(); //3. 通过连接的socket获取输入流 InputStream inputStream = accept.getInputStream(); //4. 解析输入流中数据 byte[] b = new byte[1024]; final int len = inputStream.read(b); System.out.print(++count); System.out.println(new String(b, 0, len)); //5. 通过socket获取输出流 final OutputStream outputStream = accept.getOutputStream(); //6. 发送数据到客户端 System.out.print(++count); outputStream.write(\"这是服务端发送的数据\".getBytes()); outputStream.close(); inputStream.close(); serverSocket.close(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;).start(); //创建客户端线程 new Thread(() -&gt; &#123; try&#123; System.out.print(++count); System.out.println(\"客户端启动成功\"); //1. 创建socket连接 Socket socket = new Socket(\"localhost\", 6666); //2. 获取输出流 final OutputStream outputStream = socket.getOutputStream(); //3. 发出数据 System.out.print(++count); outputStream.write(\"这是客户端发送的数据: hello\".getBytes()); //4. 获取输入流 final InputStream inputStream = socket.getInputStream(); //5. 显示接受到的数据 byte[] bytes = new byte[1024]; final int len = inputStream.read(bytes); System.out.print(++count); System.out.println(new String(bytes, 0, len)); inputStream.close(); outputStream.close(); socket.close(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 1.3. 简单的文件上传 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 客户端实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package javaBase.socket.fileUpload;import java.io.*;import java.net.Socket;/** * @author jhmarryme.cn * @date 2019/7/21 20:34 */public class FileUploadClient &#123; public static void main(String[] args) throws IOException &#123; //1. 连接服务器 final Socket socket = new Socket(\"localhost\", 6666); //2. 发送文件 //2.1 读取本地文件 final BufferedInputStream localBufferedIn = new BufferedInputStream( new FileInputStream(\"C:\\\\Users\\\\jhmarryme\\\\Downloads\\\\未命名文件.png\") ); //2.2 创建远程输出流 final BufferedOutputStream remoteBufferedOut = new BufferedOutputStream(socket.getOutputStream()); //2.3 缓冲区 int len = -1; byte[] bytes = new byte[8 * 1024]; //2.4 上传到服务器 while ( (len = localBufferedIn.read(bytes)) != -1 )&#123; remoteBufferedOut.write(bytes, 0, len);// remoteBufferedOut.flush(); // 采用关闭输出流的方式通知服务端, 因此不需要这个了 &#125; socket.shutdownOutput(); System.out.println(\"文件发送完毕\"); //接收来自服务端的信息 final InputStream remoteIn = socket.getInputStream(); byte[] back = new byte[100]; remoteIn.read(back); System.out.println(new String(back)); remoteIn.close(); //释放资源 socket.close(); localBufferedIn.close(); &#125;&#125; 服务端实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package javaBase.socket.fileUpload;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author jhmarryme.cn * @date 2019/7/21 20:34 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123;//1. 创建服务器, 等待连接 final ServerSocket serverSocket = new ServerSocket(6666); String parent = \"D:\\\\develop\\\\folderForDevelop\\\\\"; while (true)&#123; //2. 连接成功 final Socket accept = serverSocket.accept(); // 如果连接成功的话会继续进行. new Thread(() -&gt; &#123; try ( //3.1 获取远程输入流 BufferedInputStream in = new BufferedInputStream(accept.getInputStream()); //3.2 获取本地输出流 final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(new File(parent + System.currentTimeMillis() + \".txt\"))); )&#123; //4. 保存文件到本地 //4.1 缓冲区 byte[] bytes = new byte[1024 * 8]; int len = -1; //4.2 保存 while( (len = in.read(bytes)) != -1 )&#123; out.write(bytes, 0, len); &#125; //5. 回写数据 final OutputStream remoteOut = accept.getOutputStream(); remoteOut.write(\"上传成功\".getBytes()); //关闭资源 accept.close(); remoteOut.close(); System.out.println(\"文件已保存\"); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 2. 总结重点就是分清步骤, 其实总体来说很简单.今天接触的知识比较浅, 没有做更深入的学习, 等以后学习了再进行补充.","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"几个简单的递归练习","slug":"note/cyc2018/recursion/几个简单的递归练习","date":"2019-07-21T14:40:28.000Z","updated":"2019-07-21T06:41:51.872Z","comments":true,"path":"2019/07/21/note/cyc2018/recursion/几个简单的递归练习/","link":"","permalink":"https://wangdaye7.github.io/2019/07/21/note/cyc2018/recursion/几个简单的递归练习/","excerpt":"","text":"打印当前目录下所有文件及目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package javaBase.recursion;import java.io.File;import java.util.*;/** * @author jhmarryme.cn * @date 2019/7/21 11:17 */public class PrintAllDirs &#123; private static Map&lt;String, List&lt;String&gt;&gt; map; /** * 测试打印当前目录下所有文件及目录 * @param args */ public static void main(String[] args) &#123; map = new HashMap&lt;&gt;(); File dir = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\"); printDir(dir); for (Map.Entry&lt;String, List&lt;String&gt;&gt; stringListEntry : map.entrySet()) &#123; String key = stringListEntry.getKey(); System.out.println(key + \": \"); List&lt;String&gt; value = stringListEntry.getValue(); for (String s : value) &#123; System.out.println(s); &#125; System.out.println(); &#125; &#125; /** * 将当前目录下所有文件名及目录名 一一对应显示出来 * @param dir */ public static void printDir(File dir) &#123; //先获取所有文件及目录 File[] files = dir.listFiles(); for (File file : files) &#123; //如果是文件则直接存入 if (file.isFile())&#123; String parent = file.getParent(); List&lt;String&gt; strings = map.get(parent); if (strings == null) &#123; strings = new ArrayList&lt;&gt;(); map.put(parent, strings); &#125; strings.add(file.getName()); &#125; else &#123; printDir(file); &#125; &#125; &#125;&#125; 递归求和, 阶乘1234567891011121314151617181920212223242526272829303132333435363738394041424344package javaBase.recursion;/** * @author jhmarryme.cn * @date 2019/7/21 11:07 */public class SimpleRecursionTest &#123; /** * 测试 * @param args */ public static void main(String[] args) &#123; System.out.println(getSumByRecursion(10)); System.out.println(getFactorial(5L)); &#125; /** * 递归求1~n的和 * @param n * @return */ public static int getSumByRecursion(int n)&#123; if (n == 1)&#123; return n; &#125; return n + getSumByRecursion(n - 1); &#125; /** * 递归求阶乘 * @param n * @return */ public static Long getFactorial(Long n)&#123; if (n == 1) &#123; return n; &#125; return n * getFactorial(n - 1); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"Hello World","slug":"allTemp/hello-world","date":"2019-07-21T01:59:52.488Z","updated":"2019-05-21T03:34:11.139Z","comments":true,"path":"2019/07/21/allTemp/hello-world/","link":"","permalink":"https://wangdaye7.github.io/2019/07/21/allTemp/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"通用mapper使用记录","slug":"allTemp/通用mapper使用记录","date":"2019-07-18T18:33:58.000Z","updated":"2019-09-15T15:50:10.859Z","comments":true,"path":"2019/07/19/allTemp/通用mapper使用记录/","link":"","permalink":"https://wangdaye7.github.io/2019/07/19/allTemp/通用mapper使用记录/","excerpt":"","text":"基础的查询主要是记录一下平时使用过的一些用法, 以防忘了 单条件查询12345678910111213141516/** * 根据parentId查询子类目 * @param pid * @return */public List&lt;Category&gt; queryCategoryListByPid(Long pid) &#123; Category category = new Category(); category.setParentId(pid); List categories = categoryMapper.select(category); //判断结果 if (CollectionUtils.isEmpty(categories))&#123; //未找到, 通过自定义异常处理 throw new LyException(ExceptionEnum.CATEGORY_NOT_FOUND); &#125; return categories;&#125; 结合PageHelper, 通过Example查询1234567891011121314151617181920212223242526public PageResult&lt;Brand&gt; queryBrandByPage(Integer page, Integer rows, String key, String sortBy, Boolean desc) &#123; //分页 PageHelper.startPage(page, rows); //创建一个查询对象, 需要传入字节码 Example example = new Example(Brand.class); //过滤 if (StringUtils.isNotBlank(key))&#123; // 创建查询条件 example.createCriteria().orLike(\"name\", \"%\"+key+\"%\"). orEqualTo(\"letter\", key.toUpperCase()); //表中首字母为大写, 将用户输入相应转换 &#125; //排序 if (StringUtils.isNotBlank(sortBy)) &#123; example.setOrderByClause(sortBy + (desc ? \" DESC\" : \" ASC\")); //拼接字符串时需要注意加上空格 &#125; //查询 List&lt;Brand&gt; brands = brandMapper.selectByExample(example); if (CollectionUtils.isEmpty(brands)) &#123; throw new LyException(ExceptionEnum.BRAND_NOT_FOUND); &#125; //将查询结果封装到PageInfo中, 以便获取分页数据 PageInfo&lt;Brand&gt; brandPageInfo = new PageInfo&lt;&gt;(brands); //返回PageResult return new PageResult&lt;&gt;(brandPageInfo.getTotal(), brands);&#125; 保留空字段的简单插入12345678910111213141516171819public void saveBrand(Brand brand, List&lt;Long&gt; cids) &#123; //1. 保存品牌 //主键自动生成, 确保传入的为null brand.setId(null); //mapper的insertSelective可以保存有空字段的对象 int count = brandMapper.insertSelective(brand); if (count != 1) &#123; throw new LyException(ExceptionEnum.BRAND_SAVE_ERROR); &#125; //2. 将品牌ID和分类ID存入中间表 for (Long cid : cids) &#123; count = brandMapper.insertCategoryAndBrand(brand.getId(), cid); if (count != 1) &#123; throw new LyException(ExceptionEnum.BRAND_SAVE_ERROR); &#125; &#125;&#125; 根据idList查询批量插入InsertList","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[]},{"title":"通用异常处理","slug":"note/temp/通用异常处理","date":"2019-07-18T16:14:19.000Z","updated":"2019-09-08T14:23:31.851Z","comments":true,"path":"2019/07/19/note/temp/通用异常处理/","link":"","permalink":"https://wangdaye7.github.io/2019/07/19/note/temp/通用异常处理/","excerpt":"","text":"通用异常处理处理异常信息时, 通过SpringMVC的AOP拦截异常, 返回错误信息 环境依赖: (不引用启动器, 版本由父工程管理) 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 自定义枚举类用于异常信息 12345678910@Getter@AllArgsConstructor@NoArgsConstructorpublic enum ExceptionEnum &#123; //价格不能为空 PRICE_CANNOT_BE_NULL(400, \"价格不能为空\") ; private int code; private String message;&#125; 自定义信息类 12345678910111213@Datapublic class ExceptionResult &#123; private int status; private String message; private Long timestamp; public ExceptionResult(ExceptionEnum exceptionEnum) &#123; this.status = exceptionEnum.getCode(); this.message = exceptionEnum.getMessage(); this.timestamp = System.currentTimeMillis(); &#125;&#125; 自定义异常类 1234567@AllArgsConstructor@NoArgsConstructor@Getterpublic class LyException extends RuntimeException &#123; //接受枚举作为参数 private ExceptionEnum exceptionEnum;&#125; 自定义通用异常拦截器 12345678910//要想该类被扫描到, 必须和应用启动器的类处于同一个包下 @ControllerAdvicepublic class CommonExceptionHandler &#123; @ExceptionHandler(LyException.class) public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; //返回的是整个响应消息, 其中主要配置错误码和响应体 return ResponseEntity.status(e.getExceptionEnum().getCode()).body(new ExceptionResult(e.getExceptionEnum())); &#125;&#125; 应用 123456789101112131415@RestController@RequestMapping(\"item\")public class ItemController &#123; @Autowired private ItemService itemService; @PostMapping public ResponseEntity&lt;Item&gt; saveItem(Item item)&#123; //校验价格 if (item.getPrice() == null) &#123; //传递一个枚举变量 throw new LyException(ExceptionEnum.PRICE_CANNOT_BE_NULL); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(item); &#125;&#125; 补充","categories":[{"name":"待整理","slug":"待整理","permalink":"https://wangdaye7.github.io/categories/待整理/"}],"tags":[]},{"title":"命令备忘","slug":"note/temp/命令备忘","date":"2019-07-18T15:42:19.000Z","updated":"2019-09-08T14:23:21.084Z","comments":true,"path":"2019/07/18/note/temp/命令备忘/","link":"","permalink":"https://wangdaye7.github.io/2019/07/18/note/temp/命令备忘/","excerpt":"","text":"rabbitmq-server startnginx -s reload./elasticsearch","categories":[{"name":"待整理","slug":"待整理","permalink":"https://wangdaye7.github.io/categories/待整理/"}],"tags":[]},{"title":"File与流","slug":"note/cyc2018/File/File及基本流学习记录","date":"2019-07-17T11:52:41.000Z","updated":"2019-07-24T13:30:35.958Z","comments":true,"path":"2019/07/17/note/cyc2018/File/File及基本流学习记录/","link":"","permalink":"https://wangdaye7.github.io/2019/07/17/note/cyc2018/File/File及基本流学习记录/","excerpt":"","text":"1. 思维导图 2. File类 2.1. 新建/打开文件 3. IO流 3.1. 字节流 3.1.1. 通过字节流复制文件 3.2. 字符流 3.3. IO异常的处理 4. 缓冲流 4.1. 字节缓冲流和字符缓冲流 4.1.1. 字符缓冲流特有方法 4.1.2. 复制大文件 5. 转换流 6. 序列化 6.1. ObjectOutputStream类和ObjectInputStream类 6.1.1. 主要方法 7. 打印流 8. 总结 1. 思维导图 2. File类以前对文件流的认识比较浅, 只是偶尔用到的时候查一下, 不懂的用法看一下. 但总归是经常需要使用到的东西, 这次就特地好好来学一下. 2.1. 新建/打开文件这里的我的主要学习点在新建文件和打开已有的文件上, 知道常用的方法就够了, 至于很多的方法在使用的时候总结归纳一下, 翻阅API就够用了. new File()的使用方法有很多种, 可以通过绝对路径创建和结合File与相对路径使用等等, 无论文件是否存在都能新建成功, 所以最好先用exists()方法确认文件是否存在再进行下一步操作.当文件不存在时, 通过createNewFile()创建. 下面是代码练习: 12345678910111213141516171819202122232425262728293031package javaBase.File;import java.io.*;/** * @author jhmarryme.cn * @date 2019/7/17 11:57 */public class CreateFileDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\\", \"WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\"); System.out.println(file.isDirectory()); if (file.isDirectory()) &#123; File hello = new File(file, \"hellWorld.java\"); if (!hello.exists()) &#123; System.out.println(hello.exists()); hello.createNewFile(); System.out.println(hello.exists()); &#125; &#125; //查看 for (String s : file.list()) &#123; System.out.println(s); &#125; for (File listFile : file.listFiles()) &#123; System.out.println(listFile.getAbsolutePath()); &#125; &#125;&#125; 3. IO流3.1. 字节流字节流的使用很简单, 感觉平常使用的也不多, 所以就简单测试了一下用法。 重点也就是两个常用的输入输出流：OutputStream InputStream 使用的也是两个子类 FileInputStream FileOutputStream 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package javaBase.File;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;/** * @author jhmarryme.cn * @date 2019/7/21 13:46 */public class FileReadAndWrite &#123; public static void main(String[] args) &#123;// testFileWrite(); testReadFile(); &#125; public static void testReadFile()&#123; File file = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld.txt\"); try &#123; FileInputStream inputStream = new FileInputStream(file); int read;/* //无参read 返回的是int类型的数据, 转换为char可以显示 while( (read = inputStream.read()) != -1 )&#123; System.out.print( ( char)read); &#125;*/ //用byte数组作为read的参数时, 返回的是读取的长度 byte[] bytes = new byte[2]; while ((read = inputStream.read(bytes) ) != -1)&#123; System.out.print(new String(bytes,0, read)); &#125; inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 文件写入 */ public static void testFileWrite()&#123; File file = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld.txt\"); if (!file.isDirectory()) &#123; System.out.println(file.getAbsolutePath()); try &#123; //为true代表追加写入, 为false或不写则清空文件 FileOutputStream outputStream = new FileOutputStream(file,true); outputStream.write(\"helloWorld\".getBytes()); outputStream.write(\"\\r\\n\".getBytes()); outputStream.write(97); outputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.1.1. 通过字节流复制文件 打开文件流 -&gt; 循环读写 -&gt; 关闭文件 123456789101112131415161718192021/** * 测试复制文件 */public static void testCopyFile() throws IOException &#123; //打开源文件 FileInputStream source = new FileInputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld.txt\"); //打开目标文件, 不存在 FileOutputStream target = new FileOutputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld-back.txt\"); //指定缓冲数组大小 byte[] b = new byte[1024]; int len = -1; while ( (len = source.read(b)) != -1 )&#123; target.write(b, 0, len); &#125; source.close(); target.close();&#125; 3.2. 字符流使用基本和字节流一致. 3.3. IO异常的处理JDK9的改进,无需手动close :123456789// 被final修饰的对象final Resource resource1 = new Resource(\"resource1\");// 普通对象Resource resource2 = new Resource(\"resource2\");// 引入方式：直接引入try (resource1; resource2) &#123; // 使用对象&#125; 4. 缓冲流4.1. 字节缓冲流和字符缓冲流 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 使用方法很简单, 就是在已有的IO流上继续构建一个缓冲流相比于普通的IO流, 缓冲流处理的速度非常快 4.1.1. 字符缓冲流特有方法 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 4.1.2. 复制大文件测试用法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package javaBase.File;import java.io.*;/** * @author jhmarryme.cn * @date 2019/7/21 15:27 */public class FileReadByBufferdStream &#123; public static void main(String[] args) &#123; copyFileByBufferedStream(); &#125; /** * 通过缓冲流复制大文件 */ public static void copyFileByBufferedStream() &#123; String parent = \"C:\\\\Users\\\\jhmarryme\\\\Downloads\"; long length = 0; long currentTimeMillis = System.currentTimeMillis(); try ( BufferedInputStream inputStream = new BufferedInputStream( new FileInputStream(parent + \"\\\\我是大哥大.Kyou.kara.Ore.wa.Ep08.Chi_Jap.HDTVrip.1280X720-ZhuixinFan.mp4\")); BufferedOutputStream outputStream = new BufferedOutputStream( new FileOutputStream(parent + \"\\\\dageda.mp4\")); )&#123; byte[] bytes = new byte[8 * 1024]; int len = -1; while ( (len = inputStream.read(bytes)) != -1 )&#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(\"复制所花费的时间\" + (System.currentTimeMillis() - currentTimeMillis)); &#125;&#125; 5. 转换流 InputStreamReaderOutputStreamWriter 主要用来处理编码格式问题. 123456789101112131415161718192021222324252627282930313233343536package javaBase.File;import java.io.FileInputStream;import java.io.FileReader;import java.io.InputStreamReader;/** * @author jhmarryme.cn * @date 2019/7/21 15:56 */public class FileReadAndWriteByConversionStream &#123; public static void main(String[] args) &#123; testRead(); &#125; /** * 读取GB2312格式的文件 */ public static void testRead()&#123; try (// FileReader reader = new FileReader(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\test.txt\"); InputStreamReader reader = new InputStreamReader( new FileInputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\test.txt\"), \"GB2312\" ); )&#123; int read; while ((read = reader.read()) != -1)&#123; System.out.print((char)read); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 6. 序列化 Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 6.1. ObjectOutputStream类和ObjectInputStream类6.1.1. 主要方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 public final void writeObject (Object obj) : 将指定的对象写出。 public final Object readObject () : 读取一个对象。 实体类:1234567891011121314151617package javaBase.File;import lombok.Data;import java.io.Serializable;@Datapublic class Employee implements Serializable &#123; private static final long serialVersionUID = 8915532794959050340L; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125; 测试代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package javaBase.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;/** * @author jhmarryme.cn * @date 2019/7/21 16:24 */public class ObjectSerializable &#123; public static void main(String[] args) &#123; testSerializable(); testDeserializable(); &#125; /** * 反序列化对象 */ public static void testDeserializable()&#123; Employee employee = null; try ( final ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\employee.txt\")); )&#123; employee = (Employee) inputStream.readObject(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(employee.getAge()); &#125; /** * 序列化对象 */ public static void testSerializable()&#123; Employee employee = new Employee(); employee.setAge(23); employee.setName(\"王豪\"); employee.setAddress(\"荣昌\"); try ( //序列化流对象 final ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\employee.txt\")); )&#123; outputStream.writeObject(employee); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 7. 打印流可以用来改变打印流向, 从控制台转向文件. 1234567891011121314151617package javaBase.File;import java.io.FileNotFoundException;import java.io.PrintStream;/** * @author jhmarryme.cn * @date 2019/7/21 16:41 */public class TestPrintStream &#123; public static void main(String[] args) throws Exception &#123; final PrintStream printStream = new PrintStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\test.txt\"); System.setOut(printStream); System.out.println(\"hello\"); &#125;&#125; 8. 总结不管是字节流和字符流, 构造方法的参数可以为 路径或File对象. 字符流主要用来处理文本文件.使用字符流的时候如果 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 字节流则不会. 但是可以通过flush方法强制刷新缓冲区.字符流可以很方便的处理字符串.字符流，只能操作文本文件，不能操作图片，视频等非文本文件。缓冲流效率最佳. 学习完这些基本流后, 大概对文件的操作有了初步的认识. 合理的选择要使用的流. 在需要效率的时候选择缓冲流. 当文件格式需要处理的时候, 选择转换流进行处理. 正确的选择要使用的格式很重要.","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"生产者消费者问题简单模拟","slug":"note/cyc2018/thread/生产者消费者问题简单模拟","date":"2019-07-15T11:34:56.000Z","updated":"2019-07-24T06:34:11.869Z","comments":true,"path":"2019/07/15/note/cyc2018/thread/生产者消费者问题简单模拟/","link":"","permalink":"https://wangdaye7.github.io/2019/07/15/note/cyc2018/thread/生产者消费者问题简单模拟/","excerpt":"","text":"一次简单的测试. 产品: 1234567891011package javaBase.thread.producerAndConsumer;/** * @author jhmarryme.cn * @date 2019/7/15 11:17 */public class Product &#123; String color; String size; boolean flag = false;&#125; 消费者:123456789101112131415161718192021222324252627282930313233343536package javaBase.thread.producerAndConsumer;/** * 消费者 * @author jhmarryme.cn * @date 2019/7/15 11:24 */public class Consumer extends Thread &#123; Product product; public Consumer(String name, Product product) &#123; super(name); this.product = product; &#125; @Override public void run() &#123; while (true)&#123; synchronized (product)&#123; String name = Thread.currentThread().getName(); if (!product.flag) &#123; try &#123; product.wait(); System.out.println(name + \" : 产品未生产, 正在等待\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + \"正在消费产品\" + product.color + product.size); product.flag = false; product.notify(); &#125; &#125; &#125;&#125; 生产者: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package javaBase.thread.producerAndConsumer;/** * 生产者 * @author jhmarryme.cn * @date 2019/7/15 11:18 */public class Producer extends Thread &#123; Product product; public Producer(String name, Product product) &#123; super(name); this.product = product; &#125; @Override public void run() &#123; int count = 0; while(true)&#123; synchronized (product)&#123; //存在未被消费的商品 String name = Thread.currentThread().getName(); if (product.flag)&#123; try &#123; System.out.println(name + \": 存在未被消费的商品, 正在等待\"); product.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + \"开始生产产品\"); if (count % 2 == 0) &#123; product.color = \"绿色\"; product.size = \"大号\"; &#125; else &#123; product.color = \"红色\"; product.size = \"小号\"; &#125; product.flag = true; System.out.println(name + \"生产商品成功\"); System.out.println(name + \"正在等待消费\"); product.notify(); &#125; &#125; &#125;&#125; 测试类: 12345678910111213141516171819package javaBase.thread.producerAndConsumer;/** * @author jhmarryme.cn * @date 2019/7/15 11:29 */public class PCDemo &#123; /** * 测试生产者消费者问题 * @param args */ public static void main(String[] args) &#123; Product product = new Product(); new Producer(\"生产者\", product).start(); new Consumer(\"消费者\", product).start(); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"lambda简单使用","slug":"note/cyc2018/lambda/lambda简单使用","date":"2019-07-15T11:11:23.000Z","updated":"2019-07-24T06:34:32.303Z","comments":true,"path":"2019/07/15/note/cyc2018/lambda/lambda简单使用/","link":"","permalink":"https://wangdaye7.github.io/2019/07/15/note/cyc2018/lambda/lambda简单使用/","excerpt":"","text":"用法记录Lambda表达式的标准格式为 (参数类型 参数名称) -&gt; { 代码语句 } 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda的使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"Linux补充","slug":"linux/Linux补充","date":"2019-07-14T20:34:03.000Z","updated":"2019-09-10T01:50:37.310Z","comments":true,"path":"2019/07/15/linux/Linux补充/","link":"","permalink":"https://wangdaye7.github.io/2019/07/15/linux/Linux补充/","excerpt":"","text":"Linux体系结构 查看当前系统shell版本echo $SHELL 查看支持的所有shellcat /etc/shells 切换shell版本chsh -s 版本 实际切换无效. 当前发型版本cat /etc/issue 或者 sudo lsb_release -a 内核信息uname -a 查找特定的文件 find path [options] params 123find ~ -name \"JsonToString*\" 从用户家目录下查找find / -name \"JsonToString*\" 从根目录下查找find -name \"JsonToString*\" 从当前目录下 参数-iname 则表示忽略大小写 检索文件内容 grep [options] pattern file 全称: Global Regular Expression Print作用: 查找文件里符合条件的字符串 | 可以结合管道操作符使用 123456789101112131415grep \"moo\" targe* 查找以targe开头的文件并内容包含moo的文件find ~ | grep \"target\" 等同于 find ~ -name \"target*\"grep \"partial\\[true\\]\" log.info 查看日志中包含\"partial[true]\"的行 其中[] 需要转义grep \"partial\\[true\\]\" log.info | grep -o \"engine\\[[[:alnum:]]*\\]\" 再次进行过滤, 只显示\"partial[true]\"并且包含\"engine[任意数字字母]\"的行的 engine[xxxx] 部分, -o 表示只显示匹配的部分grep \"partial\\[true\\]\" log.info | grep -o \"engine\\[[0-9a-z]*\\]\"ps -ef | grep tomcat 查看tomcat信息 但是因为本条指令也在查询tomcat, 所以本条查询进程也会显示出来ps -ef | grep tomcat | grep -v \"grep\" 过滤掉该指令本身 对内容做统计 awk [options] ‘cmd’ file 一次读取一行文本, 按分隔符进行切片切片保存在内建的变量中 $1 $2 … $0为整行单引号 1234567# 先从/var/log目录下copy一份日志文件 这里选择的是dpkg.log# 查看第一, 四列的数据awk '&#123;print $1 $4&#125;' dpkg.log# 查看 第二列满足条件 或 第一行的数据awk '($2==\"14:42:45\") || NR==1 &#123;print $0&#125;' dpkg.log# 根据第二列的值统计出现过的次数awk '&#123;arr[$2]++&#125;END&#123;for(i in arr) print i \"\\t\" arr[i]&#125;' dpkg.log","categories":[],"tags":[]},{"title":"线程","slug":"note/cyc2018/thread/线程","date":"2019-07-09T11:27:02.000Z","updated":"2019-09-08T14:24:07.649Z","comments":true,"path":"2019/07/09/note/cyc2018/thread/线程/","link":"","permalink":"https://wangdaye7.github.io/2019/07/09/note/cyc2018/thread/线程/","excerpt":"","text":"1. 概念 1.1. 基本概念 1.2. 线程的状态 2. 基本方法 3. 线程的应用 3.1. 线程的创建 3.1.1. 两种创建的方式 3.1.2. 测试代码 3.1.3. Thread和Runnable的区别 3.2. 多线程 3.3. 线程的安全问题 3.3.1. 出现问题的代码 3.3.2. 线程同步 4. 线程池的使用 1. 概念1.1. 基本概念1个程序至少有一个进程,一个进程至少有一个线程. 程序 程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体 进程 是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 进程是”活的”. 线程 线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程 中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 1.2. 线程的状态在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 2. 基本方法java.lang.Thread类： 构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName():获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread():返回对当前正在执行的线程对象的引用。 3. 线程的应用3.1. 线程的创建3.1.1. 两种创建的方式 继承Thead并重写run方法 实现Runnable接口作为参数传递给Thead 可以使用匿名内部类或函数式编程 3.1.2. 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package javaBase.thread;/** * @author jhmarryme.cn * @date 2019/7/14 9:55 */public class CreateThreadFinalTest &#123; public static void main(String[] args) &#123; /*Thread th1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"thread1 -&gt; i = \" + i); &#125; &#125; &#125;);*/ Thread th1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"thread1 -&gt; i = \" + i); &#125; &#125;); th1.start(); Thread2 th2 = new Thread2(\"thread2\"); th2.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"main thread -&gt; i = \" + i); &#125; &#125;&#125;class Thread2 extends Thread&#123; public Thread2(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"thread2 -&gt; i = \" + i); &#125; &#125;&#125; 3.1.3. Thread和Runnable的区别一个类继承Thread，不适合资源共享。实现了Runable接口的话，很容易的实现资源共享。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 3.2. 多线程多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 3.3. 线程的安全问题3.3.1. 出现问题的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package javaBase.thread;/** * @author jhmarryme.cn * @date 2019/7/14 10:17 */public class ThreadSafeFinalTest &#123; public static void main(String[] args) &#123; Tickets tickets = new Tickets(); Thread th1 = new Thread(tickets, \"窗口1\"); Thread th3 = new Thread(tickets, \"窗口3\"); Thread th2 = new Thread(tickets, \"窗口2\"); th1.start(); th2.start(); th3.start(); &#125;&#125;class Tickets implements Runnable&#123; private int tickets = 100; @Override public void run() &#123; while(true)&#123; if (tickets&gt;0) &#123; //模拟出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + (tickets--) + \"张票\"); &#125; &#125; &#125;&#125; 出现了票重复买和不存在的票的情况 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 3.3.2. 线程同步 同步代码块 同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。任意new一个Object对象, 作为同步锁即可 同步方法 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 锁机制 java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock():加同步锁。 public void unlock():释放同步锁。 Lock lock = new ReentrantLock()即可 4. 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码： 12345678910111213141516171819package javaBase.thread.ThreadPool;/** * @author jhmarryme.cn * @date 2019/7/17 11:05 */public class RunnableForPool implements Runnable&#123; @Override public void run() &#123; System.out.println(\"线程准备\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" : 正在使用\"); System.out.println(Thread.currentThread().getName() + \"使用完毕\"); &#125;&#125; 线程池测试类： 123456789101112131415161718192021222324package javaBase.thread.ThreadPool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author jhmarryme.cn * @date 2019/7/17 11:06 */public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(3); // 创建Runnable实例对象 RunnableForPool r = new RunnableForPool(); // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取1个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"异常学习及简单应用","slug":"note/cyc2018/exception/异常学习及简单应用","date":"2019-07-09T11:27:02.000Z","updated":"2019-07-24T13:13:45.812Z","comments":true,"path":"2019/07/09/note/cyc2018/exception/异常学习及简单应用/","link":"","permalink":"https://wangdaye7.github.io/2019/07/09/note/cyc2018/exception/异常学习及简单应用/","excerpt":"","text":"1. 异常 1.1. 异常概念 1.2. 异常体系 1.3. 异常分类 1.4. 异常的处理 1.5. 自定义异常 2. 异常补充 2.1. 通用异常处理 1. 异常1.1. 异常概念 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2. 异常体系异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，一般来说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免。 Exception:表示异常，可做处理。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 1.3. 异常分类异常(Exception)的分类: 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.4. 异常的处理Java异常处理的五个关键字：try、catch、ﬁnally、throw、throws 1.5. 自定义异常异常类定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 2. 异常补充2.1. 通用异常处理处理异常信息时, 通过SpringMVC的AOP拦截异常, 返回错误信息 环境 123456// 依赖: (不引用启动器, 版本由父工程管理)``` yml&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 自定义枚举类用于异常信息 12345678910@Getter@AllArgsConstructor@NoArgsConstructorpublic enum ExceptionEnum &#123; //价格不能为空 PRICE_CANNOT_BE_NULL(400, \"价格不能为空\") ; private int code; private String message;&#125; 自定义信息类 12345678910111213@Datapublic class ExceptionResult &#123; private int status; private String message; private Long timestamp; public ExceptionResult(ExceptionEnum exceptionEnum) &#123; this.status = exceptionEnum.getCode(); this.message = exceptionEnum.getMessage(); this.timestamp = System.currentTimeMillis(); &#125;&#125; 自定义异常类 1234567@AllArgsConstructor@NoArgsConstructor@Getterpublic class LyException extends RuntimeException &#123; //接受枚举作为参数 private ExceptionEnum exceptionEnum;&#125; 自定义通用异常拦截器 12345678910//要想该类被扫描到, 必须和应用启动器的类处于同一个包下 @ControllerAdvicepublic class CommonExceptionHandler &#123; @ExceptionHandler(LyException.class) public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; //返回的是整个响应消息, 其中主要配置错误码和响应体 return ResponseEntity.status(e.getExceptionEnum().getCode()).body(new ExceptionResult(e.getExceptionEnum())); &#125;&#125; 应用 123456789101112131415@RestController@RequestMapping(\"item\")public class ItemController &#123; @Autowired private ItemService itemService; @PostMapping public ResponseEntity&lt;Item&gt; saveItem(Item item)&#123; //校验价格 if (item.getPrice() == null) &#123; //传递一个枚举变量 throw new LyException(ExceptionEnum.PRICE_CANNOT_BE_NULL); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(item); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"绪论","slug":"note/dataStructure/绪论","date":"2019-06-20T20:03:19.000Z","updated":"2019-09-08T14:23:57.637Z","comments":true,"path":"2019/06/21/note/dataStructure/绪论/","link":"","permalink":"https://wangdaye7.github.io/2019/06/21/note/dataStructure/绪论/","excerpt":"","text":"数据结构和算法的简单认识数据结构 基本概念 数据描述客观事物的符号. 可以输入, 可被处理. 数据元素组成数据的, 有一定意义的基本单位. 也被称为记录. 由若干个数据项构成. 数据项数据项是数据不可分割的最小单位. 数据对象性质相同的数据元素的集合, 是数据的子集. 数据结构相互之间存在一种或多种特定关系的数据元素的集合. 逻辑结构与物理结构 逻辑结构数据对象中数据元素之间的相互关系. 集合结构 线性结构 树形结构 图形结构 物理结构数据的逻辑结构在计算机中的存储形式 顺序存储结构 链式存储结构 数据类型 指一组性质相同的值得结合及定义在此集合上的一些操作的总称. 原子类型不可再分解. 结构类型若干个类型组合. 抽象数据类型 Abstract Data Type ADT, 指一个数学模型及定义在该模型上的一组操作. 总结 数据 -&gt; 数据对象 -&gt; 数据元素 -&gt; 数据项 算法 定义 是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令 特性 输入输入 可行性 确定性 有穷性 设计要求 正确性 可读性 健壮性 时间效率高和存储量低 函数的渐进增长 主要关心的是最高阶项的阶数 数据规模不同, 优劣性不同 时间复杂度 定义用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。 推导大O阶只要高阶项, 不要低阶项, 也不要高阶项系数 常数阶 线性阶 对数阶 平方阶 常见时间复杂度 -最坏情况与平均情况 空间复杂度","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wangdaye7.github.io/categories/数据结构/"}],"tags":[]},{"title":"HeadFirst设计模式读书笔记","slug":"note/designPattern/HFDesignPattern1","date":"2019-06-20T16:48:57.000Z","updated":"2019-07-04T01:42:00.926Z","comments":true,"path":"2019/06/21/note/designPattern/HFDesignPattern1/","link":"","permalink":"https://wangdaye7.github.io/2019/06/21/note/designPattern/HFDesignPattern1/","excerpt":"","text":"设计原则 类应该对扩展开放, 对修改关闭. 策略模式观察者模式装饰者模式记录 继承设计-&gt;编译时静态决定, 组合-&gt;运行时动态扩展","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://wangdaye7.github.io/categories/设计模式/"}],"tags":[]},{"title":"记录一次jdk编译-ubuntu16.04编译JDK7","slug":"note/jvm/记录一次jdk编译","date":"2019-06-19T20:23:15.000Z","updated":"2019-07-24T13:39:55.578Z","comments":true,"path":"2019/06/20/note/jvm/记录一次jdk编译/","link":"","permalink":"https://wangdaye7.github.io/2019/06/20/note/jvm/记录一次jdk编译/","excerpt":"","text":"0.1. 获取源码 0.2. 配置 0.3. 编译源码 0.4. 错误参考 0.5. 至此 编译成功 0.6. 编译完成之后 0.7. 总结 ubuntu16 环境下: 0.1. 获取源码 依赖 先安装一些依赖: 书上给出的依赖如下: 1sudo apt-get install build-essential gawk m4 openjdk-6-jdk libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif3 libmotif-dev ant 其中，openjdk-6-jdk 是不能直接apt-get 的，google以后Github-bmaupin给出了一个解决方案，我们可以直接去到openjdk，选择合适的包下载。下载前还需要注册一个Oracle帐号。下载好jdk-6u45-linux-x64.bin后复制到想要的目录并运行，相同目录下就会创建一个包含有jdk的文件夹。 libmotif3也不能直接安装，需要从libmotif3下载, 但是我是通过这种方式安装一直失败, 报错. 后来通过ubuntu的应用商店安装. 网上查阅的依赖如下: 12sudo apt-get updatesudo apt-get install build-essential gawk m4 libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif-common ant 这里我两种依赖都运行过, 书上给的依赖问题比较多, 所以随后我又安装这个依赖 这里通过下载好的源码进行: 首先是openjdk: 1234cd /home/jhmarryme/workspacesudo apt-get install unarsudo unar openjdk-7-fcs-src-b147-27_jun_2011.zipsudo mv openjdk /usr/openjdk 运行jdk.bin: 123456sudo chmod u+x jdk-6u45-linux-x64.binsudo ./jdk-6u45-linux-x64.bincd /usrsudo mkdir javacd -sudo mv jdk1.6.0_45 /usr/java/ 0.2. 配置配置文件: 1sudo vim /etc/profile 在后面追加如下内容: 12345678910111213141516171819202122232425262728293031323334##export LANG=C#BootStrap-JDKexport ALT_BOOTDIR=/usr/java/jdk1.6.0_45#OracleJDKexport ALT_JDK_IMPORT_PATH=/usr/java/jdk1.6.0_45#export ALLOW_DOWNLOADS=true#与你的CPU核数对应即可export HOTSPOT_BUILD_JOBS=1export ALT_PARALLEL_COMPILE_JOBS=1#export USE_PRECOMPILED_HEADER=true#export BUILD_LANGTOOLS=trueexport BUILD_JAXWS=false#export BUILD_JAXP=false#export BUILD_CORBA=falseexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport SKIP_COMPARE_IMAGES=true#BUILD_DEPLOY=false#BUILD_INSTALL=false#export ALT_OUTPUTDIR=/usr/openjdk/build#unset JAVA_HOMEunset CLASSPATH#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 0.3. 编译源码12cd /usr/openjdk/make sanity 末尾出现Sanity check passed. 则验证通过. 12source /etc/profilemake 0.4. 错误参考编译期间遇到一大堆错误, 逐个解决, 参考如下:主要安装参考1参考2参考3 需要注意的是 1234#错误error:\"__LEAF\"redefined [-Werror]#define __LEAF(result_type, header) \\^ 网上都说是在openjdk/hotspot/src/share/vm/runtime/interfaceSupport.hpp文件后追加, 但我修改之后没有效果, 我选择的是在该文件430行左右开始, 替换掉原本的定义. 不再报错. 12345678// LEAF routines do not lock, GC or throw exceptions #ifdef __LEAF #undef __LEAF #define __LEAF(result_type, header) \\TRACE_CALL(result_type, header) \\debug_only(NoHandleMark __hm;) \\/* begin of body */ #endif 1234567#错误/usr/openjdk/hotspot/src/share/vm/oops/constantPoolOop.cpp:272:39: error: converting 'false' to pointer type 'methodOop &#123;aka methodOopDesc*&#125;' [-Werror=conversion-null] if (cpool-&gt;cache() == NULL) return false; // nothing to load yet#错误/usr/openjdk/hotspot/src/share/vm/opto/loopnode.cpp:896:49: error: converting 'false' to pointer type 'Node*' [-Werror=conversion-null] if (expr == NULL || expr-&gt;req() != 3) return false; 0.5. 至此 编译成功 0.6. 编译完成之后 相关设置: 编译完成之后,进入OpenJDK源码下的build/j2sdk-image目录(或者build-debug、build- fastdebug这两个目录),这是整个JDK的完整编译结果,复制到JAVA_HOME目录,就可以作为一个完整的JDK使用,编译出来的虚拟机,在-version命令中带有用户的机器名。 操作如下: 12345678cd /usr/binln -s -f /usr/openjdk/build/j2sdk-image/bin/javaln -s -f /usr/openjdk/build/j2sdk-image/bin/javacjava -version#此时显示openjdk version \"1.7.0-internal\"OpenJDK Runtime Environment (build 1.7.0-internal-root_2019_06_20_02_16-b00)OpenJDK 64-Bit Server VM (build 21.0-b17, mixed mode) 运行虚拟机 在product下边（看网上都是在jvmg下边，我的jvmg下边没有gamma）的env.sh下加入, 完整路径/usr/openjdk/build/hotspot/outputdir/linux_amd64_compiler2/product 123LD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 我的是存在上述代码, 将export多余内容删除 1234567source ./env.sh./gamma -version#出现内容如下Using java runtime at: /usr/openjdk/build/j2sdk-image//jreopenjdk version \"1.7.0-internal\"OpenJDK Runtime Environment (build 1.7.0-internal-root_2019_06_20_02_16-b00)OpenJDK 64-Bit Server VM (build 21.0-b17, mixed mode) 0.7. 总结在选择获取jdk和openjdk源码时, 使用打包好的文件进行安装最为方便, 之前选用在线下载的方式时, 遇到了很多问题, 随后改为压缩包安装. 在整个编译的过程中, make的时候出现了很多问题, 我是一个一个去解决的, 其实这样太花时间了, 应该按照参考的错误解决方式全部修改后, 再次make. 会节约很多的时间. 最好是不要修改/etc/profile文件, 容易产生很多问题, 而是通过用户的sh完成. 但这里我还是修改的profile文件.","categories":[{"name":"java虚拟机读书笔记","slug":"java虚拟机读书笔记","permalink":"https://wangdaye7.github.io/categories/java虚拟机读书笔记/"}],"tags":[]},{"title":"深入理解java虚拟机读书笔记","slug":"note/jvm/深入理解java虚拟机读书笔记","date":"2019-06-17T08:49:40.000Z","updated":"2019-06-20T08:40:45.333Z","comments":true,"path":"2019/06/17/note/jvm/深入理解java虚拟机读书笔记/","link":"","permalink":"https://wangdaye7.github.io/2019/06/17/note/jvm/深入理解java虚拟机读书笔记/","excerpt":"","text":"走近java Java技术体系 sun官方定义Java包括以下组成部分: java程序设计语言 各种硬件平台上的java虚拟机 Class文件格式 JavaApi类库 第三方Java类库JDK: 支持java程序开发最小环境.(语言, 虚拟机, API)JRE: 支持java程序运行标准环境.(虚拟机, SE API子集)","categories":[],"tags":[]},{"title":"牛客算法学习part1","slug":"note/algorithm/牛客算法学习","date":"2019-06-16T20:59:43.000Z","updated":"2019-07-28T11:34:26.083Z","comments":true,"path":"2019/06/17/note/algorithm/牛客算法学习/","link":"","permalink":"https://wangdaye7.github.io/2019/06/17/note/algorithm/牛客算法学习/","excerpt":"","text":"1. 概念 1.1. 时间复杂度 1.2. 空间复杂度 1.3. 最优解 1.4. 排序的稳定性 2. 数组排序 2.1. 时间复杂度O(N^2),空间复杂度O(1) 2.1.1. 冒泡排序 2.1.2. 选择排序 2.1.3. 插入排序 2.2. 时间复杂度O(NlogN) 2.2.1. 归并排序 2.2.2. 快速排序 2.2.3. 堆排序 2.2.4. 桶排序 3. 延伸题型 3.1. 区别 3.1.1. merge与quick的区别 3.2. 归并延伸 3.2.1. 求小和 3.2.2. 降序对 3.3. 桶排序 3.3.1. 排序之后的相邻最大差值 1. 概念1.1. 时间复杂度 概念 时间复杂度为一个算法流程中, 常数操作数量的指标, 这个指标叫做O, big O.只要高阶项, 不要低阶项, 也不要高阶项系数, 剩下部分记为f(N), 时间复杂度为O(f(N)) 常数操作完成操作的时间与数据量无关 例子 寻找数组(长度N)中最大值变量max = 系统最小值, 遍历数组, 时间复杂度为O(N) 有序数组二分查找时间复杂度为O(logN) 默认以2为底 两个有序数组寻找相同的部分, 长度为N, M 循环遍历两个数组O(N * M) 遍历左边数组, 在右边数组二分查找O(N * logM) 外排, 假定无重复取两个数组的起始索引为P1, P2, 因为是寻找公共的部分且两个数组有序, 所以只有当a[P1] == a[p2]时指针才同时动, 如果当谁的值更小, 就单独移动谁的指针, 一直移动到两端值相等为止.O(N + M)最优解要根据实际的数据量进行确定, 当N的长度远小于M的时候, 通过第二种方法时间复杂度更小, 具体情况具体分析. 1.2. 空间复杂度 概念 空间复杂度一般指额外空间复杂度, 不算上输入输出需要的空间. 例子 数组中分成两个部分, 左右两个部分交换, 总长度为N 如12345 67, 交换为67 12345 通过一个辅助空间先存入67, 存入12345 空间复杂度为O(N) 直接在原数组中进行操作 通过一个辅助变量进行数组逆序, 得到7654321, 再对67单独逆序, 54321单独逆序, 得到结果6712345, 也可以先单独逆序, 再进行整体逆序 这里的空间复杂度为O(1) 1.3. 最优解一般情况下 先满足时间复杂度最优, 再满足空间复杂度最优. 1.4. 排序的稳定性无序数组中值相同的部分 排成有序之后相对次序保持不变 可以做到稳定 冒泡 插入 归并 不可以做到稳定 选择 快速 (可以做到, 论文级别, 很难 01 stable sort) 2. 数组排序2.1. 时间复杂度O(N^2),空间复杂度O(1)2.1.1. 冒泡排序123456789101112public static void bubbleSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int end = arr.length - 1; end &gt; 0; end--)&#123; for (int i = 0; i &lt; end; i ++)&#123; if (arr[i] &gt; arr[i + 1]) &#123; DigitalArrayUtil.swap(arr, i , i + 1); &#125; &#125; &#125;&#125; 2.1.2. 选择排序12345678910public static void selectionSort(int[] arr)&#123; int minIndex; for (int i = 0; i &lt; arr.length - 1; i++) &#123; minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; minIndex = (arr[minIndex] &lt; arr[j]) ? minIndex : j; &#125; DigitalArrayUtil.swap(arr, minIndex, i); &#125;&#125; 2.1.3. 插入排序 时间复杂度最好O(N), 最差O(N^2) 1234567public static void insertionSort(int[] arr)&#123;for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1] ; j--) &#123; DigitalArrayUtil.swap(arr, j, j + 1); &#125;&#125;&#125; 2.2. 时间复杂度O(NlogN)2.2.1. 归并排序 例如7 9 8 4 6 2, 先划分为798 462两个部分, 左边再划分成 79 8 , 左边再到7 9, 最后左边到7, 此时只剩一个数了, 不用再划分, 再依次与右边的进行有序合并的, 一直递归向上, 最后排序完成. 其实就是一个划分, 合并的过程.空间复杂度O(N)归并排序内部缓存法实现空间复杂度O(1)时间复杂度的计算过程$$T(n)=aT(\\frac{n}{b}) +O(n^{d})$$其中:$$ \\log _b a &gt; d \\Rightarrow O(n^{log _b a})$$$$ \\log _b a &lt; d \\Rightarrow O(n^d)$$$$ \\log _b a = d \\Rightarrow O(n^d * \\log n)$$a 为递归中子递归个数， n/b 为子递归的数据规模。这里a = 2, b = 2, d = 1其实就是 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; sortProcess(arr, 0, arr.length - 1);&#125;/** * 归并 * @param arr * @param L * @param R */public static void sortProcess(int[] arr, int L, int R)&#123; if (L == R)&#123; return; &#125; int mid = (R - L) / 2 + L; sortProcess(arr, L, mid); sortProcess(arr, mid + 1, R); merge(arr, L, mid, R);&#125;/** * 外排合并 * @param arr * @param L * @param mid * @param R */public static void merge(int[] arr, int L, int mid, int R)&#123; int[] help = new int[R - L + 1]; int p1 = L; int p2 = mid + 1; int i = 0; while (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; //只会有一个越界, 只会处理一个while循环 while(p1 &lt;= mid)&#123; help[i++] = arr[p1++]; &#125; while(p2 &lt;= R)&#123; help[i++] = arr[p2++]; &#125; for (int j = 0; j &lt; help.length; j++) &#123; arr[L + j] = help[j]; &#125;&#125; 2.2.2. 快速排序 快速排序的思想基本上还是将问题划分, 然后递归进行.总体上划分为三个区域, 大于区, 小于区, 等于区.再接着在大于区和小于区上进行同样的划分, 最后排序成功 最好的时间复杂度为O(NlogN), 最差为O(N²), 空间复杂度O(logN) 123456789101112131415161718192021222324252627282930313233private static void quickSort(int[] arr, int L, int R)&#123; if (L &lt; R)&#123; //随机快速排序 DigitalArrayUtil.swap(arr, L + (int)(Math.random() * (R - L + 1)), R); //划分区域 int[] partition = partition(arr, L, R); quickSort(arr, L, partition[0] - 1); quickSort(arr, partition[1] + 1, R); &#125;&#125;private static int[] partition(int[] arr, int L, int R)&#123; int less = L - 1; //为了少用一个变量, 这里大于区域直接指向最后一位, 就避免了最后被改变, 但要在最后进行交换 int more = R; //一直循环到大于区域为止 while(L &lt; more)&#123; if (arr[L] &lt; arr[R]) &#123; //如果属于小于区域 DigitalArrayUtil.swap(arr, L++, ++less); &#125; else if (arr[L] &gt; arr[R])&#123; //如果属于大于区域, 因为此时所在的位置是等于区, 所以指针不动, 接着比较, 直到进入正确的大于区域 DigitalArrayUtil.swap(arr, L, --more); &#125; else&#123; //属于等于区域, 不做改变 L++; &#125; &#125; //为之前的准备 做交换 DigitalArrayUtil.swap(arr, more, R); // 值得注意的是这里等于区域到more为止, 因为之前最后一位作为保留, 后又进行了交换, 所以大于区域的第一位实际是等于区的数 return new int[]&#123;less + 1, more&#125;;&#125; 2.2.3. 堆排序时间复杂度O(N*logN)，额外空间复杂度O(1) 堆可以看成一个二叉树，所以可以考虑使用二叉树的表示方法来表示堆。但是因为堆中元素按照一定的优先顺序排列，因此可以使用更简单的方法——数组——来表示，这样可以节省子节点指针空间，并且可以快速访问每个节点。 如果只是建立堆的过程，时间复杂度为O(N) 堆排序其实就是一个建立大根堆之后进行循环处理的过程, 在简单理解了堆的结构之后理解堆排序其实不难. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package chapter2;import utils.DigitalArrayUtil;import java.util.Arrays;/** * @author jhmarryme.cn * @date 2019/7/4 10:42 */public class Code_05_HeapSort &#123; /** * 堆排序 * 1. 建立大根堆 * 2. 堆循环处理 * 2.1 首尾交换 * 2.2 调整位置 * @param arr */ public static void heapSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; //建立大根堆 for (int i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i); &#125; int size = arr.length; while (--size &gt; 0)&#123; DigitalArrayUtil.swap(arr, 0, size); heapfiy(arr, 0, size); &#125; &#125; /** * 交换首尾后的 堆排序处理 * @param arr * @param index * @param heapSize */ private static void heapfiy(int[] arr, int index, int heapSize) &#123; int left = index * 2 + 1; while (left &lt; heapSize)&#123; // 当右节点存在且大于左节点时 取右节点 int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; largest = arr[index] &gt; arr[largest] ? index :largest; if (largest == index) &#123; // 代表子节点没有比自己大的了 break; &#125; DigitalArrayUtil.swap(arr, index, largest); index = largest; left = index * 2 + 1; &#125; &#125; /** * 建立大根堆 * @param arr * @param index */ private static void heapInsert(int[] arr, int index) &#123; while(arr[index] &gt; arr[(index - 1) / 2])&#123; DigitalArrayUtil.swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; /** * 测试堆排序 * @param args */ public static void main(String[] args) &#123; int testTime = 50000; int size = 100; int value = 100; boolean success = true; long l = System.currentTimeMillis(); for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = DigitalArrayUtil.generateRandomArray(size, value); int[] arr2 = Arrays.copyOf(arr1, arr1.length); heapSort(arr1); DigitalArrayUtil.comparator(arr2); if (!DigitalArrayUtil.isEqual(arr1, arr2)) &#123; success = false; break; &#125; &#125; long l2 = System.currentTimeMillis(); System.out.println(\"success = \" + success); System.out.println(\"运行时间 = \" + (l2 - l)); &#125;&#125; 2.2.4. 桶排序 不是基于比较的算法 例如有几亿个数, 范围是0~200, 那么只需要准备201个桶, 遍历一遍数组把对应的数字放入桶内, 最后再将桶内的数字依次倒出来组成新的数组. 但是虽然很快, 但实际用的不多. 实际应用中一般需要排序的很少是基本类型, 都是自定义的类型. 而桶排序需要分析数据的状况, 不具备通用性. 容器类型决定稳定性, 使用队列结构作为容器是稳定的, 栈结构就不稳定 计数排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package chapter2;import utils.DigitalArrayUtil;import java.util.Arrays;import java.util.stream.Stream;/** * @author jhmarryme.cn * @date 2019/7/28 10:35 */public class Code_06_BucketSort &#123; /** * 计数排序 * @param arr */ private static void bucketSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; int max = Integer.MIN_VALUE; for (int i : arr) &#123; max = Math.max(i, max); &#125; int[] bucket = new int[max + 1]; for (int i : arr) &#123; bucket[i]++; &#125; int index = 0; for (int i = 0; i &lt; bucket.length; i++) &#123; while(bucket[i]-- &gt; 0)&#123; arr[index++] = i; &#125; &#125; &#125; /** * 测试桶排序 * @param args */ public static void main(String[] args) &#123; int testTime = 50000; int size = 100; int value = 100; boolean success = true; long l = System.currentTimeMillis(); for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = new int[(int) ((size + 1) * Math.random())]; for (int j = 0; j &lt; arr1.length; j++) &#123; arr1[j] = ((int)(Math.random() * 201)); &#125; int[] arr2 = Arrays.copyOf(arr1, arr1.length); bucketSort(arr1); DigitalArrayUtil.comparator(arr2); if (!DigitalArrayUtil.isEqual(arr1, arr2)) &#123; success = false; break; &#125; &#125; long l2 = System.currentTimeMillis(); System.out.println(\"success = \" + success); System.out.println(\"运行时间 = \" + (l2 - l)); &#125;&#125; 基数排序 3. 延伸题型3.1. 区别3.1.1. merge与quick的区别 系统中基础类型使用quick, 自定义class类型用merge类型 稳定性, 基础类型排序不考虑稳定性所以用quick, merge是稳定的. 3.2. 归并延伸3.2.1. 求小和 利用归并排序的特点, 在进行排序过程中计算小和的总和. 3.2.2. 降序对 也是利用归并排序, 求降序对. 3.3. 桶排序3.3.1. 排序之后的相邻最大差值 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序","categories":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/categories/算法/"}],"tags":[]},{"title":"EffectiveJava读书笔记","slug":"note/effectiveJava/EffectiveJava读书笔记","date":"2019-05-23T08:59:37.000Z","updated":"2019-09-08T14:23:50.249Z","comments":true,"path":"2019/05/23/note/effectiveJava/EffectiveJava读书笔记/","link":"","permalink":"https://wangdaye7.github.io/2019/05/23/note/effectiveJava/EffectiveJava读书笔记/","excerpt":"","text":"1.引言 侧重点: 熟悉如何用习惯和高效的方式来构建代码而不是理解语言的核心, 词汇表。 书中内容不讨论性能， 更偏向于编写出清晰， 正确， 可用， 简装， 灵活和可维护的程序。 java支持的四种类型： 接口（包活注释）， 类（包括enum）, 数组, 基本类型 前三种为引用类型. 类实例和数组为对象. 类的成员由它的域, 方法, 成员类, 成员接口组成. 2.创建和销毁对象","categories":[{"name":"EffectiveJava读书笔记","slug":"EffectiveJava读书笔记","permalink":"https://wangdaye7.github.io/categories/EffectiveJava读书笔记/"}],"tags":[]},{"title":"商品数据结构及界面","slug":"项目记录/商品数据结构及界面","date":"2019-05-22T18:22:25.000Z","updated":"2019-05-22T10:22:57.067Z","comments":true,"path":"2019/05/23/项目记录/商品数据结构及界面/","link":"","permalink":"https://wangdaye7.github.io/2019/05/23/项目记录/商品数据结构及界面/","excerpt":"","text":"1.商品规格数据结构乐优商城是一个全品类的电商网站，因此商品的种类繁多，每一件商品，其属性又有差别。为了更准确描述商品及细分差别，抽象出两个概念：SPU和SKU，了解一下： 1.1.SPU和SKUSPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集 SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品 以图为例来看： 本页的 华为Mate10 就是一个商品集（SPU） 因为颜色、内存等不同，而细分出不同的Mate10，如亮黑色128G版。（SKU） 可以看出： SPU是一个抽象的商品集概念，为了方便后台的管理。 SKU才是具体要销售的商品，每一个SKU的价格、库存可能会不一样，用户购买的是SKU而不是SPU 1.2.数据库设计分析1.2.1.思考并发现问题弄清楚了SPU和SKU的概念区分，接下来我们一起思考一下该如何设计数据库表。 首先来看SPU，大家一起思考下SPU应该有哪些字段来描述？ 123456789id:主键title：标题description：描述specification：规格packaging_list：包装after_service：售后服务comment：评价category_id：商品分类brand_id：品牌 似乎并不复杂，但是大家仔细思考一下，商品的规格字段你如何填写？ 不同商品的规格不一定相同，数据库中要如何保存？ 再看下SKU，大家觉得应该有什么字段？ 12345678id：主键spu_id：关联的spuprice：价格images：图片stock：库存颜色？内存？硬盘？ 碰到难题了，不同的商品分类，可能属性是不一样的，比如手机有内存，衣服有尺码，我们是全品类的电商网站，这些不同的商品的不同属性，如何设计到一张表中？ 1.2.2.分析规格参数仔细查看每一种商品的规格你会发现： 虽然商品规格千变万化，但是同一类商品（如手机）的规格是统一的，有图为证： 华为的规格： 三星的规格： 也就是说，商品的规格参数应该是与分类绑定的。每一个分类都有统一的规格参数模板，但不同商品其参数值可能不同。 如下图所示： 1.2.3.SKU的特有属性SPU中会有一些特殊属性，用来区分不同的SKU，我们称为SKU特有属性。如华为META10的颜色、内存属性。 不同种类的商品，一个手机，一个衣服，其SKU属性不相同。 同一种类的商品，比如都是衣服，SKU属性基本是一样的，都是颜色、尺码等。 这样说起来，似乎SKU的特有属性也是与分类相关的？事实上，仔细观察你会发现，SKU的特有属性是商品规格参数的一部分： 也就是说，我们没必要单独对SKU的特有属性进行设计，它可以看做是规格参数中的一部分。这样规格参数中的属性可以标记成两部分： 所有sku共享的规格属性（称为全局属性） 每个sku不同的规格属性（称为特有属性） 1.2.4.搜索属性打开一个搜索页，我们来看看过滤的条件： 你会发现，过滤条件中的屏幕尺寸、运行内存、网路、机身内存、电池容量、CPU核数等，在规格参数中都能找到： 也就是说，规格参数中的数据，将来会有一部分作为搜索条件来使用。我们可以在设计时，将这部分属性标记出来，将来做搜索的时候，作为过滤条件。要注意的是，无论是SPU的全局属性，还是SKU的特有属性，都有可能作为搜索过滤条件的，并不冲突，而是有一个交集： 1.3.规格参数表1.3.1.整体数据结构我们观察页面的规格参数结构： 可以看到规格参数是分组的，每一组都有多个参数键值对。不过对于规格参数的模板而言，其值现在是不确定的，不同的商品值肯定不同，模板中只要保存组信息、组内参数信息即可。 因此我们设计了两张表： tb_spec_group：组，与商品分类关联 tb_spec_param：参数名，与组关联，一对多 1.3.2.规格组规格参数分组表：tb_spec_group 1234567CREATE TABLE `tb_spec_group` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` bigint(20) NOT NULL COMMENT &apos;商品分类id，一个分类下有多个规格组&apos;, `name` varchar(50) NOT NULL COMMENT &apos;规格组的名称&apos;, PRIMARY KEY (`id`), KEY `key_category` (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数的分组表，每个商品分类下有多个规格参数组&apos;; 规格组有3个字段： id：主键 cid：商品分类id，一个分类下有多个模板 name：该规格组的名称。 1.3.2.规格参数规格参数表：tb_spec_param 1234567891011121314CREATE TABLE `tb_spec_param` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` bigint(20) NOT NULL COMMENT &apos;商品分类id&apos;, `group_id` bigint(20) NOT NULL, `name` varchar(255) NOT NULL COMMENT &apos;参数名&apos;, `numeric` tinyint(1) NOT NULL COMMENT &apos;是否是数字类型参数，true或false&apos;, `unit` varchar(255) DEFAULT &apos;&apos; COMMENT &apos;数字类型参数的单位，非数字类型可以为空&apos;, `generic` tinyint(1) NOT NULL COMMENT &apos;是否是sku通用属性，true或false&apos;, `searching` tinyint(1) NOT NULL COMMENT &apos;是否用于搜索过滤，true或false&apos;, `segments` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;数值类型参数，如果需要搜索，则添加分段间隔值，如CPU频率间隔：0.5-1.0&apos;, PRIMARY KEY (`id`), KEY `key_group` (`group_id`), KEY `key_category` (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数组下的参数名&apos;; 按道理来说，我们的规格参数就只需要记录参数名、组id、商品分类id即可。但是这里却多出了很多字段，为什么？ 还记得我们之前的分析吧，规格参数中有一部分是 SKU的通用属性，一部分是SKU的特有属性，而且其中会有一些将来用作搜索过滤，这些信息都需要标记出来。 通用属性 用一个布尔类型字段来标记是否为通用： generic来标记是否为通用属性： true：代表通用属性 false：代表sku特有属性 搜索过滤 与搜索相关的有两个字段： searching：标记是否用作过滤 true：用于过滤搜索 false：不用于过滤 segments：某些数值类型的参数，在搜索时需要按区间划分，这里提前确定好划分区间 比如电池容量，0~2000mAh，2000mAh~3000mAh，3000mAh~4000mAh 数值类型 某些规格参数可能为数值类型，这样的数据才需要划分区间，我们有两个字段来描述： numberic：是否为数值类型 true：数值类型 false：不是数值类型 unit：参数的单位 2.商品规格参数管理2.1.页面布局2.1.1.整体布局打开规格参数页面，看到如下内容： 商品分类树我们之前已经做过，所以这里可以直接展示出来。 因为规格是跟商品分类绑定的，因此首先会展现商品分类树，并且提示你要选择商品分类，才能看到规格参数的模板。一起了解下页面的实现： 页面结构： 这里使用了v-layout来完成页面布局，并且添加了row属性，代表接下来的内容是行布局（左右）。 可以看出页面分成2个部分： &lt;v-flex xs3&gt;：左侧，内部又分上下两部分：商品分类树及标题 v-card-title：标题部分，这里是提示信息，告诉用户要先选择分类，才能看到模板 v-tree：这里用到的是我们之前讲过的树组件，展示商品分类树， &lt;v-flex xs9 class=&quot;px-1&quot;&gt;：右侧：内部是规格参数展示 2.1.2.右侧规格当我们点击一个分类时，最终要达到的效果： 可以看到右侧分为上下两部分： 上部：面包屑，显示当前选中的分类 下部：table，显示规格参数信息 页面实现： 可以看到右侧并不是我们熟悉的 v-data-table，而是一个spec-group组件和spec-param组件，这是我们定义的独立组件： 在SpecGroup中定义了表格： 2.2.规格组的查询2.2.1.规格组和规格参数的切换当我们点击规格参数组，表格中的数据会变为该组下的规格参数： 两者间的切换是如何实现的呢？ 我们看到在spec-group和spec-param中，通过v-show来控制是否显示，对应的属性是：showGroup: showGroup为true，则展示分组；为false，则展示组内参数。 2.2.2.树节点的点击事件当我们点击树节点时，要将v-dialog打开，因此必须绑定一个点击事件： 我们来看下handleClick方法： 点击事件发生时，发生了两件事： 记录当前选中的节点，选中的就是商品分类 showGroup被置为true，则规格组就会显示了。 同时，我们把被选中的节点（商品分类）的id传递给了SpecGroup组件： 2.2.3.页面查询规格组来看下SpecGroup.vue中的实现： 我们查看页面控制台，可以看到请求已经发出： 2.2.4.后端代码 实体类 在ly-item-interface中添加实体类： 12345678910111213@Table(name = \"tb_spec_group\")public class SpecGroup &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private String name; // getter和setter省略&#125; 在ly-item-service中编写业务： mapper 12public interface SpecGroupMapper extends Mapper&lt;SpecGroup&gt; &#123;&#125; controller 先分析下需要的东西，在页面的ajax请求中可以看出： 请求方式：查询，肯定是get 请求路径：/spec/groups/{cid} ，这里通过路径占位符传递商品分类的id 请求参数：商品分类id 返回结果：页面是直接把resp.data赋值给了groups： 那么我们返回的应该是规格组SpecGroup的集合 代码： 12345678910111213141516@RestController@RequestMapping(\"spec\")public class SpecificationController &#123; @Autowired private SpecificationService specificationService; @GetMapping(\"groups/&#123;cid&#125;\") public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; querySpecGroups(@PathVariable(\"cid\") Long cid)&#123; List&lt;SpecGroup&gt; list = this.specificationService.querySpecGroups(cid); if(list == null || list.size() == 0)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list); &#125;&#125; service: 123456789101112@Servicepublic class SpecificationService &#123; @Autowired private SpecGroupMapper specGroupMapper; public List&lt;SpecGroup&gt; querySpecGroups(Long cid) &#123; SpecGroup t = new SpecGroup(); t.setCid(cid); return this.specGroupMapper.select(t); &#125;&#125; 页面访问测试： 目前，我们数据库只为手机分类（76）提供了规格组： 我们访问：http://api.leyou.com/api/item/spec/groups/76 然后在后台系统中测试： 2.3.规格参数查询2.3.1.表格切换当我们点击规格组，会切换到规格参数显示，肯定是在规格组中绑定了点击事件： 我们看下事件处理： 可以看到这里是使用了 父子通信，子组件触发了select事件： 再来看下父组件的事件绑定： 事件处理： 这里我们记录了选中的分组，并且把标记设置为false，这样规格组就不显示了，而是显示：SpecParam 并且，我们把group也传递到spec-param组件： 2.3.2.页面查询规格参数我们来看SpecParam.vue的实现： 查看页面控制台，发现请求已经发出： 2.3.3.后台实现 实体类： 1234567891011121314151617@Table(name = \"tb_spec_param\")public class SpecParam &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private Long groupId; private String name; @Column(name = \"`numeric`\") private Boolean numeric; private String unit; private Boolean generic; private Boolean searching; private String segments; // getter和setter ...&#125; controller 分析： 请求方式：GET 请求路径：/spec/params 请求参数：gid，分组id 返回结果：该分组下的规格参数集合List&lt;SpecParam&gt; 代码： 1234567891011@GetMapping(\"/params\")public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; querySpecParam( @RequestParam(value=\"gid\", required = false) Long gid )&#123; List&lt;SpecParam&gt; list = this.specificationService.querySpecParams(gid); if(list == null || list.size() == 0)&#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list); &#125; service 12345public List&lt;SpecParam&gt; querySpecParams(Long gid)&#123; SpecParam t = new SpecParam(); t.setGroupId(gid); return this.specParamMapper.select(t);&#125; mapper 12public interface SpecParamMapper extends Mapper&lt;SpecParam&gt; &#123;&#125; 测试： 在页面刷新： 2.4.增、删、改（作业）增删改的作业就留给大家去完成了。页面中接口都已定义，你要做的就是实现后台接口。 3.SPU和SKU数据结构规格确定以后，就可以添加商品了,先看下数据库表 3.1.SPU表3.1.1.表结构SPU表： 1234567891011121314CREATE TABLE `tb_spu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;spu id&apos;, `title` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;标题&apos;, `sub_title` varchar(255) DEFAULT &apos;&apos; COMMENT &apos;子标题&apos;, `cid1` bigint(20) NOT NULL COMMENT &apos;1级类目id&apos;, `cid2` bigint(20) NOT NULL COMMENT &apos;2级类目id&apos;, `cid3` bigint(20) NOT NULL COMMENT &apos;3级类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;商品所属品牌id&apos;, `saleable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否上架，0下架，1上架&apos;, `valid` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0已删除，1有效&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime DEFAULT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=208 DEFAULT CHARSET=utf8 COMMENT=&apos;spu表，该表描述的是一个抽象的商品，比如 iphone8&apos;; 与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。 我们做了表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail 123456789CREATE TABLE `tb_spu_detail` ( `spu_id` bigint(20) NOT NULL, `description` text COMMENT &apos;商品描述信息&apos;, `generic_spec` varchar(3000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;通用规格参数数据&apos;, `special_spec` varchar(1000) NOT NULL COMMENT &apos;特有规格参数及可选值信息，json格式&apos;, `packing_list` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;包装清单&apos;, `after_service` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;售后服务&apos;, PRIMARY KEY (`spu_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这张表中的数据都比较大，为了不影响主表的查询效率我们拆分出这张表。 需要注意的是这两个字段：generic_spec和special_spec。 3.1.2.spu中的规格参数前面讲过规格参数与商品分类绑定，一个分类下的所有SPU具有类似的规格参数。SPU下的SKU可能会有不同的规格参数，因此我们计划是这样： SPU中保存通用的规格参数信息。 SKU中保存特有规格参数。 来看下我们的 表如何存储这些信息： 3.1.2.1.generic_spec字段首先是generic_spec，其中保存通用规格参数信息的值，这里为了方便查询，使用了json格式： 整体来看： json结构，其中都是键值对： key：对应的规格参数的spec_param的id value：对应规格参数的值 3.1.2.2.special_spec字段我们说spu中只保存通用规格参数，那么为什么有多出了一个special_spec字段呢？ 以手机为例，品牌、操作系统等肯定是全局通用属性，内存、颜色等肯定是特有属性。 当你确定了一个SPU，比如小米的：红米4X 全局属性值都是固定的了： 12品牌：小米型号：红米4X 特有属性举例： 123颜色：[香槟金, 樱花粉, 磨砂黑]内存：[2G, 3G]机身存储：[16GB, 32GB] 颜色、内存、机身存储，作为Sku特有属性，key虽然一样，但是SPU下的每一个sku，其值都不一样，所以值会有很多，形成数组。 我们在SPU中，会把特有属性的所有值都记录下来，形成一个数组： 里面又有哪些内容呢？ 来看数据格式： 也是json结构： key：规格参数id value：spu属性的数组 那么问题来：特有规格参数应该在sku中记录才对，为什么在spu中也要记录一份？ 因为我们有时候需要把所有规格参数都查询出来，而不是只查询1个sku的属性。比如，商品详情页展示可选的规格参数时： 刚好符号我们的结构，这样页面渲染就非常方便了。 3.2.SKU表3.2.1.表结构1234567891011121314CREATE TABLE `tb_sku` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;sku id&apos;, `spu_id` bigint(20) NOT NULL COMMENT &apos;spu id&apos;, `title` varchar(255) NOT NULL COMMENT &apos;商品标题&apos;, `images` varchar(1000) DEFAULT &apos;&apos; COMMENT &apos;商品的图片，多个图片以‘,’分割&apos;, `price` bigint(15) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;销售价格，单位为分&apos;, `indexes` varchar(100) COMMENT &apos;特有规格属性在spu属性模板中的对应下标组合&apos;, `own_spec` varchar(1000) COMMENT &apos;sku的特有规格参数，json格式&apos;, `enable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0无效，1有效&apos;, `create_time` datetime NOT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime NOT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`), KEY `key_spu_id` (`spu_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;sku表,该表表示具体的商品实体,如黑色的64GB的iphone 8&apos;; 还有一张表，代表库存： 1234567CREATE TABLE `tb_stock` ( `sku_id` bigint(20) NOT NULL COMMENT &apos;库存对应的商品sku id&apos;, `seckill_stock` int(9) DEFAULT &apos;0&apos; COMMENT &apos;可秒杀库存&apos;, `seckill_total` int(9) DEFAULT &apos;0&apos; COMMENT &apos;秒杀总数量&apos;, `stock` int(9) NOT NULL COMMENT &apos;库存数量&apos;, PRIMARY KEY (`sku_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;库存表，代表库存，秒杀库存等信息&apos;; 问题：为什么要将库存独立一张表？ 因为库存字段写频率较高，而SKU的其它字段以读为主，因此我们将两张表分离，读写不会干扰。 特别需要注意的是sku表中的indexes字段和own_spec字段。sku中应该保存特有规格参数的值，就在这两个字段中。 3.2.2.sku中的特有规格参数3.2.2.1.indexes字段在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下： 123456789101112131415&#123; \"4\": [ \"香槟金\", \"樱花粉\", \"磨砂黑\" ], \"12\": [ \"2GB\", \"3GB\" ], \"13\": [ \"16GB\", \"32GB\" ]&#125; 这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。 比如： 红米4X，香槟金，2GB内存，16GB存储 红米4X，磨砂黑，2GB内存，32GB存储 你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样： 红米4X，0,0,0 红米4X，2,0,1 既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。 这个设计在商品详情页会特别有用： 当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。 3.2.2.2.own_spec字段看结构： 1&#123;\"4\":\"香槟金\",\"12\":\"2GB\",\"13\":\"16GB\"&#125; 保存的是特有属性的键值对。 SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的值。 3.3.导入图片信息现在商品表中虽然有数据，但是所有的图片信息都是无法访问的，我们需要把图片导入到虚拟机： 首先，把课前资料提供的数据上传到虚拟机下：/leyou/static目录： 然后，使用命令解压缩： 1unzip images.zip 修改Nginx配置，使nginx反向代理这些图片地址： 1vim /opt/nginx/config/nginx.conf 修改成如下配置： 12345678910111213141516171819server &#123; listen 80; server_name image.leyou.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; # 将其它图片代理指向本地的/leyou/static目录 location / &#123; root /leyou/static/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125;","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"商品查询的实现","slug":"项目记录/商品查询的实现","date":"2019-05-22T18:15:40.000Z","updated":"2019-05-22T10:21:33.583Z","comments":true,"path":"2019/05/23/项目记录/商品查询的实现/","link":"","permalink":"https://wangdaye7.github.io/2019/05/23/项目记录/商品查询的实现/","excerpt":"","text":"4.商品查询4.1.效果预览接下来，我们实现商品管理的页面，先看下我们要实现的效果： 可以看出整体是一个table，然后有新增按钮。是不是跟昨天写品牌管理很像？ 4.2.页面请求先看整体页面结构： 并且在Vue实例挂载时就会发起查询： 我们刷新页面，可以看到浏览器发起已经发起了查询商品数据的请求： 因此接下来，我们编写接口即可。 4.3.后台提供接口页面已经准备好，接下来在后台提供分页查询SPU的功能： 4.3.1.实体类 SPU 123456789101112131415161718@Table(name = \"tb_spu\")@Datapublic class Spu &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间&#125; SPU详情 1234567891011@Table(name=\"tb_spu_detail\")@Datapublic class SpuDetail &#123; @Id private Long spuId;// 对应的SPU的id private String description;// 商品描述 private String specialSpec;// 商品特殊规格的名称及可选值模板 private String genericSpec;// 商品的全局规格属性 private String packingList;// 包装清单 private String afterService;// 售后服务&#125; 4.3.2.controller先分析： 请求方式：GET 请求路径：/spu/page 请求参数： page：当前页 rows：每页大小 key：过滤条件 saleable：上架或下架 返回结果：商品SPU的分页信息。 要注意，页面展示的是商品分类和品牌名称，而数据库中保存的是id，怎么办？ 我们可以新建一个类，继承SPU，并且拓展cname和bname属性，写到ly-item-interface 12345@Datapublic class SpuBo extends Spu &#123; private String cname; private String bname;&#125; 编写controller代码： 我们把与商品相关的一切业务接口都放到一起，起名为GoodsController，业务层也是这样 123456789101112131415161718@RestController@RequestMapping(\"spu\")public class GoodsController &#123; @Autowired private GoodsService goodsService; @GetMapping(\"page\") public ResponseEntity&lt;PageResult&lt;SpuBo&gt;&gt; querySpuByPage( @RequestParam(value = \"page\", defaultValue = \"1\") Integer page, @RequestParam(value = \"rows\", defaultValue = \"5\") Integer rows, @RequestParam(value = \"saleable\", required = false) Boolean saleable, @RequestParam(value = \"key\", required = false) String key )&#123; PageResult&lt;SpuBo&gt; spuBoPageResult = goodsService.querySpuByPage(page, rows, saleable, key); return ResponseEntity.ok(spuBoPageResult); &#125;&#125; 4.4.3.service所有商品相关的业务（包括SPU和SKU）放到一个业务下：GoodsService。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Servicepublic class GoodsService &#123; @Autowired private SpuMapper spuMapper; @Autowired private BrandService brandService; @Autowired private CategoryService categoryService; public PageResult&lt;SpuBo&gt; querySpuByPage(Integer page, Integer rows, Boolean saleable, String key) &#123; //控制每页大小 PageHelper.startPage(page, Math.min(rows, 200)); //创建查询对象 Example example = new Example(Spu.class); //创建查询条件 Example.Criteria criteria = example.createCriteria(); //是否下架 if (saleable != null) &#123; criteria.andEqualTo(\"saleable\", saleable); &#125; //过滤关键字 if (StringUtils.isNotBlank(key)) &#123; criteria.andLike(\"title\", \"%\" + key + \"%\"); &#125; //查询 //这里需要注意 将查询到的结果集强转为page对象, 为了取出查询结果的总条数 Page&lt;Spu&gt; spus = (Page&lt;Spu&gt;) spuMapper.selectByExample(example); if (CollectionUtils.isEmpty(spus)) &#123; throw new LyException(ExceptionEnum.GOODS_NOT_FOUND); &#125; //处理分类名和品牌名 List&lt;SpuBo&gt; spuBos = spus.stream().map(spu -&gt; &#123; //转换对象 SpuBo spuBo = new SpuBo(); BeanUtils.copyProperties(spu, spuBo); //处理分类名 List&lt;String&gt; cnames = categoryService.queryByIds(Arrays.asList(spuBo.getCid1(), spuBo.getCid2(), spuBo.getCid3())) .stream().map(cname -&gt; cname.getName()).collect(Collectors.toList()); spuBo.setCname(StringUtils.join(cnames, \"/\")); //处理品牌名 spuBo.setBname(brandService.queryById(spu.getBrandId()).getName()); //返回经过转换并处理的spubo return spuBo; &#125;).collect(Collectors.toList()); return new PageResult&lt;&gt;(spus.getTotal(), spuBos); &#125;&#125; 4.4.4.mapper12public interface SpuMapper extends Mapper&lt;Spu&gt; &#123;&#125; 4.4.5.Category中拓展查询名称的功能页面需要商品的分类名称需要在这里查询，因此要额外提供查询分类名称的功能， 在CategoryService中添加功能： 123public List&lt;Category&gt; queryByIds(List&lt;Long&gt; ids)&#123; return categoryMapper.selectByIdList(ids); &#125; mapper的selectByIDList方法是来自于通用mapper。不过需要我们在mapper上继承一个通用mapper接口： 12public interface CategoryMapper extends Mapper&lt;Category&gt;, IdListMapper&lt;Category, Long&gt; &#123;&#125; 4.5.测试刷新页面，查看效果： 基本与预览的效果一致，OK！","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"linux基础命令","slug":"linux/linux基础命令","date":"2019-05-13T23:47:55.000Z","updated":"2019-09-10T01:41:14.074Z","comments":true,"path":"2019/05/14/linux/linux基础命令/","link":"","permalink":"https://wangdaye7.github.io/2019/05/14/linux/linux基础命令/","excerpt":"","text":"快乐的命令行学习记录 简单命令跳转 pwd - rint name of current working directory cd - change directory ls - list directory contents cd cd 更改工作目录到你的家目录。 cd - 更改工作目录到先前的工作目录。 cd ˜user name 更改工作目录到用户家目录。 ls -a –all List all ﬁles, even those with names that begin with a period, which are normally not listed(i.e.,hidden). -d –directory Ordinaryly,if a directory is speciﬁed, ls will list the contents of the directory, not the directory itself. Use this option in conjunction with the -F –classify This option will append an indicator character to the endofeachlistedname. Forexample,a’/’ifthename is a directory. -h –human-readable Inlongformatlistings,displayﬁlesizesinhumanreadable format rather than in bytes. -l Display results in long format. -r –reverse Display the results in reverse order. Normally, ls display its results in ascending alphabetical order. -S Sort results by ﬁle size. -t Sort by modiﬁcation time. 探究 file less more less f,b 下一页, 上一页 G,g 末行, 首行 /characters, n 查找, 之前查找-h, q 帮助, 退出 操作文件和目录 cp – Copy ﬁles and directories mv – Move/rename ﬁles and directories mkdir – Create directories rm – Remove ﬁles and directories ln – Create hard and symbolic link 通配符 需要注意的:[[:class:]] 匹配任意一个属于指定字符类中的字符:[:alnum:] Matches any alphanumeric character[:alpha:] Matches any alphabetic character[:digit:] Matches any numeral[:lower:] Matches any lowercase letter[:upper] Matches any uppercase letter mkdir cp -a 复制包括属性, 所有权等所有信息 -i 交互, 确认 -r 递归 -u 更新 mv 与cp共享 u, v, i rm -f 暴力删除 i, r, v尽量使用前用ls进行测试 ln -s 符号连接 GUI中Ctrl+Shift拖动创建链接 使用命令 type –说明怎样解释一个命令名 which –显示会执行哪个可执行程序 man –显示命令手册页 info –显示命令 info whatis –显示一个命令的简洁描述 alias –创建命令别名 apropos类似于搜索, 比如apropos directory 就是搜索和文件夹相关的命令 等同于man -k directory aliasalias foo=’cd /usr; ls; cd -‘ 注意不能习惯性的等式加空格使用之前先测试是否存在: type foo删除: unalias foo单独的alias 查看系统中的所有别名切换用户后 alias将消失,一次性 重定向 cat - Concatenate ﬁles sort - Sort lines of text uniq - Report or omit repeated lines grep - Print lines matching a pattern wc - Print newline, word, and byte counts for each ﬁle head - Output the ﬁrst part of a ﬁle tail - Output the last part of a ﬁle tee - Read from standard input and write to standard output and ﬁles 重定向的简单使用 >的使用中, 如果发生错误不会将错误信息重定向 新建(或清除)文件的方法 > test.txt 两次> 为追加 0, 1, 2 分别为标准输入, 输出, 和错误 123ll /bin/usr 2&gt; ll-error.txt //将错误信息重定向到ll-error.txt文件中ll /bin/usr &gt; ll-output.txt 2&amp;&gt;1 //重定向标准输出到文件中, 在重定向标准错误到标准输出, (顺序不能乱)ll /bin/usr &amp;&gt; ll-output.txt //简化写法 cat的简单使用 不具备分页的功能, 可用作查看简短的文件.还可以将多个分离的文件重新拼接成一个文件 如有文件:movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099 12cat movie.mpeg.0* &gt; movie.mpeg//这里的顺序会正确的安排, 因为通配符会以有序的方式展开 世界上最低能的文字处理器..zZ: 123cat &gt; lazy_dog.txtThe quick brown fox jumped over the lazy dog.//输入完成 Ctrl+d 告诉cat, 标准输入中, 已达到文件末尾(EOF) 仅输入cat, 会从标准输入读取数据, 会等待输入数据 管道线 将一个命令的输出 通过| 操作符 来作为另一个命令的输入, 理解为一根管子的两头, 一头作为输入, 一头作为输出. 可结合过滤器进行简单排序 可结合uniq 报道或忽略重复行 12345678//简单的管道使用ll /usr/bin | less//结合过滤器进行排序, 这里用ll无法得到想要的结果ls /bin /usr/bin | sort | less//再结合uniq,默认删除重复行 仅显示重复的数据列表加上-d选项ls /bin /usr/bin | sort | uniq -d | less wc 打印行, 单词数, 字节数 grep 打印匹配行 可以用于复杂的匹配模式, 结合正则使用. -i / -d 忽略大小写 / 只打印不匹配的行 head/tail 打印开头/结尾 当只需要开头或结尾的内容时, 通过-n选项调整打印的行数. -f 实时刷新文件, 观察日志文件的时候很有用. Ctrl+c停止 1tail -f /var/log/messages tee 结合管道的使用 一个安装在管道上的小工具. 从标准输入读入数据, 并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。在某个中间处理阶段来捕捉一个管道线的内容. 1ls /usr/bin | tee ls.txt | grep zip shell echo的展开 字符 1echo * 路径名 12345678910#查看echo /usr/*/shareecho [[:upper:]]*ls -d .[!.]?* 显示隐藏文件 不包含. ..ls -d .* 显示包含. ..的隐藏文件 ls -A 显示所有文件 ls -a 大A与小a有区别 大A 不会显示.和.. (当前目录与父目录) 小a则会 波浪线 12echo ~jhmarryme如果账号存在则展开为指定用户的家目录名, 单独的~为当前用户家目录 算数表达式展开格式:$((expression)) 只支持整数 花括号 1234类似于for循环, 空格相当于分割符, 有一个空格隔开时会拆分成两部分单独显示,嵌套使用时逗号也做拆分用.与非嵌套不同.&#123;2..4&#125; &#123;2..4&#125; 将执行3+3=6次 如果&#123;2..4&#125;,&#123;2..4&#125; 将执行3*3=9次 而嵌套中&#123;&#123;2..4&#125;,&#123;2..4&#125;&#125; 将执行3+3=6次 12echo &#123;2017..2019&#125;-&#123;1..9&#125; &#123;2017..2019&#125;-&#123;10..12&#125; 参数展开 1echo $USER ， “USER” 的变量包含你的用户名。唤醒参数展开，查看 USER 中的内 容 命令替换 123echo $(ls)ls -l $(which cp) 把 which cp 的执行结果作为一个参数传递给 ls 命令file $(ls /usr/bin/* | grep zip) 管道线的输出结果成为 ﬁle 命令的参数列表。 双引号双引号可以用来保留原来的格式 12345ls -l \"two words.txt\" 可以显示文件名带有空格的文件echo $(cal)echo \"$(cal)\" 没有引号的命令替换导致命令行包含38个参数。 加上引号命令行只有一个参数，参数中包括嵌入的空格和换行符 单引号 123456[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USERtext /home/me/ls-output.txt a b foo 4 me[me@linuxbox ~]$ echo \"text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER\"text ~/*.txt &#123;a,b&#125; foo 4 me[me@linuxbox ~]$ echo 'text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER'text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER 随着引用程度加强，越来越多的展开被禁止。 转义字符反斜杠\\ 1234echo 命令带上 ‘-e’ 选项，能够解释转义序列。你可以把转义序列放在 $’ ’ 里面。 以下例子，使用 sleep 命令，一个简单的程序，它会等待指定的秒数，然后退出。 我们可以创建一个简单的倒数计数器：sleep 10; echo -e ”Time’s up\\a”我们也可以这样做：sleep 10; echo ”Time’s up” $’\\a’","categories":[{"name":"linux","slug":"linux","permalink":"https://wangdaye7.github.io/categories/linux/"}],"tags":[]},{"title":"Nginx及反向代理原理","slug":"项目记录/Nginx及反向代理原理","date":"2019-05-13T12:35:12.000Z","updated":"2019-05-21T03:10:15.380Z","comments":true,"path":"2019/05/13/项目记录/Nginx及反向代理原理/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/Nginx及反向代理原理/","excerpt":"","text":"什么是Nginx nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 nginx作为web服务器Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 nginx作为反向代理什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器(代理服务器)代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 安装和使用 安装 安装非常简单，把课前资料提供的nginx直接解压即可，绿色免安装，舒服！ 我们在本地安装一台nginx： 解压后，目录结构： conf：配置目录 contrib：第三方依赖 html：默认的静态资源目录，类似于tomcat的webapps logs：日志目录 nginx.exe：启动程序。可双击运行，但不建议这么做。 4.5. 反向代理流程启动nginx，然后用域名访问后台管理系统： 现在实现了域名访问网站了，中间的流程是怎样的呢？ 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：127.0.0.1 请求被发往解析得到的ip，并且默认使用80端口：http://127.0.0.1:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到127.0.0.1:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"项目介绍及技术选型","slug":"项目记录/项目介绍及技术选型","date":"2019-05-13T12:35:12.000Z","updated":"2019-06-19T14:09:44.639Z","comments":true,"path":"2019/05/13/项目记录/项目介绍及技术选型/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/项目介绍及技术选型/","excerpt":"","text":"2.乐优商城介绍2.1.项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单、秒杀商品 可以品论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2.系统架构2.2.1.架构图乐优商城架构缩略图，大图请参考课前资料： 2.2.2.系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 预览图： 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 Eureka注册中心 Zuul网关服务 Spring Cloud Config配置中心 … 3.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.0和MyBatis3 Spring Boot 2.0.1版本 Spring Cloud 最新版 Finchley.RC1 Redis-4.0 RabbitMQ-3.4 Elasticsearch-5.6.8 nginx-1.10.2： FastDFS - 5.0.8 MyCat Thymeleaf 3.2.开发环境为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 3.3.域名我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"centos安装FastDFS","slug":"项目记录/centos安装FastDFS","date":"2019-05-13T12:35:12.000Z","updated":"2019-05-21T03:10:45.635Z","comments":true,"path":"2019/05/13/项目记录/centos安装FastDFS/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/centos安装FastDFS/","excerpt":"","text":"1. Centos下安装FastDFS1.1 上传将课前资料中的文件上传到linux下的/home/leyou/fdfs目录: 1.2 安装依赖FastDFS运行需要一些依赖，在课前资料提供的虚拟中已经安装好了这些依赖，如果大家想要从头学习，可以按下面方式安装： 1.2.1 安装GCC依赖GCC用来对C语言代码进行编译运行，使用yum命令安装： 1sudo yum -y install gcc 1.2.2 安装unzip工具unzip工具可以帮我们对压缩包进行解压 1sudo yum install -y unzip zip 1.2.3 安装libevent1sudo yum -y install libevent 1.2.4 安装Nginx所需依赖1sudo yum -y install pcre pcre-devel zlib zlib-devel openssl openssl-devel 1.2.5 安装libfastcommon-master这个没有yum包，只能通过编译安装： 解压刚刚上传的libfastcommon-master.zip 1unzip libfastcommon-master.zip 进入解压完成的目录： 1cd libfastcommon-master 编译并且安装： 12sudo ./make.sh sudo ./make.sh install 到这里为止，所有依赖都已经安装完毕，接下来我们安装FastDFS： 1.3 安装FastDFS1.3.1 编译安装这里我们也采用编译安装，步骤与刚才的编译安装方式一样： 解压 1tar -xvf FastDFS_v5.08.tar.gz 进入目录 1cd FastDFS 编译并安装 12sudo ./make.sh sudo ./make.sh install 校验安装结果 1）安装完成，我们应该能在/etc/init.d/目录，通过命令ll /etc/init.d/ | grep fdfs看到FastDFS提供的启动脚本： 其中： fdfs_trackerd 是tracker启动脚本 fdfs_storaged 是storage启动脚本 2）我们可以在 /etc/fdfs目录，通过命令查看到以下配置文件模板： 其中： tarcker.conf.sample 是tracker的配置文件模板 storage.conf.sample 是storage的配置文件模板 client.conf.sample 是客户端的配置文件模板 1.3.2 启动trackerFastDFS的tracker和storage在刚刚的安装过程中，都已经被安装了，因此我们安装这两种角色的方式是一样的。不同的是，两种需要不同的配置文件。 我们要启动tracker，就修改刚刚看到的tarcker.conf，并且启动fdfs_trackerd脚本即可。 编辑tracker配置 首先我们将模板文件进行赋值和重命名： 12sudo cp tracker.conf.sample tracker.confsudo vim tracker.conf 打开tracker.conf，修改base_path配置： 1base_path=/leyou/fdfs/tracker # tracker的数据和日志存放目录 创建目录 刚刚配置的目录可能不存在，我们创建出来 1sudo mkdir -p /leyou/fdfs/tracker 启动tracker 我们可以使用 sh /etc/init.d/fdfs_trackerd 启动，不过安装过程中，fdfs已经被设置为系统服务，我们可以采用熟悉的服务启动方式： 1sudo service fdfs_trackerd start # 启动fdfs_trackerd服务，停止用stop 另外，我们可以通过以下命令，设置tracker开机启动： 1sudo chkconfig fdfs_trackerd on 1.3.3 启动storage我们要启动tracker，就修改刚刚看到的tarcker.conf，并且启动fdfs_trackerd脚本即可。 编辑storage配置 首先我们将模板文件进行赋值和重命名： 12sudo cp storage.conf.sample storage.confsudo vim storage.conf 打开storage.conf，修改base_path配置： 123base_path=/leyou/fdfs/storage # storage的数据和日志存放目录store_path0=/leyou/fdfs/storage # storage的上传文件存放路径tracker_server=192.168.56.101:22122 # tracker的地址 创建目录 刚刚配置的目录可能不存在，我们创建出来 1sudo mkdir -p /leyou/fdfs/storage 启动storage 我们可以使用 sh /etc/init.d/fdfs_storaged 启动，同样我们可以用服务启动方式： 1sudo service fdfs_storaged start # 启动fdfs_storaged服务，停止用stop 另外，我们可以通过以下命令，设置tracker开机启动： 1sudo chkconfig fdfs_storaged on 最后，通过ps -ef | grep fdfs 查看进程： 1.3.4 测试文件上传进入etc/fdfs 修改client.conf文件修改配置12tracker_server=我的ip:22122bash_path=/tmp 运行:12/usr/bin/fdfs_upload_file client.conf /leyou/fdfs/test_temp/1.jpg1.jpg为测试文件名 成功后返回图片的id:group1/M00/00/00/wKgUOFzhDo6AenHWAAAsdH-0lL4512.jpggroup1 组信息M00 对应store_path0/00/00 磁盘路径 1.4 安装Nginx及FastDFS模块1.4.1 FastDFS的Nginx模块 解压 1tar -xvf fastdfs-nginx-module_v1.16.tar.gz ​ 配置config文件 123456# 进入配置目录cd /home/leyou/fdfs/fastdfs-nginx-module/src/# 修改配置vim config# 执行下面命令（将配置中的/usr/local改为/usr）：:%s+/usr/local/+/usr/+g ​ 配置mod_fastdfs.conf 1234# 将src目录下的mod_fastdfs.conf复制到 /etc/fdfs目录：sudo cp mod_fastdfs.conf /etc/fdfs/# 编辑该文件sudo vim /etc/fdfs/mod_fastdfs.cof 修改一下配置： 1234connect_timeout=10 # 客户端访问文件连接超时时长（单位：秒）tracker_server=192.168.56.101:22122 # tracker服务IP和端口url_have_group_name=true # 访问链接前缀加上组名store_path0=/leyou/fdfs/storage # 文件存储路径 复制 FastDFS的部分配置文件到/etc/fdfs目录 12cd /home/leyou/fdfs/FastDFS/conf/cp http.conf mime.types /etc/fdfs/ ​ 1.4.2 安装Nginx如果没有安装过Nginx: 解压 1tar -xvf nginx-1.10.0.tar.gz ​ 配置 1sudo ./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/home/leyou/fdfs/fastdfs-nginx-module/src ​ 编译安装 1sudo make &amp;&amp; sudo make install 如果已经安装过: 进入解压后的安装包:cd nginx-1.10.0/ 配置:1./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/home/leyou/fdfs/fastdfs-nginx-module/src 编译 不要安装:make 备份之前的nginx1mv /usr/bin/nginx /usr/bin/nginx-bck 替换之前安装的1cp /home/leyou/nginx-1.10.0/objs/nginx /usr/bin/ ​ 配置nginx整合fastdfs-module模块 我们需要修改nginx配置文件，在/opt/nginx/config/nginx.conf文件中： 1sudo vim /opt/nginx/conf/nginx.conf 将文件中，原来的server 80{ ...} 部分代码替换为如下代码： 1234567891011121314151617181920server &#123; listen 80; server_name image.leyou.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 启动 123nginx # 启动nginx -s stop # 停止nginx -s reload # 重新加载配置","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"了解电商行业","slug":"项目记录/了解电商行业","date":"2019-05-13T12:35:12.000Z","updated":"2019-05-21T03:36:21.965Z","comments":true,"path":"2019/05/13/项目记录/了解电商行业/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/了解电商行业/","excerpt":"","text":"1.了解电商行业学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 1.1.项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1.传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2.互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 1.2.电商行业的发展1.2.1.钱景近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 1.2.2.数据来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 1.2.3.技术特点从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3.常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：咸鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4.一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。8000/s 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： ​ 公司现状： ​","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"ES6使用","slug":"项目记录/ES6使用","date":"2019-05-13T12:35:12.000Z","updated":"2019-09-15T15:54:58.647Z","comments":true,"path":"2019/05/13/项目记录/ES6使用/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/ES6使用/","excerpt":"","text":"4、ES6 语法指南后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 4.1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 4.2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 4.3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 4.3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log(\"循环外：\" + i) 结果： const const声明的变量是常量，不能被修改 4.3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 4.3.3.解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 4.3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: \"jack\", // 以前： eat: function (food) &#123; console.log(this.name + \"在吃\" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + \"在吃\" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + \"在吃\" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:\"jack\", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log(\"hello,\" + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log(\"hello,\" + name); 4.3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 123456let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： 4.3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123; resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123; reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value)&#123; // 异步执行成功后的回调&#125;); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value)&#123; // 异步执行成功后的回调&#125;).catch(function(error)&#123; // 异步执行失败后的回调&#125;) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) &#123; // 这里我们用定时任务模拟异步 setTimeout(() =&gt; &#123; const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) &#123; resolve(&quot;成功！num:&quot; + num) &#125; else &#123; reject(&quot;出错了！num:&quot; + num) &#125; &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123; console.log(msg);&#125;).catch(function (msg) &#123; console.log(msg);&#125;) 结果： 4.3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 4.3.8.模块化4.3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 4.3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; 我可以使用export将这个对象导出： 123456const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125;export util; 当然，也可以简写为： 12345export const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = \"jack\"var age = 21export &#123;name,age&#125; 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default &#123; sum(a,b)&#123; return a + b; &#125;&#125; 这样，当使用者导入时，可以任意起名字 4.3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import &#123;name, age&#125; from 'user.js'console.log(name + \" , 今年\"+ age +\"岁了\") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 4.3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 4.3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"Nginx配置","slug":"项目记录/Nginx配置","date":"2019-05-13T12:35:12.000Z","updated":"2019-05-21T03:10:08.522Z","comments":true,"path":"2019/05/13/项目记录/Nginx配置/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/Nginx配置/","excerpt":"","text":"nginx解决端口问题nginx作为反向代理如果使用虚拟机 需要修改项目里 config下的index.js 修改为host: ‘localhost’为 host: ‘0.0.0.0’ nginx配置安装Nginx 新增用户useradd leyou将文件上传到目录/home/leyou 解压 1tar -xvf nginx-1.10.0.tar.gz 配置 1./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx ​这里指定安装的目录是: /opt/nginx目录下 编译安装 12yum -y install openssl openssl-devel /如果遇到错误 先运行这个sudo make &amp;&amp; sudo make install 启动 123nginx # 启动nginx -s stop # 停止nginx -s reload # 重新加载配置 chkconfig iptables off 关闭防火墙service iptables stop 临时关闭防火墙 ###访问失败123456789101112131415161718开启80端口firewall-cmd --zone=public --add-port=80/tcp --permanent其中--permanent的作用是使设置永久生效，不加的话机器重启之后失效重新载入一下防火墙设置，使设置生效firewall-cmd --reload可通过如下命令查看是否生效firewall-cmd --zone=public --query-port=80/tcp如下命令可查看当前系统打开的所有端口firewall-cmd --zone=public --list-ports ps -ef | grep nginx 是否有两个进程, 如果只有一个可能是80端口被占用了 使用目录: /opt/nginx/conf下找配置文件 反向代理配置 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:9001; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 修改SwitchHosts 设置 , IP为虚拟机IP地址 设置nginx开机启动 创建一个开机启动的脚本： 1vim /etc/init.d/nginx 添加以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/usr/bin/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/opt/nginx/conf/nginx.conf\"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep \"configure arguments:.*--user=\" | sed 's/[^*]*--user=\\([^ ]*\\).*/\\1/g' -` if [ -n \"$user\" ]; then if [ -z \"`grep $user /etc/passwd`\" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d \"=\" -f 2` if [ ! -d \"$value\" ]; then # echo \"creating\" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;\" exit 2esac 修改文件权限，并加入服务列表 1234# 修改权限chmod 777 /etc/init.d/nginx # 添加到服务列表chkconfig --add /etc/init.d/nginx 设置开机启动 1chkconfig nginx on","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"后端工程创建","slug":"项目记录/后端工程创建","date":"2019-05-13T12:35:12.000Z","updated":"2019-07-14T08:31:26.255Z","comments":true,"path":"2019/05/13/项目记录/后端工程创建/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/后端工程创建/","excerpt":"","text":"3.4.创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写工程信息： 保存的位置信息： 然后将pom文件修改成我这个样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.jhmarryme.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.SR1&lt;/spring-cloud.version&gt; &lt;mybatis.starter.version&gt;1.3.2&lt;/mybatis.starter.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;mysql.version&gt;5.1.46&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;web.starter.version&gt;2.1.4.RELEASE&lt;/web.starter.version&gt; &lt;eureka.client.version&gt;2.1.1.RELEASE&lt;/eureka.client.version&gt; &lt;actuator.starter.version&gt;2.0.4.RELEASE&lt;/actuator.starter.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;$&#123;web.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;$&#123;eureka.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;$&#123;actuator.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;!-- spring-boot:run 中文乱码解决 --&gt; &lt;jvmArguments&gt;-Dfile.encoding=UTF-8&lt;/jvmArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 3.5.创建EurekaServer3.5.1.创建工程这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry，直接创建maven项目，自然会继承父类的依赖： 选择新建module： ​ 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 3.5.2.添加依赖添加EurekaServer的依赖： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-registry&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.5.3.编写启动类1234567@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123; public static void main(String[] args) &#123; SpringApplication.run(LyRegistry.class, args); &#125;&#125; 3.5.4.配置文件12345678910111213server: port: 10086spring: application: name: ly-registryeureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server: enable-self-preservation: false # 关闭自我保护 3.5.5.项目的结构：目前，整个项目的结构如图： 3.6.创建Zuul网关3.6.1.创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： 3.6.2.添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-api-gateway&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--是springboot提供的微服务检测接口，默认对外提供几个接口：/info--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.6.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123; public static void main(String[] args) &#123; SpringApplication.run(LyApiGateway.class, args); &#125;&#125; 3.6.4.配置文件123456789101112131415161718192021222324252627282930server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;zuul: prefix: /api # 添加路由前缀 retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 10000 # 熔断超时时长：10000ms 3.6.5.项目结构目前，leyou下有两个子模块： ly-registry：服务的注册中心（EurekaServer） ly-api-gateway：服务网关（Zuul） 目前，服务的结构如图所示： 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 3.7.创建商品微服务既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 我们先完成项目的搭建： 3.7.1.微服务的结构因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： ly-item-interface：主要是对外暴露的API接口及相关实体类 ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 3.7.2.创建父工程ly-item依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 3.7.3.创建ly-item-interface在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： 3.7.4.创建ly-item-service与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 3.7.5.整个微服务结构如图所示： 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： 3.7.6.添加依赖接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;groupId&gt;cn.jhmarryme.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.jhmarryme.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt; &lt;dependencies&gt; &lt;!--Eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.jhmarryme.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ly-item-interface中需要什么我们暂时不清楚，所以先不管。 整个结构： 3.7.7.编写启动和配置在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyItemApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemApplication.class, args); &#125;&#125; 然后是全局属性文件： 12345678910111213141516171819server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/heima username: root password: 123eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 3.8.添加商品微服务的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 12345zuul: prefix: /api # 添加路由前缀 retryable: true routes: item-service: /item/** # 将商品微服务映射到/item/** 3.9.启动测试我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： 3.10.测试路由规则为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 3.11.通用工具模块有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 然后把课前资料提供的工具类引入： 然后引入依赖： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"Vue入门","slug":"项目记录/Vue入门","date":"2019-05-13T12:35:12.000Z","updated":"2019-09-15T15:54:44.351Z","comments":true,"path":"2019/05/13/项目记录/Vue入门/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/Vue入门/","excerpt":"","text":"5r学习目标 会创建Vue实例，知道Vue的常见属性 会使用Vue的生命周期的钩子函数 会使用vue常见指令 会使用vue计算属性和watch监控 会编写Vue组件 掌握组件间通信 0.前言前几天我们已经对后端的技术栈有了初步的了解、并且已经搭建了整个后端微服务的平台。接下来要做的事情就是功能开发了。但是没有前端页面，我们肯定无从下手，因此今天我们就要来了解一下前端的一些技术，完成前端页面搭建。 先聊一下前端开发模式的发展。 静态页面 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 异步刷新，操作DOM 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言. 随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如Jquery就是典型代表。 MVVM，关注模型和视图 2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。 2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。 基于时间循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台diamante，前后台统一编程语言 node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。 2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。 随后，在node的基础上，涌现出了一大批的前端框架： MVVM模式 M：即Model，模型，包括数据和一些基本操作 V：即View，视图，页面渲染结果 VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 而我们今天要学习的，就是一款MVVM模式的框架：Vue 1.认识VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 ​ 前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以期轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs 尤雨溪，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。 2.Node和NPM前面说过，NPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJs都有。为了后面学习方便，我们先安装node及NPM工具。 2.1.下载Node.js下载地址：https://nodejs.org/en/download/ 推荐下载LTS版本。 课程中采用的是8.9.0版本。目前最新的是8.11.1。大家自行下载。然后下一步安装即可。 完成以后，在控制台输入： 1node -v 看到版本信息： 2.2.NPM安装完成Node应该自带了NPM了，在控制台输入npm -v查看： npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm 我们首先安装nrm，这里-g代表全局安装 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库： 通过nrm use taobao来指定要使用的镜像源： 然后通过nrm test npm来测试速度： 测试淘宝请输入： 1npm test taobao 注意： 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 3.快速入门接下来，我们快速领略下vue的魅力 3.1.创建工程创建一个新的工程： 选中一个空的： 然后新建一个module： 选中static web，静态web项目： 位置信息： 3.2.安装vue3.2.1.下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件。 3.2.2.使用CDN或者也可以直接使用公共的CDN服务： 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; 或者： 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 3.2.3.推荐npm安装在idea的左下角，有个Terminal按钮，点击打开控制台： 进入hello-vue目录： 先输入：npm init -y 进行初始化 npm init -y 安装Vue，输入命令： 1npm install vue --save 然后就会在hello-vue目录发现一个node_modules目录，并且在下面有一个vue目录。 node_modules是通过npm安装的所有模块的默认位置。 3.3.vue入门案例3.3.1.HTML模板 在hello-vue目录新建一个HTML 在hello.html中，我们编写一段简单的代码： h2中要输出一句话：xx 非常帅。前面的xx是要渲染的数据。 3.3.2.vue渲染然后我们通过Vue进行渲染： 12345678910111213&lt;div id=\"app\"&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125; 非常帅&lt;/h2&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // 生成一个Vue实例 var app = new Vue(&#123; el:\"#app\", // el,即element。要渲染的的页面元素 data:&#123; // 数据 name:\"虎哥\" &#125; &#125;)&lt;/script&gt; 首先通过 new Vue()来创建Vue实例 然后构造函数接收一个对象，对象中有一些属性： el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 name：这里我们指定了一个name属性 页面中的h2元素中，我们通过两个花括号加上name的方式，来渲染刚刚定义的name属性。 打开页面查看效果： 更神奇的在于，当你修改name属性时，页面会跟着变化： 3.3.3.双向绑定我们对刚才的案例进行简单修改： 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"num\"&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125; 非常帅, 有&#123;&#123;num&#125;&#125;位女神为他着迷。 &lt;/h2&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // 生成一个Vue实例 var app = new Vue(&#123; el:\"#app\", // el,即element。要渲染的的页面元素 data:&#123; // 数据 name:\"虎哥\", num:1 &#125; &#125;)&lt;/script&gt; 我们在data添加了新的属性：num 在页面中有一个input元素，通过v-model与num进行绑定。 效果： 我们可以观察到，输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。 input与num绑定，input的value值变化，影响到了data中的num值 页面两个花括号与数据num绑定，因此num值变化，引起了页面效果变化。 没有任何dom操作，这就是双向绑定的魅力。 3.3.4.事件处理我们在页面添加一个按钮： 1&lt;button v-on:click=\"num++\"&gt;点我&lt;/button&gt; 这里用v-on指令绑定点击事件，而不是普通的onclick，然后直接操作num 普通onclick是无法直接操作num的。 效果： 4.Vue实例4.1.创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; // 选项&#125;) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods … 接下来我们一 一介绍。 4.2.模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： 123&lt;div id=\"app\"&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div 123var vm = new Vue(&#123; el:\"#app\"&#125;) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 4.3.数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： 123&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"name\"/&gt;&lt;/div&gt; js: 123456var vm = new Vue(&#123; el:\"#app\", data:&#123; name:\"刘德华\" &#125;&#125;) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 4.4.方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue的作用范围内使用。 html: 1234&lt;div id=\"app\"&gt; &#123;&#123;num&#125;&#125; &lt;button v-on:click=\"add\"&gt;加&lt;/button&gt;&lt;/div&gt; js: 123456789101112var vm = new Vue(&#123; el:\"#app\", data:&#123; num: 0 &#125;, methods:&#123; add:function()&#123; // this代表的当前vue实例 this.num++; &#125; &#125;&#125;) 4.5.生命周期钩子4.5.1.生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 4.5.2.钩子函数例如：created代表在vue实例创建后； 我们可以在Vue中定义一个created函数，代表这个时期的构造函数： html: 123&lt;div id=\"app\"&gt; &#123;&#123;hello&#125;&#125;&lt;/div&gt; js: 123456789var vm = new Vue(&#123; el:\"#app\", data:&#123; hello: '' // hello初始化为空 &#125;, created()&#123; this.hello = \"hello, world！ 我出生了！\"; &#125;&#125;) 结果： 4.5.3.this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this 12345678910var vm = new Vue(&#123; el:\"#app\", data:&#123; hello: '' // hello初始化为空 &#125;, created()&#123; this.hello = \"hello, world！ 我出生了！\"; console.log(this); &#125;&#125;) 控制台的输出： 5.指令什么是指令？ 指令 (Directives) 是带有 v- 前缀的特殊属性。指令属性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 5.1.插值表达式5.1.1.花括号格式： 1&#123;&#123;表达式&#125;&#125; 说明： 该表达式支持JS语法，可以调用js内置函数（必须有返回值） 表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1; 可以直接获取Vue实例中定义的数据或函数 示例： HTML： 1&lt;div id=\"app\"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; JS: 123456var app = new Vue(&#123; el:\"#app\", data:&#123; name:\"Jack\" &#125;&#125;) 5.1.2.插值闪烁使用两个花括号加上方式在网速较慢时会出现问题。在数据未加载完成时，页面会显示出原始的花括号，加载完毕后才显示正确数据，我们称为插值闪烁。 我们将网速调慢一些，然后试试看刚才的案例： 刷新页面： 5.1.3.v-text和v-html使用v-text和v-html指令来替代插值表达式 说明： v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出 v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染 示例： HTML: 1234&lt;div id=\"app\"&gt; v-text:&lt;span v-text=\"hello\"&gt;&lt;/span&gt; &lt;br/&gt; v-html:&lt;span v-html=\"hello\"&gt;&lt;/span&gt;&lt;/div&gt; JS: 123456var vm = new Vue(&#123; el:\"#app\", data:&#123; hello: \"&lt;h1&gt;大家好，我是虎哥&lt;/h1&gt;\" &#125;&#125;) 效果： 并且不会出现插值闪烁，当没有数据时，会显示空白。 5.2.v-model刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 基本上除了最后一项，其它都是表单的输入项。 举例： html： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;input type=\"checkbox\" v-model=\"language\" value=\"Java\" /&gt;Java&lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"language\" value=\"PHP\" /&gt;PHP&lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"language\" value=\"Swift\" /&gt;Swift&lt;br/&gt; &lt;h1&gt; 你选择了：&#123;&#123;language.join(',')&#125;&#125; &lt;/h1&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#app\", data:&#123; language: [] &#125; &#125;)&lt;/script&gt; 多个CheckBox对应一个model时，model的类型是一个数组，单个checkbox值是boolean类型 radio对应的值是input的value值 input 和textarea 默认对应的model是字符串 select单选对应字符串，多选对应也是数组 效果： 5.3.v-on5.3.1.基本用法v-on指令用于给页面元素绑定事件。 语法： 1v-on:事件名=&quot;js片段或函数名&quot; 示例： 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click=\"num++\"&gt;增加&lt;/button&gt;&lt;br/&gt; &lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt; &lt;button v-on:click=\"decrement\"&gt;减少&lt;/button&gt;&lt;br/&gt; &lt;h1&gt;num: &#123;&#123;num&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; num:1 &#125;, methods:&#123; decrement()&#123; this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果： 另外，事件绑定可以简写，例如v-on:click=&#39;add&#39;可以简写为@click=&#39;add&#39; 5.3.2.事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡 .prevent：阻止默认事件发生 .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once：只执行一次 5.3.3.按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input @keyup.13=\"submit\"&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 5.3.4.组合按钮可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 5.4.v-for遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 5.4.1.遍历数组 语法： 1v-for=&quot;item in items&quot; items：要遍历的数组，需要在vue的data中定义好。 item：迭代得到的数组元素的别名 示例 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"user in users\"&gt; &#123;&#123;user.name&#125;&#125; : &#123;&#123;user.gender&#125;&#125; : &#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#app\", data:&#123; users:[ &#123;name:'柳岩', gender:'女', age: 21&#125;, &#123;name:'虎哥', gender:'男', age: 30&#125;, &#123;name:'范冰冰', gender:'女', age: 24&#125;, &#123;name:'刘亦菲', gender:'女', age: 18&#125;, &#123;name:'古力娜扎', gender:'女', age: 25&#125; ] &#125; &#125;)&lt;/script&gt; 效果： 5.4.2.数组角标在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数： 语法 1v-for=&quot;(item,index) in items&quot; items：要迭代的数组 item：迭代得到的数组元素别名 index：迭代到的当前元素索引，从0开始。 示例 1234567&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(user,index) in users\"&gt; &#123;&#123;index&#125;&#125; - &#123;&#123;user.name&#125;&#125; : &#123;&#123;user.gender&#125;&#125; : &#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 效果： 5.4.3.遍历对象v-for除了可以迭代数组，也可以迭代对象。语法基本类似 语法： 123v-for=&quot;value in object&quot;v-for=&quot;(value,key) in object&quot;v-for=&quot;(value,key,index) in object&quot; 1个参数时，得到的是对象的值 2个参数时，第一个是值，第二个是键 3个参数时，第三个是索引，从0开始 示例： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(value,key,index) in user\"&gt; &#123;&#123;index&#125;&#125; - &#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#app\", data:&#123; user:&#123;name:'柳岩', gender:'女', age: 21&#125; &#125; &#125;)&lt;/script&gt; 效果： 5.4.4.key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这个功能可以有效的提高渲染的效率。 但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 示例： 123&lt;ul&gt; &lt;li v-for=\"(item,index) in items\" :key=\"index\"&gt;&lt;/li&gt;&lt;/ul&gt; 这里使用了一个特殊语法：:key=&quot;&quot; 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性 这里我们绑定的key是数组的索引，应该是唯一的 5.5.v-if和v-show5.5.1.基本使用v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 语法： 1v-if=&quot;布尔表达式&quot; 示例： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click=\"show = !show\"&gt;点击切换&lt;/button&gt;&lt;br/&gt; &lt;h1 v-if=\"show\"&gt; 你好 &lt;/h1&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 效果： 5.5.2.与v-for结合当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 示例： 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li v-for=\"(user,index) in users\" v-if=\"user.gender === '女'\"&gt; &#123;&#123;index&#125;&#125; - &#123;&#123;user.name&#125;&#125; : &#123;&#123;user.gender&#125;&#125; : &#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#app\", data:&#123; users:[ &#123;name:'柳岩', gender:'女', age: 21&#125;, &#123;name:'虎哥', gender:'男', age: 30&#125;, &#123;name:'范冰冰', gender:'女', age: 24&#125;, &#123;name:'刘亦菲', gender:'女', age: 18&#125;, &#123;name:'古力娜扎', gender:'女', age: 25&#125; ] &#125; &#125;)&lt;/script&gt; 效果： 5.5.3.v-else你可以使用 v-else 指令来表示 v-if 的“else 块”： 123456&lt;div v-if=\"Math.random() &gt; 0.5\"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt; A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt; B&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;C&apos;&quot;&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 5.5.4.v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 示例： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click=\"show = !show\"&gt;点击切换&lt;/button&gt;&lt;br/&gt; &lt;h1 v-if=\"show\"&gt; 你好 &lt;/h1&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; el:\"#app\", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码： 5.6.v-bind5.6.1.绑定class样式假如我们想动态的修改页面元素的属性，比如class属性，这样写是错误的： 1&lt;div class=\"&#123;&#123;isAcctive&#125;&#125;\"&gt;&lt;/div&gt; 因为插值表达式不能用在属性的值中。 Vue对class属性进行了特殊处理，可以接收数组或对象格式： 数组语法 我们可以借助于v-bind指令来实现： HTML： 1&lt;div v-bind:class=\"isActive\"&gt;&lt;/div&gt; 你的data属性： 123data:&#123; isActive:['active','hasError']&#125; 渲染后的效果： 1&lt;div class=&quot;active hasError&quot;&gt;&lt;/div&gt; 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的 truthiness。 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。当有如下模板: 123&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;&lt;/div&gt; 和如下 data： 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 1&lt;div class=\"static active\"&gt;&lt;/div&gt; 当 isActive 或者 hasError 变化时，class 列表将相应地更新。例如，如果 hasError的值为 true，class 列表将变为 &quot;static active text-danger&quot;。 5.6.2.简写v-bind:class可以简写为:class 5.7.计算属性在插值表达式中使用js表达式是非常方便的，而且也经常被用到。 但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值： 123data:&#123; birthday:1529032123201 // 毫秒值&#125; 我们在页面渲染，希望得到yyyy-MM-dd的样式： 1234&lt;h1&gt;您的生日是：&#123;&#123; new Date(birthday).getFullYear() + '-'+ new Date(birthday).getMonth()+ '-' + new Date(birthday).getDay() &#125;&#125;&lt;/h1&gt; 虽然能得到结果，但是非常麻烦。 Vue中提供了计算属性，来替代复杂的表达式： 123456789101112var vm = new Vue(&#123; el:\"#app\", data:&#123; birthday:1429032123201 // 毫秒值 &#125;, computed:&#123; birth()&#123;// 计算属性本质是一个方法，但是必须返回结果 const d = new Date(this.birthday); return d.getFullYear() + \"-\" + d.getMonth() + \"-\" + d.getDay(); &#125; &#125;&#125;) 计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。 页面使用： 123&lt;div id=\"app\"&gt; &lt;h1&gt;您的生日是：&#123;&#123;birth&#125;&#125; &lt;/h1&gt;&lt;/div&gt; 效果： 5.8.watchwatch可以让我们监控一个值的变化。从而做出相应的反应。 示例： 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"message\"&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#app\", data:&#123; message:\"\" &#125;, watch:&#123; message(newVal, oldVal)&#123; console.log(newVal, oldVal); &#125; &#125; &#125;)&lt;/script&gt; 效果： 6.组件化在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。 6.1.定义全局组件我们通过Vue的component方法来定义一个全局组件。 12345678910111213141516171819&lt;div id=\"app\"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; // 定义全局组件，两个参数：1，组件名称。2，组件参数 Vue.component(\"counter\",&#123; template:'&lt;button v-on:click=\"count++\"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125; &#125;) var app = new Vue(&#123; el:\"#app\" &#125;)&lt;/script&gt; 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data的定义方式比较特殊，必须是一个函数。 效果： 6.2.组件的复用定义好的组件，可以任意复用多次： 123456&lt;div id=\"app\"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 效果： 你会发现每个组件互不干扰，都有自己的count值。怎么实现的？ 组件的data属性必须是函数！ 当我们定义这个 &lt;counter&gt; 组件时，它的data 并不是像这样直接提供一个对象： 123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！ 6.2.局部注册一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，我们会采用局部注册。 我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致： 12345678const counter = &#123; template:'&lt;button v-on:click=\"count++\"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125;&#125;; 然后在Vue中使用它： 123456var app = new Vue(&#123; el:\"#app\", components:&#123; counter:counter // 将定义的对象注册为组件 &#125;&#125;) components就是当前vue对象子组件集合。 其key就是子组件名称 其值就是组件对象的属性 效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用 6.3.组件通信通常一个单页应用会以一棵嵌套的组件树的形式来组织： 页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 左侧内容区又分为上下两个组件 右侧边栏中又包含了3个子组件 各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 6.3.1.父向子传递props比如我们有一个子组件： 12345Vue.component(\"introduce\",&#123; // 直接使用props接收到的属性来渲染页面 template:'&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;', props:[title] // 通过props来接收一个父组件传递的属性&#125;) 这个子组件中要使用title属性渲染页面，但是自己并没有title属性 通过props来接收父组件属性，名为title 父组件使用子组件，同时传递title属性： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;h1&gt;打个招呼：&lt;/h1&gt; &lt;!--使用子组件，同时传递title属性--&gt; &lt;introduce title=\"大家好，我是虎哥\"/&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; Vue.component(\"introduce\",&#123; // 直接使用props接收到的属性来渲染页面 template:'&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;', props:['title'] // 通过props来接收一个父组件传递的属性 &#125;) var app = new Vue(&#123; el:\"#app\" &#125;)&lt;/script&gt; 效果： 6.3.2.传递复杂数据我们定义一个子组件： 12345678910111213const myList = &#123; template:'\\ &lt;ul&gt;\\ &lt;li v-for=\"item in items\" :key=\"item.id\"&gt;&#123;&#123;item.id&#125;&#125; : &#123;&#123;item.name&#125;&#125;&lt;/li&gt;\\ &lt;/ul&gt;\\ ', props:&#123; // 通过props来接收父组件传递来的属性 items:&#123;// 这里定义items属性 type:Array,// 要求必须是Array类型 default:[] // 如果父组件没有传，那么给定默认值是[] &#125; &#125;&#125; 这个子组件可以对 items 进行迭代，并输出到页面。 但是组件中并未定义items属性。 通过props来定义需要从父组件中接收的属性 items：是要接收的属性名称 type：限定父组件传递来的必须是数组，否则报错 default：默认值 我们在父组件中使用它： 12345&lt;div id=\"app\"&gt; &lt;h2&gt;传智播客已开设如下课程：&lt;/h2&gt; &lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt; &lt;my-list :items=\"lessons\"/&gt;&lt;/div&gt; 12345678910111213var app = new Vue(&#123; el:\"#app\", components:&#123; myList // 当key和value一样时，可以只写一个 &#125;, data:&#123; lessons:[ &#123;id:1, name: 'java'&#125;, &#123;id:2, name: 'php'&#125;, &#123;id:3, name: 'ios'&#125;, ] &#125;&#125;) 效果： 6.3.3.子向父的通信来看这样的一个案例： 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;!--使用子组件的时候，传递num到子组件中--&gt; &lt;counter :num=\"num\"&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src=\"./node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; Vue.component(\"counter\", &#123;// 子组件，定义了两个按钮，点击数字num会加或减 template:'\\ &lt;div&gt;\\ &lt;button @click=\"num++\"&gt;加&lt;/button&gt; \\ &lt;button @click=\"num--\"&gt;减&lt;/button&gt; \\ &lt;/div&gt;', props:['num']// count是从父组件获取的。 &#125;) var app = new Vue(&#123; el:\"#app\", data:&#123; num:0 &#125; &#125;)&lt;/script&gt; 子组件接收父组件的num属性 子组件定义点击按钮，点击后对num进行加或减操作 我们尝试运行： 好像没问题，点击按钮试试： 子组件接收到父组件属性后，默认是不允许修改的。怎么办？ 既然只有父组件能修改，那么加和减的操作一定是放在父组件： 1234567891011121314var app = new Vue(&#123; el:\"#app\", data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125;&#125;) 但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？ 我们可以通过v-on指令将父组件的函数绑定到子组件上： 1234&lt;div id=\"app\"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;counter :count=\"num\" @inc=\"increment\" @dec=\"decrement\"&gt;&lt;/counter&gt;&lt;/div&gt; 然后，当子组件中按钮被点击时，调用绑定的函数： 12345678910111213141516Vue.component(\"counter\", &#123; template:'\\ &lt;div&gt;\\ &lt;button @click=\"plus\"&gt;加&lt;/button&gt; \\ &lt;button @click=\"reduce\"&gt;减&lt;/button&gt; \\ &lt;/div&gt;', props:['count'], methods:&#123; plus()&#123; this.$emit(\"inc\"); &#125;, reduce()&#123; this.$emit(\"dec\"); &#125; &#125;&#125;) vue提供了一个内置的this.$emit函数，用来调用父组件绑定的函数 效果：","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://wangdaye7.github.io/categories/前端框架/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"Thymeleaf基本使用","slug":"项目记录/Thymeleaf基本使用","date":"2019-05-13T12:35:12.000Z","updated":"2019-05-21T03:09:58.226Z","comments":true,"path":"2019/05/13/项目记录/Thymeleaf基本使用/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/Thymeleaf基本使用/","excerpt":"","text":"6.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 6.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 6.2.编写接口编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染 123456789@GetMapping(\"/all\")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute(\"users\", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return \"users\";&#125; 6.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 6.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type=\"text/css\"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\"text-align: center\"&gt; &lt;span style=\"color: darkslategray; font-size: 30px\"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class=\"list\"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=\"user : $&#123;users&#125;\"&gt; &lt;td th:text=\"$&#123;user.id&#125;\"&gt;1&lt;/td&gt; &lt;td th:text=\"$&#123;user.name&#125;\"&gt;张三&lt;/td&gt; &lt;td th:text=\"$&#123;user.userName&#125;\"&gt;zhangsan&lt;/td&gt; &lt;td th:text=\"$&#123;user.age&#125;\"&gt;20&lt;/td&gt; &lt;td th:text=\"$&#123;user.sex&#125; == 1 ? '男': '女'\"&gt;男&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;\"&gt;1980-02-30&lt;/td&gt; &lt;td th:text=\"$&#123;user.note&#125;\"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 6.5.测试接下来，我们打开页面测试一下： 6.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： ​ 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 ​ eclipse中没有测试过。 我们可以修改页面，测试一下。","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"springboot微服务坑","slug":"allTemp/springboot微服务坑","date":"2019-05-13T10:11:49.000Z","updated":"2019-09-15T15:49:47.671Z","comments":true,"path":"2019/05/13/allTemp/springboot微服务坑/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/allTemp/springboot微服务坑/","excerpt":"","text":"yml文件spring boot项目启动报错:Failed to load property source from location ‘classpath:/application.yml’ yml的语法格式有误 application.yml文件格式问题File–&gt;Settings–&gt;File Encodings全部修改为UTF-8 如未解决删除中文注释 springcloud与springboot版本冲突SpringBoot2.1.4与springcloud Finchley.SR1冲突, 需要降级sb到2.0.4 父工程版本控制dependencyManagement与dependenciesdependencyManagement只做控制版本用, 不引用,而dependencies会在子工程默认引用","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[]},{"title":"springcloud配置积累","slug":"allTemp/springcloud配置积累","date":"2019-05-13T09:24:32.000Z","updated":"2019-09-15T15:49:42.020Z","comments":true,"path":"2019/05/13/allTemp/springcloud配置积累/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/allTemp/springcloud配置积累/","excerpt":"","text":"# 常用sever12server: port: 10086 # 端口 spring123spring: application: name: eureka-server # 应用名称，会在Eureka中显示 日志级别123logging: level: com.leyou: debug #设置com.leyou包下的日志级别都为debug hystrix1234567hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms ribbon123456ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 feign123feign: hystrix: enabled: true # 开启Feign的熔断功能 请求压缩123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 eureka12345678910eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka instance: instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125; #实例信息，显示IP和端口 prefer-ip-address: true ip-address: 127.0.0.1 zuul通过eureka的方式1234567891011zuul: retryable: true ##重试 routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称 #简化版zuul: routes: user-service: /user-service/** # 这里是映射路径 手动IP的方式12345678910111213zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8081 # 映射路径对应的实际url地址``` ## mybatis``` yamlmybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[]},{"title":"品牌新增vue界面搭建","slug":"项目记录/品牌新增vue界面搭建","date":"2019-05-12T16:09:29.000Z","updated":"2019-07-18T10:54:07.028Z","comments":true,"path":"2019/05/13/项目记录/品牌新增vue界面搭建/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/品牌新增vue界面搭建/","excerpt":"","text":"title: 品牌新增vue界面搭建date: 2019-05-12 16:09:29categories: 微服务项目存档tags: javaWeb 1.品牌的新增昨天我们完成了品牌的查询，接下来就是新增功能。 1.1.页面实现1.1.1.初步编写弹窗当我们点击新增按钮，应该出现一个弹窗，然后在弹窗中出现一个表格，我们就可以填写品牌信息了。 我们查看Vuetify官网，弹窗是如何实现： 另外，我们可以通过文档看到对话框的一些属性： value：控制窗口的可见性，true可见，false，不可见 max-width：控制对话框最大宽度 scrollable ：是否可滚动，要配合v-card来使用，默认是false persistent ：点击弹窗以外的地方不会关闭弹窗，默认是false 现在，我们来使用一下。 首先，我们在data中定义一个show属性，来控制对话框的显示状态： 然后，在页面添加一个v-dialog 12345678910111213&lt;!--弹出的对话框--&gt;&lt;v-dialog max-width=\"500\" v-model=\"show\" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color=\"primary\"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class=\"px-5\"&gt; 我是表单 &lt;/v-card-text&gt; &lt;/v-card&gt;&lt;/v-dialog&gt; 说明： 我们给dialog指定了3个属性，分别是 max-width：限制宽度 v-model：value值双向绑定到show变量，用来控制窗口显示 persisitent：控制窗口不会被意外关闭 因为可滚动需要配合v-card使用，因此我们在对话框中加入了一个v-card 在v-card的头部添加了一个 v-toolbar，作为窗口的头部，并且写了标题为：新增品牌 dense：紧凑显示 dark：黑暗主题 color：颜色，primary就是整个网站的主色调，蓝色 在v-card的内容部分，暂时空置，等会写表单 class=“px-5&quot;：vuetify的内置样式，含义是padding的x轴设置为5，这样表单内容会缩进一些，而不是顶着边框 基本语法：{property}{direction}-{size} property：属性，有两种padding和margin p：对应padding m：对应margin direction：只padding和margin的作用方向， t - 对应margin-top或者padding-top属性 b - 对应margin-bottom or padding-bottom l - 对应margin-left or padding-left r - 对应margin-right or padding-right x - 同时对应*-left和*-right属性 y - 同时对应*-top和*-bottom属性 size：控制空间大小，基于$spacer进行倍增，$spacer默认是16px 0：将margin或padding的大小设置为0 1 - 将margin或者padding属性设置为$spacer * .25 2 - 将margin或者padding属性设置为$spacer * .5 3 - 将margin或者padding属性设置为$spacer 4 - 将margin或者padding属性设置为$spacer * 1.5 5 - 将margin或者padding属性设置为$spacer * 3 1.1.2.实现弹窗的可见和关闭 窗口可见 接下来，我们要在点击新增品牌按钮时，将窗口显示，因此要给新增按钮绑定事件。 1&lt;v-btn color=\"primary\" @click=\"addBrand\"&gt;新增品牌&lt;/v-btn&gt; 然后定义一个addBrand方法： 1234addBrand()&#123; // 控制弹窗可见： this.show = true;&#125; 效果： 窗口关闭 现在，悲剧发生了，因为我们设置了persistent属性，窗口无法被关闭了。除非把show属性设置为false 因此我们需要给窗口添加一个关闭按钮： 1234567&lt;!--对话框的标题--&gt;&lt;v-toolbar dense dark color=\"primary\"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click=\"closeWindow\"&gt;&lt;v-icon&gt;close&lt;/v-icon&gt;&lt;/v-btn&gt;&lt;/v-toolbar&gt; 并且，我们还给按钮绑定了点击事件，回调函数为closeWindow。 接下来，编写closeWindow函数： 1234closeWindow()&#123; // 关闭窗口 this.show = false;&#125; 效果： 1.1.3.新增品牌的表单页接下来就是写表单了。我们有两种选择： 直接在dialog对话框中编写表单代码 另外编写一个组件，组件内写表单代码。然后在对话框引用组件 选第几种？ 我们选第二种方案，优点： 表单代码独立组件，可拔插，方便后期的维护。 代码分离，可读性更好。 我们新建一个MyBrandForm.vue组件： 将MyBrandForm引入到MyBrand中，这里使用局部组件的语法： 先导入自定义组件： 12// 导入自定义的表单组件import MyBrandForm from './MyBrandForm' 然后通过components属性来指定局部组件： 123components:&#123; MyBrandForm&#125; 然后在页面中引用： 页面效果： 1.1.4.编写表单1.1.4.1.表单查看文档，找到关于表单的部分： v-form，表单组件，内部可以有许多输入项。v-form有下面的属性： value：true，代表表单验证通过；false，代表表单验证失败 v-form提供了两个方法： reset：重置表单数据 validate：校验整个表单数据，前提是你写好了校验规则。返回Boolean表示校验成功或失败 我们在data中定义一个valid属性，跟表单的value进行双向绑定，观察表单是否通过校验，同时把等会要跟表单关联的品牌brand对象声明出来： 1234567891011121314export default &#123; name: \"my-brand-form\", data() &#123; return &#123; valid:false, // 表单校验结果标记 brand:&#123; name:'', // 品牌名称 letter:'', // 品牌首字母 image:'',// 品牌logo categories:[], // 品牌所属的商品分类数组 &#125; &#125; &#125;&#125; 然后，在页面先写一个表单： 123&lt;v-form v-model=\"valid\"&gt;&lt;/v-form&gt; 1.1.4.2.文本框我们的品牌总共需要这些字段： 名称 首字母 商品分类，有很多个 LOGO 表单项主要包括文本框、密码框、多选框、单选框、文本域、下拉选框、文件上传等。思考下我们的品牌需要哪些？ 文本框：品牌名称、品牌首字母都属于文本框 文件上传：品牌需要图片，这个是文件上传框 下拉选框：商品分类提前已经定义好，这里需要通过下拉选框展示，提供给用户选择。 先看文本框，昨天已经用过的，叫做v-text-field： 查看文档，v-text-field有以下关键属性： append-icon：文本框后追加图标，需要填写图标名称。无默认值 clearable：是否添加一个清空图标，点击会清空文本框。默认是false color：颜色 counter：是否添加一个文本计数器，在角落显示文本长度，指定true或允许的组大长度。无默认值 dark：是否应用黑暗色调，默认是false disable：是否禁用，默认是false flat：是否移除默认的动画效果，默认是false full-width：指定宽度为全屏，默认是false hide-details：是否因此错误提示，默认是false hint：输入框的提示文本 label：输入框的标签 multi-line：是否转为文本域，默认是false。文本框和文本域可以自由切换 placeholder：输入框占位符文本，focus后消失 required：是否为必填项，如果是，会在label后加*，不具备校验功能。默认是false rows：文本域的行数，multi-line为true时才有效 rules：指定校验规则及错误提示信息，数组结构。默认[] single-line：是否单行文本显示，默认是false suffix：显示后缀 接下来，我们先添加两个字段：品牌名称、品牌的首字母，校验规则暂时不写： 1234&lt;v-form v-model=\"valid\"&gt; &lt;v-text-field v-model=\"brand.name\" label=\"请输入品牌名称\" required /&gt; &lt;v-text-field v-model=\"brand.letter\" label=\"请输入品牌首字母\" required /&gt;&lt;/v-form&gt; 千万不要忘了通过v-model把表单项与brand的属性关联起来。 效果： 1.1.4.3.级联下拉选框接下来就是商品分类了，按照刚才的分析，商品分类应该是下拉选框。 但是大家仔细思考，商品分类包含三级。在展示的时候，应该是先由用户选中1级，才显示2级；选择了2级，才显示3级。形成一个多级分类的三级联动效果。 这个时候，就不是普通的下拉选框，而是三级联动的下拉选框！ 这样的选框，在Vuetify中并没有提供（它提供的是基本的下拉框）。因此我已经给大家编写了一个无限级联动的下拉选框，能够满足我们的需求。 具体请参考课前资料的《自定义组件用法指南.md》 我们在代码中使用： 123456&lt;v-cascader url=\"/item/category/list\" multiple required v-model=\"brand.categories\" label=\"请选择商品分类\"/&gt; url：加载商品分类选项的接口路径 multiple：是否多选，这里设置为true，因为一个品牌可能有多个分类 requried：是否是必须的，这里为true，会在提示上加*，提醒用户 v-model：关联我们brand对象的categories属性 label：文字说明 效果： data中获取的结果： 1.1.4.4.文件上传项在Vuetify中，也没有文件上传的组件。 还好，我已经给大家写好了一个文件上传的组件： 详细用法，参考《自定义组件使用指南.md》 我们添加上传的组件： 1234567891011121314&lt;v-layout row&gt; &lt;v-flex xs3&gt; &lt;span style=\"font-size: 16px; color: #444\"&gt;品牌LOGO：&lt;/span&gt; &lt;/v-flex&gt; &lt;v-flex&gt; &lt;v-upload v-model=\"brand.image\" url=\"/upload\" :multiple=\"false\" :pic-width=\"250\" :pic-height=\"90\" /&gt; &lt;/v-flex&gt;&lt;/v-layout&gt; 注意： 文件上传组件本身没有提供文字提示。因此我们需要自己添加一段文字说明 我们要实现文字和图片组件左右放置，因此这里使用了v-layout布局组件： layout添加了row属性，代表这是一行，如果是column，代表是多行 layout下面有v-flex组件，是这一行的单元，我们有2个单元 &lt;v-flex xs3&gt; ：显示文字说明，xs3是响应式布局，代表占12格中的3格 剩下的部分就是图片上传组件了 v-upload：图片上传组件，包含以下属性： v-model：将上传的结果绑定到brand的image属性 url：上传的路径，我们先随便写一个。 multiple：是否运行多图片上传，这里是false。因为品牌LOGO只有一个 pic-width和pic-height：可以控制l图片上传后展示的宽高 最终结果： 1.1.4.5.按钮上面已经把所有的表单项写完。最后就差提交和清空的按钮了。 在表单的最下面添加两个按钮： 12345&lt;v-layout class=\"my-4\" row&gt; &lt;v-spacer/&gt; &lt;v-btn @click=\"submit\" color=\"primary\"&gt;提交&lt;/v-btn&gt; &lt;v-btn @click=\"clear\" &gt;重置&lt;/v-btn&gt;&lt;/v-layout&gt; 通过layout来进行布局，my-4增大上下边距 v-spacer占用一定空间，将按钮都排挤到页面右侧 两个按钮分别绑定了submit和clear事件 我们先将方法定义出来： 12345678methods:&#123; submit()&#123; // 提交表单 &#125;, clear()&#123; // 重置表单 &#125;&#125; 重置表单相对简单，因为v-form组件已经提供了reset方法，用来清空表单数据。只要我们拿到表单组件对象，就可以调用方法了。 我们可以通过$refs内置对象来获取表单组件。 首先，在表单上定义ref属性： 然后，在页面查看this.$refs属性： 看到this.$refs中只有一个属性，就是myBrandForm 我们在clear中来获取表单对象并调用reset方法： 123456789101112methods:&#123; submit()&#123; // 提交表单 console.log(this); &#125;, clear()&#123; // 重置表单 this.$refs.myBrandForm.reset(); // 需要手动清空商品分类 this.categories = []; &#125;&#125; 要注意的是，这里我们还手动把this.categories清空了，因为我写的级联选择组件并没有跟表单结合起来。需要手动清空。 1.1.5.表单校验1.1.5.1.校验规则Vuetify的表单校验，是通过rules属性来指定的： 校验规则的写法： 说明： 规则是一个数组 数组中的元素是一个函数，该函数接收表单项的值作为参数，函数返回值两种情况： 返回true，代表成功， 返回错误提示信息，代表失败 1.1.5.2.项目中代码我们有四个字段： name：做非空校验和长度校验，长度必须大于1 letter：首字母，校验长度为1，非空。 image：图片，不做校验，图片可以为空 categories：非空校验，自定义组件已经帮我们完成，不用写了 首先，我们定义规则： 12345678nameRules:[ v =&gt; !!v || \"品牌名称不能为空\", v =&gt; v.length &gt; 1 || \"品牌名称至少2位\"],letterRules:[ v =&gt; !!v || \"首字母不能为空\", v =&gt; /^[A-Z]&#123;1&#125;$/.test(v) || \"品牌字母只能是A~Z的大写字母\"] 然后，在页面标签中指定： 12&lt;v-text-field v-model=\"brand.name\" label=\"请输入品牌名称\" required :rules=\"nameRules\" /&gt;&lt;v-text-field v-model=\"brand.letter\" label=\"请输入品牌首字母\" required :rules=\"letterRules\" /&gt; 效果： 1.1.6.表单提交在submit方法中添加表单提交的逻辑： 1234567891011121314151617181920submit() &#123; // 1、表单校验 if (this.$refs.myBrandForm.validate()) &#123; // 2、定义一个请求参数对象，通过解构表达式来获取brand中的属性 const &#123;categories ,letter ,...params&#125; = this.brand; // 3、数据库中只要保存分类的id即可，因此我们对categories的值进行处理,只保留id，并转为字符串 params.cids = categories.map(c =&gt; c.id).join(\",\"); // 4、将字母都处理为大写 params.letter = letter.toUpperCase(); // 5、将数据提交到后台 this.$http.post('/item/brand', params) .then(() =&gt; &#123; // 6、弹出提示 this.$message.success(\"保存成功！\"); &#125;) .catch(() =&gt; &#123; this.$message.error(\"保存失败！\"); &#125;); &#125;&#125; 1、通过this.$refs.myBrandForm选中表单，然后调用表单的validate方法，进行表单校验。返回boolean值，true代表校验通过 2、通过解构表达式来获取brand中的值，categories和letter需要处理，单独获取。其它的存入params对象中 3、品牌和商品分类的中间表只保存两者的id，而brand.categories中保存的数对象数组，里面有id和name属性，因此这里通过数组的map功能转为id数组，然后通过join方法拼接为字符串 4、首字母都处理为大写保存 5、发起请求 6、弹窗提示成功还是失败，这里用到的是我们的自定义组件功能message组件： 这个插件把$message对象绑定到了Vue的原型上，因此我们可以通过this.$message来直接调用。 包含以下常用方法： info、error、success、warning等，弹出一个带有提示信息的窗口，色调与为普通（灰）、错误（红色）、成功（绿色）和警告（黄色）。使用方法：this.$message.info(“msg”) confirm：确认框。用法：this.$message.confirm(&quot;确认框的提示信息&quot;)，返回一个Promise","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"实现图片上传","slug":"项目记录/图片上传实现","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:05:38.012Z","comments":true,"path":"2019/05/13/项目记录/图片上传实现/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/图片上传实现/","excerpt":"","text":"2.实现图片上传刚才的新增实现中，我们并没有上传图片，接下来我们一起完成图片上传逻辑。 文件的上传并不只是在品牌管理中有需求，以后的其它服务也可能需要，因此我们创建一个独立的微服务，专门处理各种上传。 2.1.搭建项目2.1.1.创建module 2.1.2.依赖我们需要EurekaClient和web依赖： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-upload&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.1.3.编写配置12345678910111213141516171819server: port: 8082spring: application: name: upload-service servlet: multipart: max-file-size: 5MB # 限制文件上传的大小# Eurekaeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 需要注意的是，我们应该添加了限制文件大小的配置 2.1.4.启动类1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyUploadService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyUploadService.class, args); &#125;&#125; 结构： 2.2.编写上传功能2.2.1.controller编写controller需要知道4个内容： 请求方式：上传肯定是POST 请求路径：/upload/image 请求参数：文件，参数名是file，SpringMVC会封装为一个接口：MultipleFile 返回结果：上传成功后得到的文件的url路径 代码如下： 1234567891011121314151617181920212223@RestController@RequestMapping(\"upload\")public class UploadController &#123; @Autowired private UploadService uploadService; /** * 上传图片功能 * @param file * @return */ @PostMapping(\"image\") public ResponseEntity&lt;String&gt; uploadImage(@RequestParam(\"file\") MultipartFile file) &#123; String url = this.uploadService.upload(file); if (StringUtils.isBlank(url)) &#123; // url为空，证明上传失败 return new ResponseEntity&lt;&gt;(HttpStatus.BAD_REQUEST); &#125; // 返回200，并且携带url路径 return ResponseEntity.ok(url); &#125;&#125; 2.2.2.service在上传文件过程中，我们需要对上传的内容进行校验： 校验文件大小 校验文件的媒体类型 校验文件的内容 文件大小在Spring的配置文件中设置，因此已经会被校验，我们不用管。 具体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class UploadService &#123; private static final Logger logger = LoggerFactory.getLogger(UploadController.class); // 支持的文件类型 private static final List&lt;String&gt; suffixes = Arrays.asList(\"image/png\", \"image/jpeg\"); public String upload(MultipartFile file) &#123; try &#123; // 1、图片信息校验 // 1)校验文件类型 String type = file.getContentType(); if (!suffixes.contains(type)) &#123; logger.info(\"上传失败，文件类型不匹配：&#123;&#125;\", type); return null; &#125; // 2)校验图片内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) &#123; logger.info(\"上传失败，文件内容不符合要求\"); return null; &#125; // 2、保存图片 // 2.1、生成保存目录 File dir = new File(\"D:\\\\heima\\\\upload\"); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 2.2、保存图片 file.transferTo(new File(dir, file.getOriginalFilename())); // 2.3、拼接图片地址 String url = \"http://image.leyou.com/upload/\" + file.getOriginalFilename(); return url; &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 新:123456789101112131415161718192021222324252627282930@Service@Slf4jpublic class UploadService &#123; public final List&lt;String&gt; allowTypes = Arrays.asList(\"image/jpeg\", \"image/png\", \"image/bmp\"); public String upload(MultipartFile file)&#123; try &#123; //校验文件类型 String contentType = file.getContentType(); if (!allowTypes.contains(contentType)) &#123; throw new LyException(ExceptionEnum.FILE_TYPE_ERROR); &#125; //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) &#123; throw new LyException(ExceptionEnum.FILE_TYPE_ERROR); &#125; //准备目标路径 File dest = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\初识项目\\\\leyou_upload\", file.getOriginalFilename()); //保存文件到本地 file.transferTo(dest); //返回文件地址 return \"http://image/leyou.com/\" + file.getOriginalFilename(); &#125; catch (IOException e) &#123; log.error(\"上传文件失败\", e); throw new LyException(ExceptionEnum.UPLOAD_FILE_ERROR); &#125; &#125;&#125; 这里有一个问题：为什么图片地址需要使用另外的url？ 图片不能保存在服务器内部，这样会对服务器产生额外的加载负担 一般静态资源都应该使用独立域名，这样访问静态资源时不会携带一些不必要的cookie，减小请求的数据量 2.2.3.测试上传我们通过RestClient工具来测试： 结果： 去目录下查看： 上传成功！ 2.2.4.绕过网关图片上传是文件的传输，如果也经过Zuul网关的代理，文件就会经过多次网路传输，造成不必要的网络负担。在高并发时，可能导致网络阻塞，Zuul网关不可用。这样我们的整个系统就瘫痪了。 所以，我们上传文件的请求就不经过网关来处理了。 2.2.4.1.Zuul的路由过滤Zuul中提供了一个ignored-patterns属性，用来忽略不希望路由的URL路径，示例： 1zuul.ignored-patterns: /upload/** 路径过滤会对一切微服务进行判定。 Zuul还提供了ignored-services属性，进行服务过滤： 1zuul.ignored-services: upload-servie 我们这里采用忽略服务： 123zuul: ignored-services: - upload-service # 忽略upload-service服务 上面的配置采用了集合语法，代表可以配置多个 2.2.4.2.Nginx的rewrite指令现在，我们修改页面的访问路径： 123456&lt;v-upload v-model=\"brand.image\" url=\"/upload/image\" :multiple=\"false\" :pic-width=\"250\" :pic-height=\"90\" /&gt; 查看页面的请求路径： 可以看到这个地址不对，依然是去找Zuul网关，因为我们的系统全局配置了URL地址。怎么办？ 有同学会想：修改页面请求地址不就好了。 注意：原则上，我们是不能把除了网关以外的服务对外暴露的，不安全。 既然不能修改页面请求，那么就只能在Nginx反向代理上做文章了。 我们修改nginx配置，将以/api/upload开头的请求拦截下来，转交到真实的服务地址: 12345location /api/upload &#123; proxy_pass http://127.0.0.1:8082; proxy_connect_timeout 600; proxy_read_timeout 600;&#125; 这样写大家觉得对不对呢？ 显然是不对的，因为ip和端口虽然对了，但是路径没变，依然是：http://127.0.0.1:8002/api/upload/image 前面多了一个/api Nginx提供了rewrite指令，用于对地址进行重写，语法规则： 1rewrite &quot;用来匹配路径的正则&quot; 重写后的路径 [指令]; 我们的案例： 1234567891011121314151617181920212223server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 上传路径的映射 location /api/upload &#123; proxy_pass http://127.0.0.1:8082; proxy_connect_timeout 600; proxy_read_timeout 600; rewrite \"^/api/(.*)$\" /$1 break; &#125; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; 新:1234567891011121314151617server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location /api/upload &#123; rewrite \"^/(.*)$\" /zuul/$1; &#125; location / &#123; proxy_pass http://127.0.0.1:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; 首先，我们映射路径是/api/upload，而下面一个映射路径是 / ，根据最长路径匹配原则，/api/upload优先级更高。也就是说，凡是以/api/upload开头的路径，都会被第一个配置处理 proxy_pass：反向代理，这次我们代理到8082端口，也就是upload-service服务 rewrite &quot;^/api/(.*)$&quot; /$1 break，路径重写： &quot;^/api/(.*)$&quot;：匹配路径的正则表达式，用了分组语法，把/api/以后的所有部分当做1组 /$1：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始），即/api/后面的所有。这样新的路径就是除去/api/以外的所有，就达到了去除/api前缀的目的 break：指令，常用的有2个，分别是：last、break last：重写路径结束后，将得到的路径重新进行一次路径匹配 break：重写路径结束后，不再重新匹配路径。 我们这里不能选择last，否则以新的路径/upload/image来匹配，就不会被正确的匹配到8082端口了 修改完成，输入nginx -s reload命令重新加载配置。然后再次上传试试。 2.2.5.跨域问题重启nginx，再次上传，发现报错了： 不过庆幸的是，这个错误已经不是第一次见了，跨域问题。 我们在upload-service中添加一个CorsFilter即可： 1234567891011121314151617181920212223@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(\"http://manage.leyou.com\"); //2) 是否发送Cookie信息 config.setAllowCredentials(false); //3) 允许的请求方式 config.addAllowedMethod(\"OPTIONS\"); config.addAllowedMethod(\"POST\"); config.addAllowedHeader(\"*\"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\"/**\", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 再次测试： 不过，非常遗憾的是，访问图片地址，却没有响应。 这是因为我们并没有任何服务器对应image.leyou.com这个域名。。 这个问题，我们暂时放下，回头再来解决。 2.2.6.之前上传的缺陷先思考一下，之前上传的功能，有没有什么问题？ 上传本身没有任何问题，问题出在保存文件的方式，我们是保存在服务器机器，就会有下面的问题： 单机器存储，存储能力有限 无法进行水平扩展，因为多台机器的文件无法共享,会出现访问不到的情况 数据没有备份，有单点故障风险 并发能力差 这个时候，最好使用分布式文件存储来代替本地文件存储。 3.FastDFS3.1.什么是分布式文件系统分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 通俗来讲： 传统文件系统管理的文件就存储在本机。 分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问 3.2.什么是FastDFSFastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富： 文件存储 文件同步 文件访问（上传、下载） 存取负载均衡 在线扩容 适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。 3.3.FastDFS的架构3.3.1.架构图先上图： FastDFS两个主要的角色：Tracker Server 和 Storage Server 。 Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息 Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。 Storage Cluster ：存储集群，有多个Group组成。 3.3.2.上传和下载流程 上传 Client通过Tracker server查找可用的Storage server。 Tracker server向Client返回一台可用的Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。 上传完成，Storage server返回Client一个文件ID，文件上传结束。 下载 Client通过Tracker server查找要下载文件所在的的Storage server。 Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。 下载文件成功。 3.4.安装和使用参考课前资料的：《centos安装FastDFS.md》 3.5.java客户端余庆先生提供了一个Java客户端，但是作为一个C程序员，写的java代码可想而知。而且已经很久不维护了。 这里推荐一个开源的FastDFS客户端，支持最新的SpringBoot2.0。 配置使用极为简单，支持连接池，支持自动生成缩略图，狂拽酷炫吊炸天啊，有木有。 地址：tobato/FastDFS_client 3.5.1.引入依赖在父工程中，我们已经管理了依赖，版本为： 1&lt;fastDFS.client.version&gt;1.26.2&lt;/fastDFS.client.version&gt; 因此，这里我们直接引入坐标即可： 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.5.2.引入配置类纯java配置： 123456@Configuration @Import(FdfsClientConfig.class)// 解决jmx重复注册bean的问题@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)public class FastClientImporter &#123;&#125; 3.5.3.编写FastDFS属性12345678fdfs: so-timeout: 1501 connect-timeout: 601 thumb-image: # 缩略图 width: 60 height: 60 tracker-list: # tracker地址 - 192.168.20.56:22122 3.5.4.测试123456789101112131415161718192021222324252627282930313233343536373839@RunWith(SpringRunner.class)@SpringBootTest(classes = LyUploadService.class)public class FdfsTest &#123; @Autowired private FastFileStorageClient storageClient; @Autowired private ThumbImageConfig thumbImageConfig; @Test public void testUpload() throws FileNotFoundException &#123; File file = new File(\"C:\\\\Users\\\\jhmarryme\\\\Pictures\\\\Saved Pictures\\\\doge.jpg\"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadFile( new FileInputStream(file), file.length(), \"jpg\", null); System.out.println(\"**************************\"); System.out.println(FilenameUtils.getExtension(file.getName())); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); &#125; @Test public void testUploadAndCreateThumb() throws FileNotFoundException &#123; File file = new File(\"C:\\\\Users\\\\jhmarryme\\\\Pictures\\\\Saved Pictures\\\\RAIA([@[IQ&#123;0S67@W42D][M.png\"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadImageAndCrtThumbImage( new FileInputStream(file), file.length(), \"png\", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); // 获取缩略图路径 String path = thumbImageConfig.getThumbImagePath(storePath.getPath()); System.out.println(path); &#125;&#125; 结果： 123group1/M00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630_60x60.png 访问第一个路径： 访问最后一个路径（缩略图路径），注意加组名： 3.5.5.改造上传逻辑12345678910111213141516171819202122232425262728293031323334353637383940@Service@Slf4j@EnableConfigurationProperties(UploadProperties.class)public class UploadService &#123; @Autowired private FastFileStorageClient storageClient; @Autowired private UploadProperties uploadProperties;// public final List&lt;String&gt; allowTypes = Arrays.asList(\"image/jpeg\", \"image/png\", \"image/bmp\"); public String upload(MultipartFile file)&#123; try &#123; //校验文件类型 String contentType = file.getContentType(); if (!uploadProperties.getAllowTypes().contains(contentType)) &#123; throw new LyException(ExceptionEnum.FILE_TYPE_ERROR); &#125; //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) &#123; throw new LyException(ExceptionEnum.FILE_TYPE_ERROR); &#125;// //准备目标路径// File dest = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\初识项目\\\\leyou_upload\", file.getOriginalFilename());// //保存文件到本地// file.transferTo(dest); //获取文件的后缀名 String extension = FilenameUtils.getExtension(file.getOriginalFilename()); //上传文件到Fastdfs服务器 StorePath storePath = storageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //返回文件地址 return uploadProperties.getBaseUrl() + storePath.getFullPath(); &#125; catch (IOException e) &#123; log.error(\"上传文件失败\", e); throw new LyException(ExceptionEnum.UPLOAD_FILE_ERROR); &#125; &#125;&#125; 只需要把原来保存文件的逻辑去掉，然后上传到FastDFS即可。 3.5.6.测试通过RestClient测试： 3.6.页面测试上传发现上传成功： 不过，当我们访问页面时： 这是因为我们图片是上传到虚拟机的，ip为：192.168.56.101 因此，我们需要将image.leyou.com映射到192.168.56.101 修改我们的hosts： 再次上传：","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"搭建后台管理前端","slug":"项目记录/搭建后台管理前端","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:04:43.769Z","comments":true,"path":"2019/05/13/项目记录/搭建后台管理前端/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/搭建后台管理前端/","excerpt":"","text":"1.搭建后台管理前端1.1.导入已有资源导入已有项目leyou-manage-web 1.2.安装依赖没有node_modules文件夹。不过package.json中依然定义了所需的一切依赖： 打开终端，进入项目目录，输入：npm install命令，即可安装这些依赖。 大概需要几分钟。 如果安装过程出现以下问题： 删除node_modules目录，重新安装。 1.3.运行一下看看输入命令：npm run dev 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转：","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"利用Cors解决跨域问题","slug":"项目记录/利用Cors解决跨域问题","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:09:07.540Z","comments":true,"path":"2019/05/13/项目记录/利用Cors解决跨域问题/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/利用Cors解决跨域问题/","excerpt":"","text":"6.3.3.实现非常简单在leyou-gateway中编写一个配置类，并且注册CorsFilter： 123456789101112131415161718192021222324252627282930313233343536import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin(\"http://manage.leyou.com\"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod(\"OPTIONS\"); config.addAllowedMethod(\"HEAD\"); config.addAllowedMethod(\"GET\"); config.addAllowedMethod(\"PUT\"); config.addAllowedMethod(\"POST\"); config.addAllowedMethod(\"DELETE\"); config.addAllowedMethod(\"PATCH\"); // 4）允许的头信息 config.addAllowedHeader(\"*\"); // 5) 有效时长 config.setMaxAge(3600L); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration(\"/**\", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构：","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"微服务笔记(待整理)","slug":"项目记录/微服务笔记","date":"2019-05-12T16:09:29.000Z","updated":"2019-09-15T15:53:17.247Z","comments":true,"path":"2019/05/13/项目记录/微服务笔记/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/微服务笔记/","excerpt":"","text":"REST请求 请求规范GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 响应规范@ResponseBody 将java对象序列化放到响应体body里去, 默认json, 但不一定是json 状态码状态码范围 12345671xx 信息，请求收到，继续处理。范围保留用于底层HTTP的东西，你很可能永远也用不到。2xx 成功，行为被成功地接受、理解和采纳3xx 重定向，为了完成请求，必须进一步执行的动作4xx 客户端错误，请求包含语法错误或者请求无法实现。范围保留用于响应客户端做出的错误，例如。他们提供不良数据或要求不存在的东西。这些请求应该是幂等的，而不是更改服务器的状态。5xx 范围的状态码是保留给服务器端错误用的。这些错误常常是从底层的函数抛出来的，甚至开发人员也通常没法处理，发送这类状态码的目的以确保客户端获得某种响应。当收到5xx响应时，客户端不可能知道服务器的状态，所以这类状态码是要尽可能的避免。 常用:123456789101112131415200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。502 网关错误503 Service Unavailable504 网关超时 通用异常处理处理异常信息时, 通过SpringMVC的AOP拦截异常, 返回错误信息12345671. 环境依赖: (不引用启动器, 版本由父工程管理)``` yml&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 自定义枚举类用于异常信息 12345678910@Getter@AllArgsConstructor@NoArgsConstructorpublic enum ExceptionEnum &#123; //价格不能为空 PRICE_CANNOT_BE_NULL(400, \"价格不能为空\") ; private int code; private String message;&#125; 自定义信息类 12345678910111213@Datapublic class ExceptionResult &#123; private int status; private String message; private Long timestamp; public ExceptionResult(ExceptionEnum exceptionEnum) &#123; this.status = exceptionEnum.getCode(); this.message = exceptionEnum.getMessage(); this.timestamp = System.currentTimeMillis(); &#125;&#125; 自定义异常类 1234567@AllArgsConstructor@NoArgsConstructor@Getterpublic class LyException extends RuntimeException &#123; //接受枚举作为参数 private ExceptionEnum exceptionEnum;&#125; 自定义通用异常拦截器 12345678910//要想该类被扫描到, 必须和应用启动器的类处于同一个包下 @ControllerAdvicepublic class CommonExceptionHandler &#123; @ExceptionHandler(LyException.class) public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; //返回的是整个响应消息, 其中主要配置错误码和响应体 return ResponseEntity.status(e.getExceptionEnum().getCode()).body(new ExceptionResult(e.getExceptionEnum())); &#125;&#125; 应用 123456789101112131415@RestController@RequestMapping(\"item\")public class ItemController &#123; @Autowired private ItemService itemService; @PostMapping public ResponseEntity&lt;Item&gt; saveItem(Item item)&#123; //校验价格 if (item.getPrice() == null) &#123; //传递一个枚举变量 throw new LyException(ExceptionEnum.PRICE_CANNOT_BE_NULL); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(item); &#125;&#125;","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"实时刷新界面及静态图片访问","slug":"项目记录/实时刷新界面及静态图片访问","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:05:29.804Z","comments":true,"path":"2019/05/13/项目记录/实时刷新界面及静态图片访问/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/实时刷新界面及静态图片访问/","excerpt":"","text":"实时刷新问题因为访问的路径中带有了9001端口, 所以在nginx中配置manage.leyou.com 9001端口的监听, 代理路径与manage.leyou.com配置一致 访问虚拟机中静态资源图片的配置现在虚拟机中建立相应文件夹 /leyou/static再将图片压缩包image.zip导入,之后路径为/leyou/static/images/12345678910111213141516171819202122232425262728293031server &#123; # 使9001端口的请求正确到达 listen 9001; server_name manage.leyou.com; location / &#123; proxy_pass http://192.168.20.60:9001; &#125; &#125; server &#123; listen 80; server_name image.leyou.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; # 监听域名中不带group 访问的是静态资源, 直接代理访问 location / &#123; root /leyou/static/; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"修改品牌","slug":"项目记录/修改品牌(未完成)","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:12:37.776Z","comments":true,"path":"2019/05/13/项目记录/修改品牌(未完成)/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/修改品牌(未完成)/","excerpt":"","text":"4.修改品牌（作业）修改的难点在于回显。 当我们点击编辑按钮，希望弹出窗口的同时，看到原来的数据： 4.1.点击编辑出现弹窗这个比较简单，修改show属性为true即可实现，我们绑定一个点击事件： 1&lt;v-btn color=\"info\" @click=\"editBrand\"&gt;编辑&lt;/v-btn&gt; 然后编写事件，改变show 的状态： 如果仅仅是这样，编辑按钮与新增按钮将没有任何区别，关键在于，如何回显呢？ 4.2.回显数据回显数据，就是把当前点击的品牌数据传递到子组件（MyBrandForm）。而父组件给子组件传递数据，通过props属性。 第一步：在编辑时获取当前选中的品牌信息，并且记录到data中 先在data中定义属性，用来接收用来编辑的brand数据： 我们在页面触发编辑事件时，把当前的brand传递给editBrand方法： 1&lt;v-btn color=\"info\" @click=\"editBrand(props.item)\"&gt;编辑&lt;/v-btn&gt; 然后在editBrand中接收数据，赋值给oldBrand： 123456editBrand(oldBrand)&#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand;&#125;, 第二步：把获取的brand数据 传递给子组件 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class=\"px-5\"&gt; &lt;my-brand-form @close=\"closeWindow\" :oldBrand=\"oldBrand\"/&gt;&lt;/v-card-text&gt; 第三步：在子组件中通过props接收要编辑的brand数据，Vue会自动完成回显 接收数据： 通过watch函数监控oldBrand的变化，把值copy到本地的brand： 12345678910111213141516171819watch: &#123; oldBrand: &#123;// 监控oldBrand的变化 handler(val) &#123; if(val)&#123; // 注意不要直接复制，否则这边的修改会影响到父组件的数据，copy属性即可 this.brand = Object.deepCopy(val) &#125;else&#123; // 为空，初始化brand this.brand = &#123; name: '', letter: '', image: '', categories: [], &#125; &#125; &#125;, deep: true &#125;&#125; Object.deepCopy 自定义的对对象进行深度复制的方法。 需要判断监听到的是否为空，如果为空，应该进行初始化 测试：发现数据回显了，除了商品分类以外： 4.3.商品分类回显为什么商品分类没有回显？ 因为品牌中并没有商品分类数据。我们需要在进入编辑页面之前，查询商品分类信息： 4.3.1.后台提供接口 controller 12345678910111213/** * 通过品牌id查询商品分类 * @param bid * @return */@GetMapping(\"bid/&#123;bid&#125;\")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryByBrandId(@PathVariable(\"bid\") Long bid) &#123; List&lt;Category&gt; list = this.categoryService.queryByBrandId(bid); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; Service 123public List&lt;Category&gt; queryByBrandId(Long bid) &#123; return this.categoryMapper.queryByBrandId(bid);&#125; mapper 因为需要通过中间表进行子查询，所以这里要手写Sql： 1234567/** * 根据品牌id查询商品分类 * @param bid * @return */@Select(\"SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)\")List&lt;Category&gt; queryByBrandId(Long bid); 4.3.2.前台查询分类并渲染我们在编辑页面打开之前，先把数据查询完毕： 123456789101112editBrand(oldBrand)&#123; // 根据品牌信息查询商品分类 this.$http.get(\"/item/category/bid/\" + oldBrand.id) .then((&#123;data&#125;) =&gt; &#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand // 回显商品分类 this.oldBrand.categories = data; &#125;)&#125; 再次测试：数据成功回显了 4.3.3.新增窗口数据干扰但是，此时却产生了新问题：新增窗口竟然也有数据？ 原因： ​ 如果之前打开过编辑，那么在父组件中记录的oldBrand会保留。下次再打开窗口，如果是编辑窗口到没问题，但是新增的话，就会再次显示上次打开的品牌信息了。 解决： ​ 新增窗口打开前，把数据置空。 123456addBrand() &#123; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null;&#125; 4.3.4.提交表单时判断是新增还是修改新增和修改是同一个页面，我们该如何判断？ 父组件中点击按钮弹出新增或修改的窗口，因此父组件非常清楚接下来是新增还是修改。 因此，最简单的方案就是，在父组件中定义变量，记录新增或修改状态，当弹出页面时，把这个状态也传递给子组件。 第一步：在父组件中记录状态： 第二步：在新增和修改前，更改状态： 第三步：传递给子组件 第四步，子组件接收标记： 标题的动态化： 表单提交动态： axios除了除了get和post外，还有一个通用的请求方式： 1234567891011121314// 将数据提交到后台// this.$http.post('/item/brand', this.$qs.stringify(params))this.$http(&#123; method: this.isEdit ? 'put' : 'post', // 动态判断是POST还是PUT url: '/item/brand', data: this.$qs.stringify(this.brand)&#125;).then(() =&gt; &#123; // 关闭窗口 this.$emit(\"close\"); this.$message.success(\"保存成功！\");&#125;) .catch(() =&gt; &#123; this.$message.error(\"保存失败！\");&#125;); 5.删除（作业）","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"品牌查询Vue界面搭建","slug":"项目记录/品牌查询Vue界面搭建","date":"2019-05-12T16:09:29.000Z","updated":"2019-07-21T02:02:17.093Z","comments":true,"path":"2019/05/13/项目记录/品牌查询Vue界面搭建/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/品牌查询Vue界面搭建/","excerpt":"","text":"7.从0开始品牌的查询先看看我们要实现的效果： 从0开始，实现下从前端到后端的完整开发。 7.1.设计前端页面为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。 内容利用模板初始化 改变router新的index.js，将路由地址指向MyBrand.vue 7.1.1.查询表格大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档： 仔细阅读，发现v-data-table中有以下核心属性： dark：是否使用黑暗色彩主题，默认是false expand：表格的行是否可以展开，默认是false headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构： 12345678&#123; text: string, // 表头的显示文本 value: string, // 表头对应的每行数据的key align: 'left' | 'center' | 'right', // 位置 sortable: boolean, // 是否可排序 class: string[] | string,// 样式 width: string,// 宽度&#125; items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致 loading：是否显示加载数据的进度条，默认是false no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值 pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构： 123456&#123; page: 1, // 当前页 rowsPerPage: 5, // 每页大小 sortBy: '', // 排序字段 descending:false, // 是否降序&#125; total-items：分页的总条数信息，number类型，无默认值 select-all ：是否显示每一行的复选框，Boolean类型，无默认值 value：当表格可选的时候，返回选中的行 我们向下翻，找找有没有看起来牛逼的案例。 找到这样一条： 其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。 点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中 模板： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 对slot的用法不理解. 7.1.2.表格分析接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。 先看模板中table上的一些属性： 123456789&lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt;&lt;/v-data-table&gt; headers：表头信息，是一个数组 items：要在表格中展示的数据，数组结构，每一个元素是一行。在这里应该是品牌集合 pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。 total-items：总条数，在这里是品牌的总记录数 loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。 另外，在v-data-tables中，我们还看到另一段代码： 12345678&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt;&lt;/template&gt; 这段就是在渲染每一行的数据。Vue会自动遍历上面传递的items属性，并把得到的对象传递给这段template中的props.item属性。我们从中得到数据，渲染在页面即可。 我们需要做的事情，主要有两件： 给items和totalItems赋值 当pagination变化时，重新获取数据，再次给items和totalItems赋值 7.1.3.动手实现表格中具体有哪些列呢？参照品牌表： 品牌中有id,name,image,letter字段。 7.1.3.1.修改模板12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 我们修改了以下部分： items：指向一个brands变量，等下在js代码中定义 total-items：指向了totalBrands变量，等下在js代码中定义 template模板中，渲染了四个字段： id： name image，注意，我们不是以文本渲染，而是赋值到一个img标签的src属性中，并且做了非空判断 letter 7.1.3.2.编写数据模型接下来编写要用到的数据： 1234567891011121314data () &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', value: 'name', sortable: false&#125;, &#123;text: 'LOGO', align: 'center', value: 'image', sortable: false&#125;, &#123;text: '首字母', align: 'center', value: 'letter'&#125;, ] &#125;&#125; 7.1.3.3.数据初始化接下来就是对brands和totalBrands完成赋值动作了。 我们编写一个函数来完成赋值，提高复用性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748methods: &#123; getDataFromServer()&#123; // 从服务端加载数据的函数 // 伪造演示数据 const brands = [ &#123; \"id\": 2032, \"name\": \"OPPO\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg\", \"letter\": \"O\", \"categories\": null &#125;, &#123; \"id\": 2033, \"name\": \"飞利浦（PHILIPS）\", \"image\": \"http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg\", \"letter\": \"F\", \"categories\": null &#125;, &#123; \"id\": 2034, \"name\": \"华为（HUAWEI）\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg\", \"letter\": \"H\", \"categories\": null &#125;, &#123; \"id\": 2036, \"name\": \"酷派（Coolpad）\", \"image\": \"http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg\", \"letter\": \"K\", \"categories\": null &#125;, &#123; \"id\": 2037, \"name\": \"魅族（MEIZU）\", \"image\": \"http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg\", \"letter\": \"M\", \"categories\": null &#125; ]; // 延迟一段时间，模拟数据请求时间 setTimeout(()=&gt;&#123; this.brands = brands; // 赋值给品牌数组 this.totalBrands = brands.length; // 赋值数据总条数 this.loading = false; // 数据加载完成 &#125;, 1000); &#125;&#125; 然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数： 1234// 渲染后执行mounted()&#123; this.getDataFromServer() // 调用数据初始化函数&#125; 6.2.3.4.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;myBrand&quot;, data () &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, value: &apos;name&apos;, sortable: false&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, value: &apos;image&apos;, sortable: false&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;&#125;, ] &#125; &#125;, methods: &#123; getDataFromServer()&#123; // 从服务端加载数据的函数 // 伪造演示数据 const brands = [ &#123; &quot;id&quot;: 2032, &quot;name&quot;: &quot;OPPO&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg&quot;, &quot;letter&quot;: &quot;O&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2033, &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;, &quot;image&quot;: &quot;http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg&quot;, &quot;letter&quot;: &quot;F&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2034, &quot;name&quot;: &quot;华为（HUAWEI）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg&quot;, &quot;letter&quot;: &quot;H&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2036, &quot;name&quot;: &quot;酷派（Coolpad）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg&quot;, &quot;letter&quot;: &quot;K&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2037, &quot;name&quot;: &quot;魅族（MEIZU）&quot;, &quot;image&quot;: &quot;http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg&quot;, &quot;letter&quot;: &quot;M&quot;, &quot;categories&quot;: null &#125; ]; // 延迟一段时间，模拟数据请求时间 setTimeout(()=&gt;&#123; this.brands = brands; // 赋值给品牌数组 this.totalBrands = brands.length; // 赋值数据总条数 this.loading = false; // 数据加载完成 &#125;, 1000); &#125; &#125;, // 渲染后执行 mounted()&#123; this.getDataFromServer() // 调用数据初始化函数 &#125; &#125;&lt;/script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;/style&gt; 7.1.4.优化页面7.1.4.1.编辑和删除按钮我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列。 其实就是多了一列，只是这一列没有数据，而是两个按钮而已。可以在官方文档中找一个带有操作按钮的表格，作为参考。 我们先在头（headers）中添加一列： 1234567headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', value: 'name', sortable: false&#125;, &#123;text: 'LOGO', align: 'center', value: 'image', sortable: false&#125;, &#123;text: '首字母', align: 'center', value: 'letter'&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false &#125;] 然后在模板中添加按钮： 1234567891011121314&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-icon small class=&quot;mr-2&quot; @click=&quot;editItem(props.item)&quot;&gt; edit &lt;/v-icon&gt; &lt;v-icon small @click=&quot;deleteItem(props.item)&quot;&gt; delete &lt;/v-icon&gt; &lt;/td&gt;&lt;/template&gt; 效果： 7.1.4.2.新增按钮在官方文档中找到按钮的用法： 因为新增跟某个品牌无关，是独立的，因此我们可以放到表格的外面。 效果： 7.1.4.3.卡片（card）为了不让按钮显得过于孤立，我们可以将按新增按钮和表格放到一张卡片（card）中。 我们去官网查看卡片的用法： 卡片v-card包含四个基本组件： v-card-media：一般放图片或视频 v-card-title：卡片的标题，一般位于卡片顶部 v-card-text：卡片的文本（主体内容），一般位于卡片正中 v-card-action：卡片的按钮，一般位于卡片底部 我们可以把新增的按钮放到v-card-title位置，把table放到下面，这样就成一个上下关系。 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;v-card&gt; &lt;v-card-title flat color=&quot;white&quot;&gt; &lt;v-btn color=&quot;primary&quot;&gt;新增&lt;/v-btn&gt; &lt;/v-card-title&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-icon small class=&quot;mr-2&quot; @click=&quot;editItem(props.item)&quot;&gt; edit &lt;/v-icon&gt; &lt;v-icon small @click=&quot;deleteItem(props.item)&quot;&gt; delete &lt;/v-icon&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-card&gt;&lt;/template&gt; 效果： 7.1.4.4.添加搜索框我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。 查看官网中，文本框的用法： name：字段名，表单中会用到 label/placeholder：提示文字 value：值。可以用v-model代替，实现双向绑定 修改模板，添加输入框： 12345&lt;v-card-title&gt; &lt;v-btn color=\"primary\"&gt;新增品牌&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\"/&gt;&lt;/v-card-title&gt; 注意：要在数据模型中，添加search字段： 12345678910111213141516data() &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 search: \"\", // 查询关键字 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', value: 'name', sortable: false&#125;, &#123;text: 'LOGO', align: 'center', value: 'image', sortable: false&#125;, &#123;text: '首字母', align: 'center', value: 'letter'&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false&#125; ] &#125;&#125; 效果： 发现输入框超级长！！！ 这个时候，我们可以使用Vuetify提供的一个空间隔离工具： 修改代码： 1234567&lt;v-card-title&gt; &lt;v-btn color=\"primary\"&gt;新增品牌&lt;/v-btn&gt; &lt;!--空间隔离组件--&gt; &lt;v-spacer /&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\"/&gt;&lt;/v-card-title&gt; 7.1.4.5.添加搜索图标查看textfiled的文档，发现： 通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 material-icons官网去查看。 修改我们的代码： 1&lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\" append-icon=\"search\"/&gt; 7.1.4.6.把文本框变紧凑搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示： 修改代码： 1&lt;v-text-field label=\"输入关键字搜索\" v-model=\"search\" append-icon=\"search\" hide-details/&gt; 效果： 几乎已经达到了原来一样的效果了吧！ 7.2.后台提供查询接口前台页面已经准备好，接下来就是后台提供数据接口了。 7.2.1.数据库表1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 7.2.2.实体类 12345678910@Data@Table(name = \"tb_brand\")public class Brand &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter;&#125; 7.2.3.mapper 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; 7.2.4.controller编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125; public Long getTotal() &#123; return total; &#125; public void setTotal(Long total) &#123; this.total = total; &#125; public List&lt;T&gt; getItems() &#123; return items; &#125; public void setItems(List&lt;T&gt; items) &#123; this.items = items; &#125; public Long getTotalPage() &#123; return totalPage; &#125; public void setTotalPage(Long totalPage) &#123; this.totalPage = totalPage; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到leyou-common中，提高复用性： 不要忘记在leyou-item-service工程的pom.xml中引入leyou-common的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;leyou-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 接下来，我们编写Controller 123456789101112131415161718192021@RestController@RequestMapping(\"brand\")public class BrandController &#123; @Autowired private BrandService brandService; @GetMapping(\"page\") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage( @RequestParam(value = \"page\", defaultValue = \"1\") Integer page, @RequestParam(value = \"rows\", defaultValue = \"5\") Integer rows, @RequestParam(value = \"sortBy\", required = false) String sortBy, @RequestParam(value = \"desc\", defaultValue = \"false\") Boolean desc, @RequestParam(value = \"key\", required = false) String key) &#123; PageResult&lt;Brand&gt; result = this.brandService.queryBrandByPageAndSort(page,rows,sortBy,desc, key); if (result == null || result.getItems().size() == 0) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(result); &#125;&#125; 7.2.5.Service 123456789101112131415161718192021222324252627@Servicepublic class BrandService &#123; @Autowired private BrandMapper brandMapper; public PageResult&lt;Brand&gt; queryBrandByPageAndSort( Integer page, Integer rows, String sortBy, Boolean desc, String key) &#123; // 开始分页 PageHelper.startPage(page, rows); // 过滤 Example example = new Example(Brand.class); if (StringUtils.isNotBlank(key)) &#123; example.createCriteria().andLike(\"name\", \"%\" + key + \"%\") .orEqualTo(\"letter\", key); &#125; if (StringUtils.isNotBlank(sortBy)) &#123; // 排序 String orderByClause = sortBy + (desc ? \" DESC\" : \" ASC\"); example.setOrderByClause(orderByClause); &#125; // 查询 Page&lt;Brand&gt; pageInfo = (Page&lt;Brand&gt;) brandMapper.selectByExample(example); // 返回结果 return new PageResult&lt;&gt;(pageInfo.getTotal(), pageInfo); &#125;&#125; 7.2.6.测试通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染 7.3.异步查询工具axios异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 7.3.1.axios入门Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get(\"/item/category/list?pid=0\") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get(\"/item/category/list\", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post(\"/user\",&#123; name:\"Jack\", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 7.3.2.axios的全局配置而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 7.3.3.小试一下我们在组件MyBrand.vue的getDataFromServer方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： resp到底都有那些数据，查看控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 7.4.异步加载品牌数据虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性： 分别是： descending：是否是降序，对应请求参数的desc page：当前页，对应参数的page rowsPerpage：每页大小，对应参数中的rows sortBy：排序字段，对应参数的sortBy 缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。 另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。 接下来，我们完善请求参数： 12345678910111213141516171819methods: &#123; getDataFromServer() &#123; // 从服务端加载数据的函数 this.loading = true; // 加载数据 // 通过axios获取数据 this.$http.get(\"/item/brand/page\", &#123; params: &#123; page: this.pagination.page, // 当前页 rows: this.pagination.rowsPerPage, // 每页条数 sortBy: this.pagination.sortBy, // 排序字段 desc: this.pagination.descending, // 是否降序 key: this.search // 查询字段 &#125; &#125;).then(resp =&gt; &#123; // 获取响应结果对象 this.totalBrands = resp.data.total; // 总条数 this.brands = resp.data.items; // 品牌数据 this.loading = false; // 加载完成 &#125;); &#125;&#125; 查看网络请求： 效果： 7.5.完成分页和过滤6.6.1.分页现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？ 虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！ 具体实现： 成功实现分页功能： 6.6.2.过滤分页实现了，过滤也很好实现了。过滤字段对应的是search属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 6.7.完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;template&gt; &lt;v-card&gt; &lt;v-card-title flat color=&quot;white&quot;&gt; &lt;v-btn color=&quot;primary&quot;&gt;新增&lt;/v-btn&gt; &lt;!--空间隔离组件--&gt; &lt;v-spacer /&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-text-field label=&quot;输入关键字搜索&quot; append-icon=&quot;search&quot; v-model=&quot;search&quot; hide-details/&gt; &lt;/v-card-title&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;/&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-icon small class=&quot;mr-2&quot; @click=&quot;editItem(props.item)&quot;&gt; edit &lt;/v-icon&gt; &lt;v-icon small @click=&quot;deleteItem(props.item)&quot;&gt; delete &lt;/v-icon&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;myBrand&quot;, data() &#123; return &#123; totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 search: &quot;&quot;, // 查询关键字 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, value: &apos;name&apos;, sortable: false&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, value: &apos;image&apos;, sortable: false&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;&#125;, &#123;text: &apos;操作&apos;, align: &apos;center&apos;, value: &apos;id&apos;, sortable: false&#125; ] &#125; &#125;, watch: &#123; pagination:&#123; deep: true, // 深度监视 handler()&#123; this.getDataFromServer(); &#125; &#125;, search()&#123; this.pagination.page = 1; this.getDataFromServer(); &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务端加载数据的函数 this.loading = true; // 加载数据 // 通过axios获取数据 this.$http.get(&quot;/item/brand/page&quot;, &#123; params: &#123; page: this.pagination.page, // 当前页 rows: this.pagination.rowsPerPage, // 每页条数 sortBy: this.pagination.sortBy, // 排序字段 desc: this.pagination.descending, // 是否降序 key: this.search // 查询字段 &#125; &#125;).then(resp =&gt; &#123; // 获取响应结果对象 this.totalBrands = resp.data.total; // 总条数 this.brands = resp.data.items; // 品牌数据 this.loading = false; // 加载完成 &#125;); &#125; &#125;, // 渲染后执行 mounted() &#123; this.getDataFromServer() // 调用数据初始化函数 &#125; &#125;&lt;/script&gt;&lt;!-- scoped:当前样式只作用于当前组件的节点 --&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"跨域分析","slug":"项目记录/跨域分析","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:04:25.631Z","comments":true,"path":"2019/05/13/项目记录/跨域分析/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/跨域分析/","excerpt":"","text":"6.跨域问题跨域：浏览器对于javascript的同源策略的限制 。 以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 6.1.为什么有跨域问题？跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是与当前页域名相同的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 6.2.解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 6.3.cors解决跨域6.3.1.什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 6.3.2.原理有点复杂浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 6.3.2.1.简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名） Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 有关cookie： 要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 6.3.2.2.特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"使用域名访问本地项目","slug":"项目记录/使用域名访问本地项目","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-22T05:45:29.166Z","comments":true,"path":"2019/05/13/项目记录/使用域名访问本地项目/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/使用域名访问本地项目/","excerpt":"","text":"4.使用域名访问本地项目域名解析 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 解决域名解析问题使用SwitchHosts伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 ping一下域名试试是否畅通 然后通过域名访问： 原因：我们配置了项目访问的路径，虽然manage.leyou.com映射的ip也是127.0.0.1，但是webpack会验证host是否符合配置。 在webpack.dev.conf.js中取消host验证： 重新执行npm run dev，刷新浏览器： OK！ nginx解决端口问题","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"后台管理系统前端项目结构","slug":"项目记录/后台管理系统前端项目结构","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:08:46.588Z","comments":true,"path":"2019/05/13/项目记录/后台管理系统前端项目结构/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/后台管理系统前端项目结构/","excerpt":"","text":"3.项目结构开始编码前，我们先了解下项目的结构。 3.1.目录结构首先是目录结构图： 3.2.调用关系我们最主要理清index.html、main.js、App.vue之间的关系： 理一下： index.html：html模板文件。定义了空的div，其id为app。 main.js：实例化vue对象，并且绑定通过id选择器，绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。main.js中使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。index.html引用它之后，就拥有了vue的内容（包括组件、样式等），所以，main.js也是webpack打包的入口。 index.js：定义请求路径和组件的映射关系。相当于之前的&lt;vue-router&gt; App.vue中也没有内容，而是定义了vue-router的锚点：&lt;router-view&gt;,我们之前讲过，vue-router路由后的组件将会在锚点展示。 最终结论：一切路由后的内容都将通过App.vue在index.html中显示。 访问流程：用户在浏览器输入路径，例如：http://localhost:9001/#/item/brand –&gt; index.js(/item/brand路径对应pages/item/Brand.vue组件) –&gt; 该组件显示在App.vue的锚点位置 –&gt; main.js使用了App.vue组件，并把该组件渲染在index.html文件中（id为“app”的div中） 3.3.页面布局接下来我们一起看下页面布局。 Layout组件是我们的整个页面的布局组件： 一个典型的三块布局。包含左，上，中三部分： 里面使用了Vuetify中的2个组件和一个布局元素： v-navigation-drawer ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 ![1530380237867](https://jhmarryme-1257584644.cos.ap-chengdu.myqcloud.com/springboot%E5%BE%AE%E6%9C%8D%E5%8A%A1/day6/assets/1530380237867.png) v-toolbar：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。 v-content：并不是一个组件，而是标记页面布局的元素。可以根据您指定的app组件的结构动态调整大小，使得您可以创建高度可定制的组件。 那么问题来了：v-content中的内容来自哪里？ Layout映射的路径是/ 除了Login以为的所有组件，都是定义在Layout的children属性，并且路径都是/的下面 因此当路由到子组件时，会在Layout中定义的锚点中显示。 并且Layout中的其它部分不会变化，这就实现了布局的共享。","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"新增完成后关闭窗口","slug":"项目记录/品牌新增后的关闭弹窗","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:06:35.569Z","comments":true,"path":"2019/05/13/项目记录/品牌新增后的关闭弹窗/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/品牌新增后的关闭弹窗/","excerpt":"","text":"1.4.新增完成后关闭窗口我们发现有一个问题：新增不管成功还是失败，窗口都一致在这里，不会关闭。 这样很不友好，我们希望如果新增失败，窗口保持；但是新增成功，窗口关闭才对。 因此，我们需要在新增的ajax请求完成以后，关闭窗口 但问题在于，控制窗口是否显示的标记在父组件：MyBrand.vue中。子组件如何才能操作父组件的属性？或者告诉父组件该关闭窗口了？ 之前我们讲过一个父子组件的通信，有印象吗？ 第一步，在父组件中定义一个函数，用来关闭窗口，不过之前已经定义过了，我们优化一下，关闭的同时重新加载数据： 123456closeWindow()&#123; // 关闭窗口 this.show = false; // 重新加载数据 this.getDataFromServer();&#125; 第二步，父组件在使用子组件时，绑定事件，关联到这个函数： 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class=\"px-5\"&gt; &lt;my-brand-form @close=\"closeWindow\"/&gt;&lt;/v-card-text&gt; 第三步，子组件通过this.$emit调用父组件的函数： 测试一下","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"webpack及vue-cli","slug":"项目记录/webpack及vue框架相关i","date":"2019-05-12T16:09:29.000Z","updated":"2019-09-15T15:54:48.847Z","comments":true,"path":"2019/05/13/项目记录/webpack及vue框架相关i/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/webpack及vue框架相关i/","excerpt":"","text":"1. 学习目标 了解vue-router使用 了解webpack使用 会使用vue-cli搭建项目 独立搭建后台管理系统 了解系统基本结构 2. 路由vue-router2.1. 场景模拟现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换： 2.1.1. 编写父组件为了让接下来的功能比较清晰，我们先新建一个文件夹：src: 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id=\"app\"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src=\"../node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#app\" &#125;)&lt;/script&gt; 样式： 2.1.2. 编写登录组件接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放如独立的JS文件中，我们新建一个login.js 编写组件，这里我们只写模板，不写功能： 123456789const loginForm = &#123; template:'\\ &lt;div&gt;\\ &lt;h2&gt;登录页&lt;/h2&gt; \\ 用户名：&lt;input type=\"text\"&gt;&lt;br/&gt;\\ 密码：&lt;input type=\"password\"&gt;&lt;br/&gt;\\ &lt;/div&gt;\\ '&#125; 2.1.3. 编写注册组件新建单文件组件：register.js 编写模板： 12345678910const registerForm = &#123; template:'\\ &lt;div&gt;\\ &lt;h2&gt;注册页&lt;/h2&gt; \\ 用户名：&lt;input type=\"text\"&gt;&lt;br/&gt;\\ 密码：&lt;input type=\"password\"&gt;&lt;br/&gt;\\ 确认密码：&lt;input type=\"password\"&gt;&lt;br/&gt;\\ &lt;/div&gt;\\ '&#125; 2.1.4. 在父组件中引用在index.html中使用刚刚编写的两个组件 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src=\"../node_modules/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"js/login.js\"&gt;&lt;/script&gt;&lt;script src=\"js/register.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el:\"#app\", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 2.1.5. 问题我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 2.2. vue-router简介和安装使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装： 1npm install vue-router --save 在index.html中引入依赖： 1&lt;script src=\"../node_modules/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 2.3. 快速入门新建vue-router对象，并且指定路由规则： 12345678910// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写多个路由规则 &#123; path:\"/login\", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:\"/register\",component:registerForm&#125;, ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:\"#app\", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制： 12345678910&lt;div id=\"app\"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html 3. webpack3.1. 认识webpackWebpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 3.2. 四个核心概念学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的启点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 3.3. 安装webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。 输入命令： 1npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 3.4. 编写webpack配置接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 3.4.1. 入口entrywebpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？ 我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！ 然后把原来index.html中的js代码全部移动到main.js中 1234567891011121314151617181920212223242526// 使用es6的语法导入js模块import Vue from '../node_modules/vue/dist/vue';import VueRouter from '../node_modules/vue-router/dist/vue-router'import loginForm from './js/login'import registerForm from './js/register'Vue.use(VueRouter)// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写多个路由规则 &#123; path:\"/login\", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:\"/register\",component:registerForm&#125;, ]&#125;)var vm = new Vue(&#123; el:\"#app\", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router&#125;) 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 注意，要使用import，就需要在login.js和register.js中添加export导出语句： 12345678910const loginForm = &#123; template:` &lt;div&gt; &lt;h2&gt;登录页&lt;/h2&gt; 用户名：&lt;input type=\"text\"&gt;&lt;br/&gt; 密码：&lt;input type=\"password\"&gt;&lt;br/&gt; &lt;/div&gt; `&#125;export default loginForm; register.js: 1234567891011const registerForm = &#123; template:` &lt;div&gt; &lt;h2&gt;注册页&lt;/h2&gt; 用户名：&lt;input type=\"text\"&gt;&lt;br/&gt; 密码：&lt;input type=\"password\"&gt;&lt;br/&gt; 确认密码：&lt;input type=\"password\"&gt;&lt;br/&gt; &lt;/div&gt; `&#125;export default registerForm; vue-router使用模块话加载后，必须增加一句：Vue.use(VueRouter) 这样，main.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件&#125; 3.4.2. 出口output出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件 output:&#123; // path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 path : __dirname+'/dist', filename:'build.js' //输出的js文件名 &#125;&#125; 3.5. 执行打包在控制台输入以下命令： 1npx webpack --config webpack.config.js 随后，查看dist目录： 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 3.6. 测试运行在index.html中引入刚刚生成的build.js文件， 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=\"../dist/build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行： 3.7. 打包CSS3.7.1. 编写css文件我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a&#123; display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;&#125;#app a:hover&#123; background-color: whitesmoke; color: dodgerblue;&#125;#app div&#123; width: 300px; height: 150px;&#125;#app&#123; width: 305px; border: 1px solid dodgerblue;&#125; 3.7.2. 安装加载器前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 命令： 1npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： 3.7.3. 在main.js引入css文件因为入口在main.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import './css/main.css' 3.7.4. 在webpack.config.js添加加载器123456789101112131415161718module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 3.7.5. 重新打包再次输入打包指令：npx webpack --config webpack.config.js 效果： 3.8. script脚本我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是脚本的名称build 3.9. 打包HTML之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件： 1npm install html-webpack-plugin --save-dev 需要在webpack.config.js中添加插件： 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: '首页', //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: 'index.html', // dist目录下生成的文件名 template: './src/index.html' // 我们原来的index.html，作为模板 &#125;) ]&#125; 2）将原来HTML中的引入js代码删除： 3）再次打包：npm run build 4）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type=\"text/javascript\" src=\"build.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.10. 热更新的web服务刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件： 1npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123\"scripts\": &#123; \"dev\": \"webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1\"&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3）运行脚本： 1npm run dev 4）效果： 4. vue-cli4.1. 介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令： 1npm install -g vue-cli 4.2. 快速上手我们新建一个module： 打开终端并进入目录： 用vue-cli命令，快速搭建一个webpack的项目： 1vue init webpack 前面几项都走默认或yes 下面这些我们选no 最后，再选yes，使用 npm安装 4.3. 项目结构安装好的项目结构： 入口文件： 4.4. 单文件组件需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的loginForm.js和registerForm.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，看到上面的data(){}了吧 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 4.5. 运行看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面： 5. Vuetify框架5.1. 为什么要学习UI框架Vue负责的是虽然会帮我们进行视图的渲染，但是样式是有我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 5.2. 为什么是Vuetify有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 这是官网的说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 5.3. 怎么用？基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 6. 项目结构开始编码前，我们先了解下项目的结构： 6.1. 目录结构首先是目录结构图： 6.2. 调用关系我们最主要理清index.html、main.js、App.vue之间的关系： 理一下： index.html中定义了空的div，其id为app。 main.js中定义了Vue对象，并且绑定通过id选择器，绑定到index.html的div中，因此main.js的内容都将在index.html的div中显示。 而main.js中只有一行内容：&lt;App/&gt;,这是使用了App组件，即App.vue，也就是说index.html中最终展现的是App.vue中的内容。 App.vue中也没有内容，而是定义了vue-router的锚点：&lt;router-view&gt;,我们之前讲过，vue-router路由后的组件将会在锚点展示。 最终的结论是：一切路由后的内容都将通过App.vue在index.html中显示。 6.3. 页面布局接下来我们一起看下页面布局： Layout组件是我们的整个页面的布局组件： 一个典型的三块布局。包含左，上，中三部分： 里面使用了Vuetify中的2个组件和一个布局元素： v-navigation-drawer ：导航抽屉，主要用于容纳应用程序中的页面的导航链接。 v-toolbar：工具栏通常是网站导航的主要途径。可以与导航抽屉一起很好地工作，动态选择是否打开导航抽屉，实现可伸缩的侧边栏。 v-content：并不是一个组件，而是标记页面布局的元素。可以根据您指定的app组件的结构动态调整大小，使得您可以创建高度可定制的组件。 那么问题来了：v-content中的内容来自哪里？ Layout映射的路径是/ 除了Login以为的所有组件，都是定义在Layout的children属性，并且路径都是/的下面 因此当路由到子组件时，会在Layout中定义的锚点中显示。 并且Layout中的其它部分不会变化，这就实现了布局的共享。","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://wangdaye7.github.io/categories/前端框架/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"商品分类查询后端实现","slug":"项目记录/商品分类查询后端实现","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:05:49.734Z","comments":true,"path":"2019/05/13/项目记录/商品分类查询后端实现/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/商品分类查询后端实现/","excerpt":"","text":"5.实现商品分类查询商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示： 一个商品分类下有很多商品 一个商品分类下有很多品牌 而一个品牌，可能属于不同的分类 一个品牌下也会有很多商品 依次去完成：商品分类、品牌、商品的开发。 5.1.导入数据首先导入课前资料提供的sql 商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 5.2.页面实现5.2.1.页面分析首先我们看下要实现的效果： 商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。 一起来看页面，对应的是/pages/item/Category.vue： 页面模板： 1234567891011121314&lt;template&gt; &lt;v-card&gt; &lt;v-flex xs12 sm10&gt; &lt;v-tree url=\"/item/category/list\" :treeData=\"treeData\" :isEdit=\"isEdit\" @handleAdd=\"handleAdd\" @handleEdit=\"handleEdit\" @handleDelete=\"handleDelete\" @handleClick=\"handleClick\" /&gt; &lt;/v-flex&gt; &lt;/v-card&gt;&lt;/template&gt; v-card：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。 v-flex：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度： 本例中，我们用sm10控制在小屏幕及以上时，显示宽度为10格 v-tree：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件： 里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。 5.2.2.树组件的用法也可参考课前资料中的：《自定义Vue组件的用法.md》 这里我贴出树组件的用法指南。 属性列表： 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; \"id\": 74, \"name\": \"手机\", \"parentId\": 0, \"isParent\": true, \"sort\": 2 &#125;, &#123; \"id\": 75, \"name\": \"家用电器\", \"parentId\": 0, \"isParent\": true, \"sort\": 3 &#125;] 事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含完整的node信息 完整node的信息 回调函数中返回完整的node节点会包含以下数据： 12345678&#123; \"id\": 76, // 节点id \"name\": \"手机\", // 节点名称 \"parentId\": 75, // 父节点id \"isParent\": false, // 是否是父节点 \"sort\": 1, // 顺序 \"path\": [\"手机\", \"手机通讯\", \"手机\"] // 所有父节点的名称数组&#125; 5.3.实现功能5.3.1.url异步请求给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么： 1234567&lt;v-tree url=\"/item/category/list\" :isEdit=\"isEdit\" @handleAdd=\"handleAdd\" @handleEdit=\"handleEdit\" @handleDelete=\"handleDelete\" @handleClick=\"handleClick\" /&gt; 刷新页面，可以看到： 页面中的树没有了，并且发起了一条请求：http://localhost/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://localhost/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名。 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 5.3.2.实体类在ly-item-interface中添加category实体类： 内容： 1234567891011@Table(name=\"tb_category\")@Datapublic class Category &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private String name; private Long parentId; private Boolean isParent; private Integer sort;&#125; 需要注意的是，这里要用到jpa的注解，因此我们在ly-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 5.3.3.controller编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; \"id\": 74, \"name\": \"手机\", \"parentId\": 0, \"isParent\": true, \"sort\": 2 &#125;, &#123; \"id\": 75, \"name\": \"家用电器\", \"parentId\": 0, \"isParent\": true, \"sort\": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。也就是List&lt;Category&gt; controller代码： 12345678910111213141516171819202122232425262728293031323334package com.leyou.item.web;import com.leyou.item.pojo.Category;import com.leyou.item.service.CategoryService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author jhmarryme.cn * @date 2019/5/16 12:37 */@RestController@RequestMapping(\"category\")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 通过pid查找商品分类 * @param pid * @return */ @GetMapping(\"list\") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoryListByPid(@RequestParam(\"pid\") Long pid)&#123; return ResponseEntity.ok(categoryService.queryCategoryListByPid(pid)); &#125;&#125; 5.3.4.service一般service层会定义接口和实现类，这里直接写实现类了： 1234567891011121314151617181920212223242526272829303132333435363738package com.leyou.item.service;import com.leyou.common.enums.ExceptionEnum;import com.leyou.common.exception.LyException;import com.leyou.item.mapper.CategoryMapper;import com.leyou.item.pojo.Category;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.util.List;/** * @author jhmarryme.cn * @date 2019/5/16 12:35 */@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; /** * 根据parentId查询子类目 * @param pid * @return */ public List&lt;Category&gt; queryCategoryListByPid(Long pid) &#123; Category category = new Category(); category.setParentId(pid); List categories = categoryMapper.select(category); //判断结果 if (CollectionUtils.isEmpty(categories))&#123; //未找到, 通过自定义异常处理 throw new LyException(ExceptionEnum.CATEGORY_NOT_FOUND); &#125; return categories; &#125;&#125; 5.3.5.mapper我们使用通用mapper来简化开发： 1234567891011package com.leyou.item.mapper;import com.leyou.item.pojo.Category;import tk.mybatis.mapper.common.Mapper;/** * @author jhmarryme.cn * @date 2019/5/16 12:35 */public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 1234567891011121314151617181920package com.leyou;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import tk.mybatis.spring.annotation.MapperScan;/** * @author jhmarryme.cn * @date 2019/5/14 19:58 */@SpringBootApplication@EnableDiscoveryClient@MapperScan(\"com.leyou.item.mapper\")public class LyItemServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemServiceApplication.class, args); &#125;&#125; 5.3.6.启动并测试我们不经过网关，直接访问：http://localhost:8081/category/list 然后试试网关是否畅通：http://api.leyou.com/api/item/category/list 一切OK！ 然后刷新后台管理页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"品牌新增后端实现","slug":"项目记录/品牌新增后端实现","date":"2019-05-12T16:09:29.000Z","updated":"2019-05-21T03:06:21.447Z","comments":true,"path":"2019/05/13/项目记录/品牌新增后端实现/","link":"","permalink":"https://wangdaye7.github.io/2019/05/13/项目记录/品牌新增后端实现/","excerpt":"","text":"1.2.后台实现新增1.2.1.controller还是一样，先分析四个内容： 请求方式：刚才看到了是POST 请求路径：/brand 请求参数：brand对象，外加商品分类的id数组cids 返回值：无 代码： 12345678910/** * 新增品牌 * @param brand * @return */@PostMappingpublic ResponseEntity&lt;Void&gt; saveBrand(Brand brand, @RequestParam(\"cids\") List&lt;Long&gt; cids) &#123; this.brandService.saveBrand(brand, cids); return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; 1.2.2.Service这里要注意，我们不仅要新增品牌，还要维护品牌和商品分类的中间表。 123456789@Transactionalpublic void saveBrand(Brand brand, List&lt;Long&gt; cids) &#123; // 新增品牌信息 this.brandMapper.insertSelective(brand); // 新增品牌和分类中间表 for (Long cid : cids) &#123; this.brandMapper.insertCategoryBrand(cid, brand.getId()); &#125;&#125; 这里调用了brandMapper中的一个自定义方法，来实现中间表的数据新增 1.2.3.Mapper通用Mapper只能处理单表，也就是Brand的数据，因此我们手动编写一个方法及sql，实现中间表的新增： 12345678910public interface BrandMapper extends Mapper&lt;Brand&gt; &#123; /** * 新增商品分类和品牌中间表数据 * @param cid 商品分类id * @param bid 品牌id * @return */ @Insert(\"INSERT INTO tb_category_brand (category_id, brand_id) VALUES (#&#123;cid&#125;,#&#123;bid&#125;)\") int insertCategoryBrand(@Param(\"cid\") Long cid, @Param(\"bid\") Long bid);&#125; 1.3.请求参数格式错误1.3.1.原因分析我们填写表单并提交，发现报错了： 查看控制台的请求详情： 发现请求的数据格式是JSON格式。 原因分析： axios处理请求体的原则会根据请求数据的格式来定： 如果请求体是对象：会转为json发送 如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。 如：name=jack&amp;age=12 1.3.2.QS工具QS是一个第三方库，我们可以用npm install qs --save来安装。不过我们在项目中已经集成了，大家无需安装： 这个工具的名字：QS，即Query String，请求参数字符串。 什么是请求参数字符串？例如： name=jack&amp;age=21 QS工具可以便捷的实现 JS的Object与QueryString的转换。 在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过this.$qs来获取这个工具： 我们将this.$qs对象打印到控制台： 123created()&#123; console.log(this.$qs);&#125; 发现其中有3个方法： 这里我们要使用的方法是stringify，它可以把Object转为QueryString。 测试一下，使用浏览器工具，把qs对象保存为一个临时变量： 然后调用stringify方法： 成功将person对象变成了 name=jack&amp;age=21的字符串了 1.3.3.解决问题修改页面，对参数处理后发送： 然后再次发起请求： 发现请求成功： 参数格式： 数据库：","categories":[{"name":"微服务项目存档","slug":"微服务项目存档","permalink":"https://wangdaye7.github.io/categories/微服务项目存档/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"}]},{"title":"ssmAop日志接触","slug":"allTemp/ssmAop日志接触","date":"2019-03-25T18:03:13.000Z","updated":"2019-09-15T15:49:21.510Z","comments":true,"path":"2019/03/26/allTemp/ssmAop日志接触/","link":"","permalink":"https://wangdaye7.github.io/2019/03/26/allTemp/ssmAop日志接触/","excerpt":"","text":"ssm中的AOP日志使用简单日志处理 在spring-mvc.xml中开启AOP注解支持 123456&lt;!-- 支持AOP的注解支持，AOP底层使用代理技术 JDK动态代理，要求必须有接口 cglib代理，生成子类对象，proxy-target-class=\"true\" 默认使用cglib的方式 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; 切面类的编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Component@Aspectpublic class LogAop &#123; @Autowired private HttpServletRequest request; @Autowired private SysLogService sysLogService; private Date visitTime; //开始时间 private Class clazz; //访问的类 private Method method;//访问的方法 //前置通知 主要是获取开始时间，执行的类是哪一个，执行的是哪一个方法 @Before(\"execution(* jhmarryme.controller.*.*(..))\") public void doBefore(JoinPoint jp) throws NoSuchMethodException &#123; visitTime = new Date();//当前时间就是开始访问的时间 clazz = jp.getTarget().getClass(); //具体要访问的类 String methodName = jp.getSignature().getName(); //获取访问的方法的名称 Object[] args = jp.getArgs();//获取访问的方法的参数 //获取具体执行的方法的Method对象 if (args == null || args.length == 0) &#123; //这里只能获取无参数的方法 method = clazz.getMethod(methodName); &#125; else &#123; Class[] classArgs = new Class[args.length]; for (int i = 0; i &lt; args.length; i++) &#123; classArgs[i] = args[i].getClass(); &#125; clazz.getMethod(methodName, classArgs); &#125; &#125; //后置通知 @After(\"execution(* jhmarryme.controller.*.*(..))\") public void doAfter(JoinPoint jp) throws Exception &#123; //获取访问的时长 long time = System.currentTimeMillis() - visitTime.getTime(); String url = \"\"; //获取url if (clazz != null &amp;&amp; method != null &amp;&amp; clazz != LogAop.class) &#123; //1.获取类上的@RequestMapping(\"/orders\") RequestMapping classAnnotation = (RequestMapping) clazz.getAnnotation(RequestMapping.class); if (classAnnotation != null) &#123; String[] classValue = classAnnotation.value(); //2.获取方法上的@RequestMapping(xxx) RequestMapping methodAnnotation = method.getAnnotation(RequestMapping.class); if (methodAnnotation != null) &#123; String[] methodValue = methodAnnotation.value(); url = classValue[0] + methodValue[0]; //获取访问的ip String ip = request.getRemoteAddr(); //获取当前操作的用户 //从上下文中获了当前登录的用户 SecurityContext context = SecurityContextHolder.getContext(); User user = (User) context.getAuthentication().getPrincipal(); String username = user.getUsername(); //将日志相关信息封装到SysLog对象 SysLogs sysLog = new SysLogs(); //执行时长 sysLog.setExecutionTime(time); sysLog.setIp(ip); sysLog.setMethod(\"[类名] \" + clazz.getName() + \"[方法名] \" + method.getName()); sysLog.setUrl(url); sysLog.setUsername(username); sysLog.setVisitTime(visitTime); //调用Service完成操作 sysLogService.save(sysLog); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"框架","slug":"框架","permalink":"https://wangdaye7.github.io/tags/框架/"}]},{"title":"SpringSecurity使用记录","slug":"allTemp/SpringSecurity使用记录","date":"2019-03-19T19:51:21.000Z","updated":"2019-09-15T15:49:31.884Z","comments":true,"path":"2019/03/20/allTemp/SpringSecurity使用记录/","link":"","permalink":"https://wangdaye7.github.io/2019/03/20/allTemp/SpringSecurity使用记录/","excerpt":"","text":"##理解(待完成)当完成配置后, 对权限的控制就完全交给springsecurity管理了, 不需要再用controller进行控制了配置access的角色时, 需要加上前缀ROLE_ 使用记录SimpleGrantedAuthority 用于new User() 对象时作为参数传递进去, 我的理解是一个简单的授权信息集合, 传递的类型为List集合 123456789101112131415161718192021222324//在service中的编写//此处的&#123;noop&#125;需要加上, 因为使用的是明文public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserInfo userInfo = null; try &#123; userInfo = userDao.findByUsername(username); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //处理自己的用户对象封装成UserDetails 此处的User为框架提供的类, 而为了避免冲突 将自己的User类更名为Users // User user=new User(userInfo.getUsername(),\"&#123;noop&#125;\"+userInfo.getPassword(),getAuthority(userInfo.getRoles())); User user = new User(userInfo.getUsername(), \"&#123;noop&#125;\" + userInfo.getPassword(), userInfo.getStatus() == 0 ? false : true, true, true, true, getAuthority(userInfo.getRoles())); return user;&#125;//作用就是返回一个List集合，集合中装入的是角色描述public List&lt;SimpleGrantedAuthority&gt; getAuthority(List&lt;Role&gt; roles) &#123; List&lt;SimpleGrantedAuthority&gt; list = new ArrayList&lt;&gt;(); for (Role role : roles) &#123; //需要加上前缀ROLE_ 对应spring-security.xml中的配置 list.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getRoleName())); &#125; return list;&#125; 对密码进行加密 在spring-security.xml配置PasswordEncoder对象 123456789&lt;!-- 切换成数据库中的用户名和密码 --&gt;&lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref=\"userService\"&gt; &lt;!-- 配置加密的方式--&gt; &lt;security:password-encoder ref=\"passwordEncoder\"/&gt; &lt;/security:authentication-provider&gt;&lt;/security:authentication-manager&gt;&lt;!-- 配置加密类 --&gt;&lt;bean id=\"passwordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"/&gt; 保存用户时对用户的加密在service中进行 12345public void save(Users user) &#123; //对存入的密码进行加密 user.setPassword(passwordEncoder.encode(user.getPassword())); userDao.save(user);&#125; security中的验证就不需要在密码前添加”{noop}”了 服务器端方法级权限控制Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解，这三种注解默认都是没有启用的，需要单独通过global-method-security元素的对应属性进行启用其中JSR-250可以省略前缀ROLE_ 而Secured不可以12345678//配置文件&lt;security:global-method-security jsr250-annotations=\"enabled\"/&gt;&lt;security:global-method-security secured-annotations=\"enabled\"/&gt;&lt;security:global-method-security pre-post-annotations=\"disabled\"/&gt;//注解开启@EnableGlobalMethodSecurity ：Spring Security默认是禁用注解的，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为Bean。 JSR-250注解需要先添加依赖: 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;@RolesAllowed表示访问对应方法时所应该具有的角色示例：@RolesAllowed(&#123;\"USER\", \"ADMIN\"&#125;) 该方法只要具有\"USER\", \"ADMIN\"任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN@PermitAll表示允许所有的角色进行访问，也就是说不进行权限控制@DenyAll是和PermitAll相反的，表示无论什么角色都不能访问 支持表达式的注解 123456789101112示例：@PreAuthorize(\"#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)\")void changePassword(@P(\"userId\") long userId )&#123; &#125;这里表示在changePassword方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该方法。@PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常示例：@PostAuthorizeUser getUser(\"returnObject.userId == authentication.principal.userId orhasPermission(returnObject, 'ADMIN')\");@PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果@PreFilter 允许方法调用,但必须在进入方法之前过滤输入值 @Secured注解 12345@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。示例：@Secured(\"IS_AUTHENTICATED_ANONYMOUSLY\")public Account readAccount(Long id);@Secured(\"ROLE_TELLER\") 遇到的问题无法进行权限控制, 用注解进行配置后还是所有人都可以访问, 查阅后发现将将注解从controller层移动到service可以解决 解决的方法 将配置文件: 123&lt;security:global-method-security jsr250-annotations=\"enabled\"/&gt;&lt;security:global-method-security secured-annotations=\"enabled\"/&gt;&lt;security:global-method-security pre-post-annotations=\"disabled\"/&gt; 放入spring-mvc文件中配置, 而此时不能自动导入命名空间约束, 导入的话运行会报异常手动添加 1234xmlns:security=\"http://www.springframework.org/schema/security\"http://www.springframework.org/schema/securityhttp://www.springframework.org/schema/security/spring-security.xsd 到相应的位置 页面端标签控制权限 在jsp页面中可以使用spring security提供的权限标签来进行权限控制 maven导入 12345&lt;dependency&gt;&lt;groupId&gt;org.springframework.security&lt;/groupId&gt;&lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt;&lt;version&gt;version&lt;/version&gt;&lt;/dependency&gt; 页面导入 1&lt;%@taglib uri=\"http://www.springframework.org/security/tags\" prefix=\"security\"%&gt; 注意的问题 在jsp页面中使用了SPEL表达式, 需要在spring-security.xml 开启SPEL表达式支持 或者配置一个bean 1&lt;bean id=\"webexpressionHandler\" class=\"org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler\" /&gt; 常用标签 123456789101112131415161718191. authorizeauthorize是用来判断普通权限的，通过判断用户是否具有对应的权限而控制其所包含内容的显示&lt;security:authorize access=\"\" method=\"\" url=\"\" var=\"\"&gt;&lt;/security:authorize&gt;&lt;security:authorize access=\"hasRole('ADMIN')\" &gt;&lt;/security:authorize&gt; //只有ADMIN用户才能访问access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限method：method属性是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法url：url表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中2. authentication&lt;security:authentication property=\"\" htmlEscape=\"\" scope=\"\" var=\"\"/&gt;property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取，如“principle.username”，不允许直接通过方法进行调用htmlEscape：表示是否需要将html进行转义。默认为true。scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥有的作用范围都进行进行指定var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中 使用前的准备步骤 导入依赖 123456789101112131415&lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt;&lt;/properties&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; web.xml添加 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;!-- 配置加载类路径的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml,classpath*:spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置监听器，监听request域对象的创建和销毁的 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 核心文件spring-security.xml文件 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:security=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\"&gt; &lt;!-- 配置不拦截的资源 --&gt; &lt;security:http pattern=\"/login.jsp\" security=\"none\"/&gt; &lt;security:http pattern=\"/failer.jsp\" security=\"none\"/&gt; &lt;security:http pattern=\"/css/**\" security=\"none\"/&gt; &lt;security:http pattern=\"/img/**\" security=\"none\"/&gt; &lt;security:http pattern=\"/plugins/**\" security=\"none\"/&gt; &lt;!-- 配置具体的规则 auto-config=\"true\" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions=\"false\" 是否使用SPEL表达式（没学习过） --&gt; &lt;security:http auto-config=\"true\" use-expressions=\"false\"&gt; &lt;!-- 配置具体的拦截的规则 pattern=\"请求路径的规则\" access=\"访问系统的人，必须有ROLE_USER的角色\" --&gt; &lt;security:intercept-url pattern=\"/**\" access=\"ROLE_USER,ROLE_ADMIN\"/&gt; &lt;!-- 定义跳转的具体的页面 --&gt; &lt;security:form-login login-page=\"/login.jsp\" login-processing-url=\"/login.do\" default-target-url=\"/index.jsp\" authentication-failure-url=\"/failer.jsp\" authentication-success-forward-url=\"/pages/main.jsp\" /&gt; &lt;!-- 关闭跨域请求 --&gt; &lt;security:csrf disabled=\"true\"/&gt; &lt;!-- 退出 --&gt; &lt;security:logout invalidate-session=\"true\" logout-url=\"/logout.do\" logout-success-url=\"/login.jsp\" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref=\"userService\"&gt; &lt;!-- 配置加密的方式 &lt;security:password-encoder ref=\"passwordEncoder\"/&gt;--&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密类 --&gt; &lt;bean id=\"passwordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"/&gt; &lt;!-- 提供了入门的方式，在内存中存入用户名和密码 &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name=\"admin\" password=\"&#123;noop&#125;admin\" authorities=\"ROLE_USER\"/&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; --&gt;&lt;/beans&gt; UserService需要继承类UserDetailsService 123456789public interface UserService extends UserDetailsService &#123; List&lt;Users&gt; findAll() throws Exception; void save(Users user); Users findById(String id); void addRoleToUser(String userId, String[] ids);&#125; 不经过数据库时: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:security=\"http://www.springframework.org/schema/security\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd\"&gt; &lt;!-- 配置不过滤的资源（静态资源及登录相关） --&gt; &lt;security:http security=\"none\" pattern=\"/login.html\" /&gt; &lt;security:http security=\"none\" pattern=\"/failer.html\" /&gt; &lt;security:http auto-config=\"true\" use-expressions=\"false\" &gt; &lt;!-- 配置资料连接，表示任意路径都需要ROLE_USER权限 --&gt; &lt;security:intercept-url pattern=\"/**\" access=\"ROLE_USER\" /&gt; &lt;!-- 自定义登陆页面，login-page 自定义登陆页面 authentication-failure-url 用户权限校验失败之后才会跳转到这个页面，如果数据库中没有这个用户则不会跳转到这个页面。 default-target-url 登陆成功后跳转的页面。 注：登陆页面用户名固定 username，密码 password，action:login --&gt; &lt;security:form-login login-page=\"/login.html\" login-processing-url=\"/login\" username-parameter=\"username\" password-parameter=\"password\" authentication-failure-url=\"/failer.html\" default-target-url=\"/success.html\" /&gt; &lt;!-- 登出， invalidate-session 是否删除session logout-url：登出处理链接 logout-success-url：登出成功页面 注：登出操作 只需要链接到 logout即可登出当前用户 --&gt; &lt;security:logout invalidate-session=\"true\" logout-url=\"/logout\" logout-success-url=\"/login.jsp\" /&gt; &lt;!-- 关闭CSRF,默认是开启的 --&gt; &lt;security:csrf disabled=\"true\" /&gt; &lt;/security:http&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name=\"user\" password=\"&#123;noop&#125;user\" authorities=\"ROLE_USER\" /&gt; &lt;security:user name=\"admin\" password=\"&#123;noop&#125;admin\" authorities=\"ROLE_ADMIN\" /&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt;&lt;/beans&gt;","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/tags/ssm/"},{"name":"框架","slug":"框架","permalink":"https://wangdaye7.github.io/tags/框架/"}]},{"title":"howToSpeakEnglishWell","slug":"allTemp/howToSpeakEnglishWell","date":"2019-03-17T22:53:12.000Z","updated":"2019-06-23T02:23:15.775Z","comments":true,"path":"2019/03/18/allTemp/howToSpeakEnglishWell/","link":"","permalink":"https://wangdaye7.github.io/2019/03/18/allTemp/howToSpeakEnglishWell/","excerpt":"","text":"常用英语口语会话first daylinks to youtube Hi. Could you help me, please? 您能帮我个忙么？ I’m lost. 我迷路了。 Go straight and then turn left! 直走然后左转。 I’m trying to get to the mall. 我想去购物商城。 Do you know where I can find a shoe store? 请问鞋店在哪? This way. 这边走（也可以表示礼让的时候这边请） How much is it? 这个多少钱？ Can you do any better? 你能给个更好的价钱么？ How about ten dollars? / Would you take ten dollars? 十块钱怎么样？ If I took two, would you give me a discount? 我要是买两件的话，你能给打个折么？ Do you have this shirt in a small? 这件衬衫有小号的么？ Can you break this bill for me, please? 请问能帮我换成零钱么？ Two fives and a ten please. 两个五块和一个十块。 Where can I pay? 在哪交钱。 Here you are. 给你。 Could I ask you a question? 我能问你一个问题么？ Do you have a moment/minute? 你现在有空么？ Do you have any siblings? 你有兄弟姐妹么？ Do you have any brothers or sisters? 你有兄弟姐妹么？ I’m an only child. 我是独生子女 How old is your kid/child? 你的孩子多大了？ How are the kids? 孩子们怎样？ They grow so fast ! 他们长的真快啊。 How’s the family? 家人们还好么？ Long time, no see! 好久不见（中式表达方式） What’s new? 生活有什么变化么？ Are you still working at the bank? 你还在银行上班么？ It’s a nice day! 今天天气真不错。 （陌生人之间的万能开头语） I like your dress 我喜欢你的裙子 （面对夸奖，礼貌回应 Thank you） Your daughter is so beautiful! 你的女儿真漂亮！ Your baby is so cute !! 你的宝宝真可爱 （婴儿一般用cute） What’s your baby’s name? 你的宝宝叫什么名字？ Your garden’s so beautiful! 你的花园真好看。 What would you like for dinner? 晚餐你想吃些什么？ Dumplings 饺子 Sounds great ! 听起来真不错！ My treat. 我请客。 Help yourself. 请随意。 After you. 您先请。（一般乘坐电梯或是礼让的时候） I look forward to seeing you again. 希望再次见到你 / 期待与你的再次会面。 （用seeing 是为了搭配 look forward。 回答的时候可以直接用：Me too.） Are you ok? 你没事吧？ I feel sick. / I am sick. 我感觉不舒服 / 我病了 （前一种表示主观的感受，后一种表示已经确定自己病了）。 What should I do? 我该怎么办？ Do you want to go to the hospital ? 你要不要去医院呢？ Are you hurt ? 你受伤了么？ （hurt 不只可以指生理方面，也可以指心理方面： I feel hurt.） Don’t worry. 不要担心。 Calm down. 冷静点。 I see！ 我明白了！ （别人说了一些是事情，你突然明白了） I didn’t mean it . 我不是故意的。 Never mind. 不要紧的，没关系的。 第四天link to youtube What brings you here today？ 什么风把你吹来了 What’s the matter? My knees hurt. My knees are in pain. It’s painful to watch that. 我的膝盖很疼, 不能直接说my knees are painful. 使用painful要用不定式. How long has it been? About/Roughly three weeks. 有多长时间了? You should’ve come earlier. It didn’t bother me much before. 你应该早点来, 之前疼的不是很厉害. Have a seat. Let me examine it. It’s nothing serious. 请坐, 让我检查一下, 不是很严重 Are you serious? I’m serious. Why are you so serious? 你是认真的吗？ 你怎么这么严肃， 放不开 Try these exercises. Exercise every day. I mean it. I didn’t mean it. Could you refer me to a specialist? You don’t need one. You’ll be fine. It’s just a matter of time. 只是时间的问题 I recommend you see a physiotherapist. I feel he did a good job. He said I have a very good/positive attitude. He has an attitude. 这里的attitude本身就有消极/不好态度的意思, 所以不用加negative Don’t give me attitude. I recovered very fast. I thanked him for everything. Is the tax included in the price? It’s eighty dollars plus tax. Do you want a receipt? How do you like your doctor? He’s always on time. I can’t believe it. He’s always in a rush. What’s the rush? I wouldn’t recommend him.","categories":[{"name":"英语","slug":"英语","permalink":"https://wangdaye7.github.io/categories/英语/"}],"tags":[{"name":"口语","slug":"口语","permalink":"https://wangdaye7.github.io/tags/口语/"}]},{"title":"LeetCode记录","slug":"note/algorithm/LeetCode记录","date":"2019-03-17T12:46:21.000Z","updated":"2019-09-08T14:22:03.578Z","comments":true,"path":"2019/03/17/note/algorithm/LeetCode记录/","link":"","permalink":"https://wangdaye7.github.io/2019/03/17/note/algorithm/LeetCode记录/","excerpt":"","text":"leetCode清单解答HashMap相关 两数之和 题目:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路从0开始遍历nums数组, 使用hashmap存放期望的值(target-nums[i])和索引值(i), 判断当前nums[i]是否是前面的需要的期望值, 如果是, 则代表找到了, 不是则继续下一次 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; ans = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(ans.containsKey(nums[i]))&#123; return new int[]&#123;ans.get(nums[i]), i&#125;; &#125; ans.put(target - nums[i], i); &#125; return null; &#125;&#125; 和为k的子数组 题目给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。示例 1 :输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 思路建立map表用于存储每个连续子数组sum求和出现的次数，初始化为（0,1），表示和为0的连续子数组出现1次。 sum的值是在对nums数组的循环中不断累加当前元素的，res的值则需要查找map中是否已存在sum-k的元素，也就是在查找此前所有从0项开始累加的连续子项和中有没有sum-k。 如果有的话，则说明从该项到当前项的连续子数组和必定为k，那么res则可以和这个sum的对应值，即这个sum出现的次数，相加得到新的res。 对于当前sum如果已存在与map中则其对应值+1，不存在则添加新项，初始值为1。 123456789101112131415161718class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); int res = 0; int sum = 0; for(int i = 0; i &lt; nums.length; i++)&#123; sum += nums[i]; //如果k = 13 而此时sum = 20, 所以sum - k = 7, 查看是否有出现过7, 如果有则代表从该项到当前项的连续子数组和为13, 将出现过的次数加到结果 if(map.containsKey(sum - k))&#123; res += map.get(sum - k); &#125; //因为这是一个包含负数的数组, 所有存在和为20的情况有很多种, 需要处理 map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return res; &#125;&#125; ListNode相关 两数相加 题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 12345678910111213141516171819202122232425262728class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //定义一个进位标志 int flag = 0; ListNode p1 = l1; ListNode p2 = l2; ListNode res = new ListNode(-1); ListNode cur = res; while(p1 != null || p2 != null)&#123; int x = (p1 != null) ? p1.val : 0; int y = (p2 != null) ? p2.val : 0; int sum = x + y + flag; flag = sum / 10; cur.next = new ListNode(sum % 10); cur = cur.next; if(p1 != null)&#123; p1 = p1.next; &#125; if(p2 != null)&#123; p2 = p2.next; &#125; &#125; if(flag &gt; 0)&#123; cur.next = new ListNode(flag); &#125; return res.next; &#125;&#125; 两数相加2 -题目 给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 进阶: 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 示例: 输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 8 -&gt; 0 -&gt; 7 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;(); while(l1 != null || l2 != null)&#123; if(l1 != null)&#123; s1.push(l1.val); l1 = l1.next; &#125; if(l2 != null)&#123; s2.push(l2.val); l2 = l2.next; &#125; &#125; int flag = 0; ListNode head = null; ListNode temp = null; while(!s1.empty() || !s2.empty())&#123; int x = (!s1.empty()) ? s1.pop() : 0; int y = (!s2.empty()) ? s2.pop() : 0; int sum = x + y + flag; ListNode node = new ListNode(sum % 10); temp = head; head = node; head.next = temp; head = node; flag = sum / 10; &#125; if(flag &gt; 0)&#123; temp = head; head = new ListNode(1); head.next = temp; &#125; return head; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/tags/算法/"}]},{"title":"mybatis使用记录","slug":"allTemp/mybatis使用记录","date":"2019-03-17T12:46:21.000Z","updated":"2019-09-15T15:49:51.835Z","comments":true,"path":"2019/03/17/allTemp/mybatis使用记录/","link":"","permalink":"https://wangdaye7.github.io/2019/03/17/allTemp/mybatis使用记录/","excerpt":"","text":"注解中的使用当结果对象中的属性与表中的数据 类型不一致时(表中存放的是外键 引用其他表中的id, 而结果集对象中存放的是根据这个id对应的对象)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 查询所有订单信息, 其中根据产品id又查询产品, 并将产品一并封装到结果集中了. 相当于两次查询 * @return * @throws Exception */@Select(\"select * from orders\") @Results(&#123; @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"orderNum\", property = \"orderNum\"), @Result(column = \"orderTime\", property = \"orderTime\"), @Result(column = \"orderStatus\", property = \"orderStatus\"), @Result(column = \"peopleCount\", property = \"peopleCount\"), @Result(column = \"payType\", property = \"payType\"), @Result(column = \"orderDesc\", property = \"orderDesc\"), @Result(column = \"peopleCount\", property = \"peopleCount\"), // 表中存放的为外键, 引用产品id, 但是要将这个id重新映射为结果集中对应的类型product 需要进行第二次查询并封装@One适用于一对一映射 @Many为多对多 //其中的select为相应dao的全限定类名, 可以用JavaType指定内部查询的返回类型 @Result(column = \"productId\", property = \"product\", one = @One( select = \"jhmarryme.dao.ProductDao.findById\" )), &#125;) public List&lt;Orders&gt; findAll() throws Exception; /** * 根据id查找订单 * @param id * @return */ @Select(\"select * from orders where id in (select orderId from order_traveller where orderId = #&#123;id&#125;)\") @Results(&#123; @Result(id = true, column = \"id\", property = \"id\"), @Result(column = \"orderTime\", property = \"orderTime\"), @Result(column = \"orderNum\", property = \"orderNum\"), @Result(column = \"orderStatus\", property = \"orderStatus\"), @Result(column = \"peopleCount\", property = \"peopleCount\"), @Result(column = \"payType\", property = \"payType\"), @Result(column = \"orderDesc\", property = \"orderDesc\"), @Result(column = \"productId\", property = \"product\", one = @One( select = \"jhmarryme.dao.ProductDao.findById\" )), @Result(column = \"memberId\", property = \"member\", one = @One( select = \"jhmarryme.dao.MemberDao.findById\" )), //此处当返回值为list集合的时候, 如果要写JavaType值必须是List.class 不是查找的类.class, 可以不写 @Result(column = \"id\", property = \"travellers\", many = @Many( select = \"jhmarryme.dao.TravellerDao.findByOrdersId\" )) &#125;) public Orders findById(String id); 复习SQL语法 left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录 inner join(等值连接) 只返回两个表中联结字段相等的行 pageHelper插件的使用在调用service时使用插件, 当controller收到了返回的参数result时, 使用new PageInfo(result) 将此bean传到jsp页面, 这个就是分页的bean, 具体属性查看该对象git中文文档123456789101112131415161718192021222324252627282930313233343536373839404142434445//applicationContext.xml中&lt;!-- 把交给IOC管理 SqlSessionFactory --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt;&lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;!-- 传入PageHelper的插件 --&gt;&lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;!-- 传入插件的对象 --&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"helperDialect\"&gt;mysql&lt;/prop&gt; &lt;prop key=\"reasonable\"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt;&lt;/property&gt;&lt;/bean&gt;//controller中@Autowired private OrdersService ordersService; @RequestMapping(\"/findAll.do\") public ModelAndView findAll(@RequestParam(name = \"page\", required = true, defaultValue = \"1\") Integer page, @RequestParam(name = \"size\", required = true, defaultValue = \"4\") Integer size) throws Exception &#123; ModelAndView view = new ModelAndView(); List&lt;Orders&gt; ordersList = ordersService.findAll(page, size); //插件提供的分页Bean对象 PageInfo pageInfo = new PageInfo(ordersList); view.addObject(\"pageInfo\", pageInfo); System.out.println(ordersList); for (Orders order : ordersList)&#123; System.out.println(order); &#125; view.setViewName(\"orders-list\"); return view; &#125;//service中public List&lt;Orders&gt; findAll(int page, int size) throws Exception &#123; //使用分页插件 PageHelper.startPage(page, size); return ordersDao.findAll(); &#125; 主键操作 使用UUID作为主键 1@Insert(\"insert into users(id) values(REPLACE(UUID(),'-', '')) 插入数据时返回自增的主键 123@Insert(\"insert into tbl_user (name, age) values (#&#123;name&#125;, #&#123;age&#125;)\")@Options(useGeneratedKeys=true, keyProperty=\"userId\", keyColumn=\"id\")void insertUser(User user); 当两个参数都为一般类型时, 需要进行参数的声明1void addRoleToUser(@Param(\"userId\") String userId, @Param(\"roleId\") String id);","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/tags/ssm/"},{"name":"框架","slug":"框架","permalink":"https://wangdaye7.github.io/tags/框架/"},{"name":"Spring","slug":"Spring","permalink":"https://wangdaye7.github.io/tags/Spring/"}]},{"title":"ssm权限管理学习","slug":"allTemp/权限管理","date":"2019-03-17T12:46:21.000Z","updated":"2019-09-15T15:50:23.820Z","comments":true,"path":"2019/03/17/allTemp/权限管理/","link":"","permalink":"https://wangdaye7.github.io/2019/03/17/allTemp/权限管理/","excerpt":"","text":"遇到的问题 不能创建表 error:150 引用的外键类型定义有误, 与其他表中的不符 表名用包裹 由于spring不能自动进行date类型的数据格式注入所以:存入日期型数据时, 需要使用@DateTimeFormat注解, 在实体类的类型中加上此注解, 可以自动进行日期型的数据格式注入 12@DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date departureTime; // 出发时间 另一种方案, (待确认效果)1234@InitBinderpublic void initBinder(WebDataBinder binder) &#123;binder.registerCustomEditor(Date.class, new MyDateEdit(\"yyyy-MM-dd HH:mm\"));&#125; 实现分页功能通过pageHelper实现, 具体用法写在了Mybatis使用记录里 使用SpringSecurity实现的登陆验证控制, 存入密码时进行加密.具体用法写在了SpringSecurity使用记录里 对mybatis的一些用法的接触对Results封装数据, 其中@One 和 @Many分别用来在结果集中嵌套注入一个数据和一个List集合, 在Mybatis使用记录里记录了一些用法 通过简单的自制日期转换工具实现 日期型和date类型相互转换因为在实体类中没有直接使用date类型的数据作为展示, 而是定义了一个相应的时间str作为显示用, 所以需要进行转换 123456789101112131415161718192021222324252627public class DateUtils &#123; /** * 将日期转换为字符串 * @param date * @param patt * @return */ public static String dateToString(Date date, String patt)&#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(patt); String format = simpleDateFormat.format(date); return format; &#125; /** * 将字符串转换为日期 * @param str * @param patt * @return * @throws ParseException */ public static Date StringToDate(String str, String patt) throws ParseException &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(patt); Date parse = simpleDateFormat.parse(str); return parse; &#125;&#125; 权限管理相关","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/tags/ssm/"},{"name":"框架","slug":"框架","permalink":"https://wangdaye7.github.io/tags/框架/"},{"name":"Spring","slug":"Spring","permalink":"https://wangdaye7.github.io/tags/Spring/"}]},{"title":"牛客笔记积累","slug":"allTemp/牛客笔记积累","date":"2019-03-11T15:44:21.000Z","updated":"2019-07-09T03:39:05.077Z","comments":true,"path":"2019/03/11/allTemp/牛客笔记积累/","link":"","permalink":"https://wangdaye7.github.io/2019/03/11/allTemp/牛客笔记积累/","excerpt":"","text":"牛客笔记day1 AOP 和 OOP的区别 面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。 面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。 后缀 .class：编译后的Java文件 ； .java：是未编译的Java程序； .jsp：是Java 服务器页面技术，支持Java代码的动态网页； .xml：可拓展文本标记语言，一种文本格式，常用来做配置文件； .jar：一种压缩包格式，常用来打包 Java 类库。 Math方法Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11. 一条进程的栈区、堆区、数据区和代码区在内存中的映射参考 jdbc 1.Statement对象用于执行不带参数的简单SQL语句。 2.Prepared Statement 对象用于执行预编译SQL语句。 3.Callable Statement对象用于执行对存储过程的调用。 static被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以static不能修饰局部变量 程序编译 1..java编译成的是字节码，再被各系统的jvm翻译成本系统可以识别的机器码，这就是java一次编程多平台应用的跨平台性 java源文件生成的是class文件，与系统无关 字节码和机器码不是一回事 java程序在运行时字节码才会被jvm翻译成机器码，所以说java是解释性语言 java编译出来的目标文件，需要在合适版本的jvm上运行 无参构造器不可缺少在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。 运算时的规则 所有的byte,short,char型的值将被提升为int型； 如果有一个操作数是long型，计算结果是long型； 如果有一个操作数是float型，计算结果是float型； 如果有一个操作数是double型，计算结果是double型 final修饰的变量不会自动提升类型 当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法体时新建一个接口，然后一个类implements这个接口，并且不能为任何抽象方法提供任何细节或方法体时，这个类必须是抽象类，并override的所有方法。然后再建一个普通类extends这个抽象类，就可以为所欲为了 。这种情况就是java设计模式中的适配器模式。 Servlet与JSP九大内置对象的关系out-&gt;response.getWriterrequest -&gt;Service方法中的req参数response -&gt;Service方法中的resp参数session -&gt;request.getSessionapplication -&gt;getServletContextexception -&gt;Throwablepage -&gt;thispageContext -&gt;PageContextConfig -&gt;getServletConfig","categories":[{"name":"面试准备","slug":"面试准备","permalink":"https://wangdaye7.github.io/categories/面试准备/"}],"tags":[{"name":"积累","slug":"积累","permalink":"https://wangdaye7.github.io/tags/积累/"}]},{"title":"ssm整合","slug":"allTemp/ssm整合","date":"2019-03-06T16:22:07.000Z","updated":"2019-09-15T15:49:26.855Z","comments":true,"path":"2019/03/07/allTemp/ssm整合/","link":"","permalink":"https://wangdaye7.github.io/2019/03/07/allTemp/ssm整合/","excerpt":"","text":"独立搭建第一次 工程环境搭建 创建maven工程, 选择webapp模板, 导入坐标, 完善项目目录结构 Spring配置 导入常用约束 开启注解扫描, 配置哪些要扫描的包 编写测试类 测试Spring能否独立运行 springMVC配置 web.xml配置核心控制器 核心控制器 中文乱码过滤器 过滤静态资源 springmvc.xml配置 导入常用约束 配置注解扫描 只扫描web层 配置视图解析器 配置解析的目录和文件类型 开启mvc注解支持 配置Tomcat 整合Spring和springmvc核心目的就是为了在controller中调用service层方法,要让服务器能加载到Spring的配置文件 web.xml中配置一个监听器, 在启动服务时创建一个容器(默认只能加载WEB-INF下的配置文件) 需要手动只能Spring配置文件位置 测试Controller中调用service方法 搭建和测试mybatis 配置文件的编写 配置数据源 配置包的路径, 如果是XML方式配置dao需要加载xml dao层使用注解配置 测试mybatis 整合mybatis和Spring把 mybatis 配置文件（SqlMapConfig.xml）中内容配置到 spring 配置文件中 配置数据源 配置sqlSession工厂 配置要扫描的dao包 配置Spring事务管理器 配置事务管理器 配置事务通知(作用的方法) 配置AOP 配置AOP切入点 配置事务通知与切入点的关系 有需要的话开启注解支持 由于配置了事务, 一定要在Springmvc的配置文件中排除扫描service, 不然没有事务处理能力问题总结1 . 控制台提示log4j找不到12log4j:WARN No appenders could be found for logger (org.springframework.core.env.StandardEnvironment).log4j:WARN Please initialize the log4j system properly. 导入配置文件即可 控制台输出语句乱码configurations中的VM options里加上-Dfile.encoding=UTF-8 在Springmvc+mybatis中事务不回滚Spring容器优先加载,是父容器，而SpringMVC产生的是子容器。子容器Controller进行扫描装配时装配的@Service注解的实例是没有经过事务加强处理，即没有事务处理能力的Service，而父容器进行初始化的Service是保证事务的增强处理能力的。如果不在子容器中将Service exclude掉，此时得到的将是原样的无事务处理能力的Service，因为在多上下文的情况下，如果同一个bean被定义两次，后面一个优先。 数据库查询中文乱码在url后面加上?useUnicode=true&amp;characterEncoding=UTF-8指定编码集 修改代码后没有效果, maven重新clean-&gt;install一下","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/tags/ssm/"},{"name":"框架","slug":"框架","permalink":"https://wangdaye7.github.io/tags/框架/"}]},{"title":"SpringMVC记录","slug":"allTemp/SpringMVC记录","date":"2019-03-06T15:33:12.000Z","updated":"2019-09-15T15:49:35.905Z","comments":true,"path":"2019/03/06/allTemp/SpringMVC记录/","link":"","permalink":"https://wangdaye7.github.io/2019/03/06/allTemp/SpringMVC记录/","excerpt":"","text":"遇到的问题 使用$.post方法发送请求, controller接收时出现415错误 原因是controller中使用了@RequestBody注解接收参数, 需要删掉, 如果使用$.ajax则不会出现此异常 使用$.get方法发送请求, controller接收时出现400错误 原因同上 return “rediect:findAll.do”; //controller中的返回值, 重定向","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/tags/ssm/"},{"name":"框架","slug":"框架","permalink":"https://wangdaye7.github.io/tags/框架/"}]},{"title":"mybatis入门","slug":"allTemp/mybatis入门","date":"2019-03-03T19:35:16.000Z","updated":"2019-09-15T15:49:57.862Z","comments":true,"path":"2019/03/04/allTemp/mybatis入门/","link":"","permalink":"https://wangdaye7.github.io/2019/03/04/allTemp/mybatis入门/","excerpt":"","text":"day1mybatis的理解使用mybatis的步骤主要按照这个步骤来做, 在其中具体配置文件的编写中, 参考mybatis中文网的内容填写, 注意其中的一些细节, 顺利完成. 在配置SqlMapConfig.xml中的properties属性时, 使用resource标签外部引用.properties文件.第一步：创建 maven 工程第二步：导入坐标第三步：编写必要代码（实体类和持久层接口）第四步：编写 SqlMapConfig.xml 123456789101112131415161718192021222324252627282930&lt;? xml version = \"1.0\" encoding = \"UTF-8\" ?&gt;&lt; !DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\" &gt; &lt;configuration&gt; &lt;properties resource=\"jdbcConfig.properties\" /&gt; &lt;typeAliases&gt; &lt;!--&lt;typeAlias type=\"jhmarryme.domain.User\" alias=\"user\" /&gt;--&gt; &lt;package name=\"jhmarryme.domain\" /&gt; &lt;/typeAliases&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=\"jhmarryme.dao\" /&gt; &lt;!--&lt;mapper resource=\"jhmarryme/dao/IUserDao.xml\" /&gt;--&gt; &lt;/mappers&gt; &lt;/configuration&gt; 第五步：编写映射配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"jhmarryme.dao.IUserDao\"&gt; &lt;!-- 查找所有用户信息--&gt; &lt;select id=\"findAllUser\" resultType=\"jhmarryme.domain.User\"&gt; select * from user&lt;/select&gt;&lt;!--查询总用户数--&gt; &lt;select id=\"findTotalUser\" resultType=\"int\"&gt; select count(id) from user&lt;/select&gt; &lt;!--保存一个用户, 并返回表中自增的id--&gt; &lt;insert id=\"saveUser\" parameterType=\"jhmarryme.domain.User\"&gt; &lt;selectKey keyProperty=\"id\" keyColumn=\"id\" resultType=\"int\"&gt; select last_insert_id(); &lt;/selectKey&gt; insert into user(username, address, birthday, sex) values(#&#123;username&#125;, #&#123;address&#125;, #&#123;birthday&#125;, #&#123;sex&#125;) &lt;/insert&gt; &lt;!-- 根据条件查询相关的用户 --&gt; &lt;select id=\"findUserByCondition\" resultType=\"user\" parameterType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"username != null\"&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;if test=\"address != null\"&gt; and address like #&#123;address&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;!--查询id在集合中的用户--&gt; &lt;select id=\"findUserInIds\" parameterType=\"pojovo\" resultType=\"user\"&gt; select * from user &lt;where&gt; &lt;if test=\"ids != null and ids.size() &gt;0\"&gt; &lt;foreach collection=\"ids\" open=\"and id in(\" close=\")\" item=\"id\" separator=\",\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 第六步：编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class MyBatisTest &#123; SqlSessionFactory sqlSessionFactory; SqlSession session; IUserDao userDao; @Before public void init() &#123; String resource = \"SqlMapConfig.xml\"; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); session = sqlSessionFactory.openSession(); try &#123; userDao = session.getMapper(IUserDao.class); &#125; finally &#123; &#125; &#125; /** * 测试查找总用户 */ @Test public void testFindAll()&#123; List&lt;User&gt; users = userDao.findAllUser(); for (User user: users ) &#123; System.out.println(user); &#125; &#125; /** * 测试查找总用户数 */ @Test public void testTotalUser()&#123; int totalUser = userDao.findTotalUser(); System.out.println(totalUser); &#125; @Test public void testSaveUser()&#123; User user = new User(); user.setUsername(\"江航12\"); user.setBirthday(new Date()); user.setAddress(\"北碚\"); user.setSex(\"女\"); System.out.println(user); userDao.saveUser(user); System.out.println(user); session.commit(); &#125; @Test public void testUpdateUser()&#123; &#125; @Test public void testFindUserByCondition()&#123; User user = new User(); user.setUsername(\"%王%\"); user.setAddress(\"%金燕龙%\"); List&lt;User&gt; users = userDao.findUserByCondition(user); for (User u: users)&#123; System.out.println(u); &#125; &#125; /** * 查询id在集合中的所有用户信息 */ @Test public void testFindInIds()&#123; List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(50); ids.add(41); PojoVo vo = new PojoVo(); vo.setIds(ids); List&lt;User&gt; users = userDao.findUserInIds(vo); for (User u: users)&#123; System.out.println(u); &#125; &#125;&#125; Mybatis基本用法记录遇到的问题 导入坐标时没有mybatis的提示, 第一反应肯定是仓库里找不到这个包, 打开设置, 找到maven的设置, 发现maven使用的是默认的版本, 于是乎更换之前下载的版本, 其中配置好了本地仓库的位置. 问题解决 补充 SqlMapConfig.xml 中配置的内容和顺序 1234567891011121314151617-properties（属性） --property-settings（全局配置参数） --setting-typeAliases（类型别名） --typeAliase --package-typeHandlers（类型处理器）-objectFactory（对象工厂）-plugins（插件）-environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源）-mappers（映射器） --mapper --package jdbcConfig.properties如下: 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ee42jdbc.username=rootjdbc.password=1234 pagehelper插件的使用使用步骤","categories":[{"name":"ssm","slug":"ssm","permalink":"https://wangdaye7.github.io/categories/ssm/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"mybatis","slug":"mybatis","permalink":"https://wangdaye7.github.io/tags/mybatis/"},{"name":"web框架","slug":"web框架","permalink":"https://wangdaye7.github.io/tags/web框架/"}]},{"title":"hexo使用记录","slug":"allTemp/hexo使用记录","date":"2019-02-26T23:43:53.000Z","updated":"2019-06-19T11:12:56.579Z","comments":true,"path":"2019/02/27/allTemp/hexo使用记录/","link":"","permalink":"https://wangdaye7.github.io/2019/02/27/allTemp/hexo使用记录/","excerpt":"","text":"添加分类及标签创建“分类”选项 生成“分类”页并添加tpye属性 打开命令行，进入博客所在文件夹。执行命令 1hexo new page categories 根据提示信息找到index.md, 添加type: “categories”到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: \"categories\"--- 保存并关闭文件。 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 123456789---title: hexo使用记录date: 2019-02-26 23:43:53categories:- hexotags:- hexo- 博客--- 创建“标签”选项同上, 只需要把categories替换为tags即可","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wangdaye7.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wangdaye7.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://wangdaye7.github.io/tags/博客/"}]},{"title":"vue入门学习","slug":"allTemp/vue入门学习","date":"2019-02-26T12:24:13.000Z","updated":"2019-09-15T15:54:29.355Z","comments":true,"path":"2019/02/26/allTemp/vue入门学习/","link":"","permalink":"https://wangdaye7.github.io/2019/02/26/allTemp/vue入门学习/","excerpt":"","text":"学习的路线 Vue概述 Vue的快速入门 Vue的语法 插值表达式 事件的绑定 数据的显示 逻辑判断和循环输出 Vue的生命周期 8个生命周期的执行点 4个基本的 4个特殊的 axios的ajax异步请求 它和jquery的ajax比较相似 综合案例 实现用户的查询列表和更新操作 前端：Vue 后端：ssm helloWord的创建 选择maven-&gt;webapp模板, 补全java, resources, test文件夹 run -&gt; edit configuration-&gt;添加tomcat local script代码 1234567891011&lt;script&gt; //view model //创建一个vue对象 new Vue(&#123; el:\"#app\", //接管id为app的区域 data:&#123; message:\"Hello world, Vue\" &#125; &#125;); &lt;/script&gt; html代码 123&lt;div id=\"app\"&gt; &#123;&#123;message&#125;&#125;&lt;/div&gt; 补充tomcat的设置, 使代码更新后无需重新部署即可同步更新到浏览器 run -&gt; edit configuration-&gt;Tomcat 下的deployment 选择后缀为explode的 项目war 在server进行更新设置 知识点keyDown事件的用法使用event.keyCode获取按下的键, 对按下的键进行控制, event.preventDefault()阻止事件, .stopPopagation()阻止传播 vue接收event需要加上$, 并且可使用@代替v:on按键修饰符的使用@keyDown.enter=”fun1” 当回车被按下的时候执行fun1函数 使用v-bind给标签的属性赋值 可用:简化书写 :color=”ys1”, 在Vue对象中定义ys1的值 直接使用插值表达式不会生效 v-on的事件修饰符常用的两个: .stop .prevent123456789101112131415161718&lt;div id=\"app\"&gt; &lt;form @submit.prevent action=\"http://www.itcast.cn\" method=\"get\"&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt; &lt;div @click=\"fun1\"&gt; &lt;a @click.stop href=\"http://www.itcast.cn\"&gt;itcast&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', //表示当前vue对象接管了div区域 methods: &#123; fun1: function () &#123; alert(\"hello itcast\"); &#125; &#125; &#125;);&lt;/script&gt; v-text和v-html在标签内使用v-text=”message”, message在Vue对象中赋值 v-for的使用 列表中的使用 123&lt;li v-for=\"(item, index) in list\"&gt; //索引在后 &#123;&#123;index + \" \" + item&#125;&#125;&lt;/li&gt; 对象中的使用 123&lt;li v-for=\"(value, key) in wjh\"&gt; &#123;&#123;key + \" \" + value&#125;&#125;&lt;/li&gt; 对象数组中的使用 1234567&lt;table&gt; &lt;tr v-for=\"p in person\"&gt; &lt;td&gt;&#123;&#123;p.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.age&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;p.sex&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; v-model的使用用于控制表单input中的value12345678910111213141516171819&lt;div id=\"app\"&gt; 姓名:&lt;input type=\"text\" id=\"username\" v-model=\"user.username\"&gt;&lt;br&gt; 密码:&lt;input type=\"password\" id=\"password\" v-model=\"user.password\"&gt;&lt;br&gt; &lt;input type=\"button\" @click=\"fun\" value=\"获取\"&gt;&lt;/div&gt;new Vue(&#123; el:'#app', //表示当前vue对象接管了div区域 data:&#123; user:&#123;username:\"\",password:\"\"&#125;&#125;,methods:&#123;fun:function()&#123; alert(this.user.username+\" \"+this.user.password); this.user.username=\"tom\"; this.user.password=\"11111111\"; &#125;&#125;&#125;); v-if与v-showv-if=”true/false” 控制元素是否显示, 可以使用vue对象的data控制 声明周期vue对象初始化过程中，会执行到beforeCreate,created,beforeMount,mounted 这几个钩子的内容 beforeCreate ：数据还没有监听，没有绑定到vue对象实例，同时也没有挂载对象 created ：数据已经绑定到了对象实例，但是还没有挂载对象 beforeMount: 模板已经编译好了，根据数据和模板已经生成了对应的元素对象，将数据对象关联到了对象的el属性，el属性是一个HTMLElement对象，也就是这个阶段，vue实例通过原生的createElement等方法来创建这个html片段，准备注入到我们vue实例指明的el属性所对应的挂载点 mounted:将el的内容挂载到了el，相当于我们在jquery执行了(el).html(el),生成页面上真正的dom，上面我们就会发现dom的元素和我们el的元素是一致的。在此之后，我们能够用方法来获取到el元素下的dom对象，并进 行各种操作 当我们的data发生改变时，会调用beforeUpdate和updated方法 beforeUpdate ：数据更新到dom之前，我们可以看到$el对象已经修改，但是我们页面上dom的数据还没有发生改变 updated: dom结构会通过虚拟dom的原则，找到需要更新页面dom结构的最小路径，将改变更新到dom上面，完成更新 beforeDestroy,destroed :实例的销毁，vue实例还是存在的，只是解绑了事件的监听还有watcher对象数据与view的绑定，即数据驱动 ajax的应用 引入axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中axios的github:https://github.com/axios/axios get 1234567891011121314151617181920//通过给定的ID来发送请求axios.get('/user?ID=12345').then(function(response)&#123; console.log(response);&#125;).catch(function(err)&#123; console.log(err);&#125;);//以上请求也可以通过这种方式来发送axios.get('/user',&#123; params:&#123; ID:12345&#125;&#125;).then(function(response)&#123; //回调函数 console.log(response);&#125;).catch(function(err)&#123; //捕获异常 console.log(err);&#125;); post 12345678910axios.post('/user',&#123; firstName:'Fred', lastName:'Flintstone'&#125;).then(function(res)&#123; console.log(res);&#125;).catch(function(err)&#123; console.log(err);&#125;);","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://wangdaye7.github.io/categories/前端框架/"}],"tags":[{"name":"javaWeb","slug":"javaWeb","permalink":"https://wangdaye7.github.io/tags/javaWeb/"},{"name":"vue","slug":"vue","permalink":"https://wangdaye7.github.io/tags/vue/"},{"name":"前端","slug":"前端","permalink":"https://wangdaye7.github.io/tags/前端/"}]},{"title":"hexo入门","slug":"allTemp/hexo入门","date":"2019-02-24T21:23:30.000Z","updated":"2019-04-09T10:20:07.835Z","comments":true,"path":"2019/02/25/allTemp/hexo入门/","link":"","permalink":"https://wangdaye7.github.io/2019/02/25/allTemp/hexo入门/","excerpt":"","text":"参考网址 hexo中文网 next主题 遇到的一些问题主题设置 设置主题后本地预览没有效果 重新生成整个博客文档解决, 暂无找到其他方法 编写文章 语法不熟悉 在使用标记后必须空格, 随意缩进会导致没有格式, markdown有严格的缩进要求 无法访问 github pages中 出现Domain does not resolve to the GitHub Pages server.在群里大佬帮助下找到问题所在, 将域名解析删除, 留下一个CNAME, 只填写wangdaye7.github.io, 检查hexo/source文件夹下的CNAME文件.完成后cmd中运行ipconfig /flushdns, 然后Chrome中Ctrl+Shift+R不使用缓存.问题解决","categories":[{"name":"hexo","slug":"hexo","permalink":"https://wangdaye7.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wangdaye7.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://wangdaye7.github.io/tags/博客/"}]}]}