{"meta":{"title":"jhmarryme's blog","subtitle":null,"description":"blog","author":"Jiahao Wang","url":"https://wangdaye7.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-02-26T23:04:48.000Z","updated":"2019-02-26T15:05:24.791Z","comments":true,"path":"categories/index.html","permalink":"https://wangdaye7.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-02-26T23:12:23.000Z","updated":"2019-02-26T15:12:51.696Z","comments":true,"path":"tags/index.html","permalink":"https://wangdaye7.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM学习","slug":"offer/refAndClassLoader","date":"2019-08-24T20:34:03.000Z","updated":"2019-09-08T14:21:04.427Z","comments":true,"path":"2019/08/25/offer/refAndClassLoader/","link":"","permalink":"https://wangdaye7.github.io/2019/08/25/offer/refAndClassLoader/","excerpt":"","text":"查看字节码 通过javap命令对.class文件进行反汇编. 123456# 编译成字节码文件javac imooc\\javaBasic\\ByteCodeSample.java# 对代码进行反汇编javap -c imooc.javaBasic.ByteCodeSample# 运行java imooc.javaBasic.ByteCodeSample JVM如何加载.class文件 Class.forName方法的使用 通过Class.forName方法练习反射, 在运行期间动态加载类 实体类: 12345678910111213141516171819package imooc.reflect;/** * @author jhmarryme.cn * @date 2019/7/24 19:15 */public class Rebot &#123; private String name; public void sayHi(String helloSentence)&#123; System.out.println(helloSentence + \" \" + name); &#125; private String throwHello(String tag)&#123; return \"Hello \" + tag; &#125; static &#123; System.out.println(\"Hello Robot\"); &#125;&#125; 测试类: 123456789101112131415161718192021222324252627282930313233343536373839404142package imooc.reflect;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author jhmarryme.cn * @date 2019/7/24 19:27 */public class ReflectDemo &#123; /** * Class.forName的使用练习 * 通过反射动态获取 对象 属性 方法 * @param args */ public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException, InstantiationException &#123; Class&lt;?&gt; rc = Class.forName(\"imooc.reflect.Rebot\"); Rebot r = (Rebot) rc.newInstance(); //getDeclaredMethod可以获取到包括私有, 但是不包括继承来的所有方法 Method throwHello = rc.getDeclaredMethod(\"throwHello\", String.class); //私有的方法或字段, 需要设置 throwHello.setAccessible(true); //需要传入的参数为r Object str = throwHello.invoke(r, \"王家豪\"); System.out.println(\"throwHello 's result is \" + str); //getMethod不能获取到私有的方法, 但是可以获取到继承的方法 Method sayHi = rc.getMethod(\"sayHi\", String.class); sayHi.invoke(r, \"你好啊\"); //获取私有的字段 Field name = rc.getDeclaredField(\"name\"); name.setAccessible(true); name.set(r, \"江航\"); sayHi.invoke(r, \"你好啊\"); &#125;&#125; classLoader 类从编译到执行的过程 ClassLoader作用 ClassLoader种类 自定义ClassLoaderMyClassLoader: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package imooc.reflect;import java.io.*;/** * 自定义的类加载器, 用于加载自定义位置的类 * 通过重写findClass方法 达到效果 * 重写的是findClass方法, 但使用时调用的是loadClass方法 * @author jhmarryme.cn * @date 2019/7/24 20:14 */public class MyClassLoader extends ClassLoader &#123; //类所在的路径 private String path; //随意取名 private String classLoaderName; public MyClassLoader(String path, String classLoaderName) &#123; this.path = path; this.classLoaderName = classLoaderName; &#125; /** * 用于寻找类文件 * @param name * @return */ @Override public Class findClass(String name)&#123; //先加载类的二进制流 byte[] b = loadClassData(name); //通过defineClass方法创建类 return defineClass(name, b, 0, b.length); &#125; //用于加载类文件 private byte[] loadClassData(String name) &#123; //找到类文件 name = path + \"/\" + name + \".class\"; try ( InputStream in = new FileInputStream(new File(name)); ByteArrayOutputStream out = new ByteArrayOutputStream(); )&#123; int i = 0; while ((i = in.read()) != -1)&#123; out.write(i); &#125; return out.toByteArray(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 测试类: 12345678910111213141516171819package imooc.reflect;/** * 测试自定义类加载器 * @author jhmarryme.cn * @date 2019/7/24 20:23 */public class MyClassLoaderChecker &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; MyClassLoader classLoader = new MyClassLoader(\"D:/develop/folderForDevelop/\", \"myClassLoader\"); //调用的是loadClass方法加载类 Class&lt;?&gt; waLi = classLoader.loadClass(\"WaLi\"); System.out.println(waLi.getClassLoader()); waLi.newInstance(); &#125;&#125;","categories":[],"tags":[]},{"title":"牛客算法学习2","slug":"note/algorithm/牛客算法学习2","date":"2019-07-28T19:34:47.000Z","updated":"2019-09-08T14:21:58.182Z","comments":true,"path":"2019/07/29/note/algorithm/牛客算法学习2/","link":"","permalink":"https://wangdaye7.github.io/2019/07/29/note/algorithm/牛客算法学习2/","excerpt":"","text":"part2栈队列一个特殊的栈 在实现栈的基本功能的基础上，再实现返 回栈中最小元素的操作。1．pop、push、getMin操作的时间复杂度都是O(1)。2．设计的栈类型可以使用现成的栈结构 栈和队列的转换实现用栈实现队列 因为栈是先进后出的, 假设现有push栈, 先创建一个辅助栈pop逆序存入push中的值, 只需要弹出pop栈顶的值即可, 只有当pop栈为空的时候才存入push中所有的数据, 而且必须一次性存入. 用队列实现栈 队列是先进先出的, 假设有队列queue, 创建一个辅助队列help, 当需要弹出时, 首先将queue弹出到只剩一个值, 并且将弹出的值依次放入help中, 这时候queue中剩下的数据就是最后进来的那个数据, 弹出即可. 此时help中还是维持着queue中原来的顺序, 而queue队列已经空了, 只需要将help与queue队列互换一下就可以了. 猫狗队列哈希哈希函数 哈希函数的输入认为是无穷的, 而输出是有限的 相同的输入, 一定是相同的输出 same input same output 不同的输入也可能导致相同的输出 dif input maybe same output, 这就叫哈希碰撞 离散性, 整个S域上基本均匀分布.","categories":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/categories/算法/"}],"tags":[]},{"title":"方法引用","slug":"note/cyc2018/stream/方法引用","date":"2019-07-24T14:19:23.000Z","updated":"2019-07-24T06:24:44.427Z","comments":true,"path":"2019/07/24/note/cyc2018/stream/方法引用/","link":"","permalink":"https://wangdaye7.github.io/2019/07/24/note/cyc2018/stream/方法引用/","excerpt":"","text":"1. 思维导图 2. 方法引用 2.1. 概念 2.1.1. 目的 2.1.2. 使用场景 2.2. 如何引用 2.2.1. 通过对象名引用成员方法 2.2.2. 通过类名称引用静态方法 2.2.3. 通过super引用成员方法 2.2.4. 通过this引用成员方法 2.2.5. 类的构造器引用 2.2.6. 数组的构造器引用 2.3. 方法引用练习 1. 思维导图 2. 方法引用2.1. 概念 双冒号::为引用运算符，它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。 2.1.1. 目的 简化代码, 避免写重复逻辑 2.1.2. 使用场景 如果lambda所要表达的函数方案已经存在与某个方法的实现中, 则可以通过双冒号来引用该方法作为Lambda的替代者. 其实你想表达的lambda已经有人帮你实现了, 就没有必要自己再写一遍, 直接引用即可 2.2. 如何引用2.2.1. 通过对象名引用成员方法12345public class MethodRefObject &#123; public void printUpperCase(String str) &#123; System.out.println(str.toUpperCase()); &#125;&#125; 函数式接口： 1234@FunctionalInterfacepublic interface Printable &#123; void print(String str);&#125; 12345678910public class Demo04MethodRef &#123; private static void printString(Printable lambda) &#123; lambda.print(\"Hello\"); &#125; public static void main(String[] args) &#123; MethodRefObject obj = new MethodRefObject(); printString(obj::printUpperCase); &#125;&#125; 2.2.2. 通过类名称引用静态方法2.2.3. 通过super引用成员方法1234@FunctionalInterfacepublic interface Greetable &#123; void greet();&#125; 12345public class Human &#123; public void sayHello() &#123; System.out.println(\"Hello!\"); &#125;&#125; 123456789101112131415public class Man extends Human &#123; @Override public void sayHello() &#123; System.out.println(\"大家好,我是Man!\"); &#125; //定义方法method,参数传递Greetable接口 public void method(Greetable g)&#123; g.greet(); &#125; public void show()&#123; method(super::sayHello); &#125;&#125; 2.2.4. 通过this引用成员方法2.2.5. 类的构造器引用2.2.6. 数组的构造器引用2.3. 方法引用练习","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"stream与函数式接口","slug":"note/cyc2018/stream/stream与函数式接口","date":"2019-07-24T14:03:02.000Z","updated":"2019-07-24T06:35:53.710Z","comments":true,"path":"2019/07/24/note/cyc2018/stream/stream与函数式接口/","link":"","permalink":"https://wangdaye7.github.io/2019/07/24/note/cyc2018/stream/stream与函数式接口/","excerpt":"","text":"1. 思维导图 2. Stream 与函数式接口 2.1. 获取流 2.2. 流的方法 2.2.1. forEach 2.2.2. filter 2.2.3. map 2.2.4. count 2.2.5. limit 2.2.6. skip 2.2.7. concat 2.3. collect 的使用 2.3.1. 转换为 list 2.3.2. 转换为 map 2.4. 流的方法练习 2.5. 函数式接口 2.5.1. Supplier 2.5.2. Consumer 2.5.3. Predicate 2.5.4. Function&lt;T,R&gt; 2.6. 函数式接口方法练习 2.6.1. 比较器 2.6.2. consumer 2.6.3. supplier 2.6.4. function 2.6.5. predicate 2.6.6. lambda延迟加载 1. 思维导图 2. Stream 与函数式接口2.1. 获取流 所有的 Collection 集合都可以通过 stream 默认方法获取流 Stream 接口的静态方法 of 可以获取数组对应的流 Map 不是集合类型，需要根据 key, value, entry 分别获取相应的流 2.2. 流的方法2.2.1. forEach void forEach(Consumer&lt;? super T&gt; action); 2.2.2. filter Stream filter(Predicate&lt;? super T&gt; predicate); 2.2.3. map 将流中的元素映射到另一个流中，通常是用来转换成另一个类型 Stream map(Function&lt;? super T, ? extends R&gt; mapper); 2.2.4. count long count(); 2.2.5. limit Stream limit(long maxSize); 2.2.6. skip Stream skip(long n); 2.2.7. concat static Stream concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) 2.3. collect 的使用2.3.1. 转换为 list collect.() 2.3.2. 转换为 map 传入 key, value 即可 public static &lt;T,K,U&gt; Collector&lt;T,?,Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T,? extends K&gt; keyMapper,Function&lt;? super T,? extends U&gt; valueMapper) 例如：Stream.concat(one.stream(), two.stream()).collect(Collectors.toMap(s -&gt; s, s -&gt; new Person(s))); 2.4. 流的方法练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package javaBase.Stream;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.Stream;/** * @author jhmarryme.cn * @date 2019/7/24 11:21 */public class StreamAndFunctionalInterface &#123; /** * 测试流的各种方法结合常用函数式接口的使用 * @param args */ public static void main(String[] args) &#123; ArrayList&lt;String&gt; one = new ArrayList&lt;&gt;(); one.add(\"迪丽热巴\"); one.add(\"宋远桥\"); one.add(\"苏星河\"); one.add(\"石破天\"); one.add(\"石中玉\"); one.add(\"老子\"); one.add(\"庄子\"); one.add(\"洪七公\"); //第二支队伍 ArrayList&lt;String&gt; two = new ArrayList&lt;&gt;(); two.add(\"古力娜扎\"); two.add(\"张无忌\"); two.add(\"赵丽颖\"); two.add(\"张三丰\"); two.add(\"尼古拉斯赵四\"); two.add(\"张天爱\"); two.add(\"张二狗\");// 1. 第一个队伍只要名字为3个字的成员姓名；存储到一个新集合中。 one.stream().filter(s -&gt; s.length() == 3).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 2. 第一个队伍筛选之后只要前3个人；存储到一个新集合中。 one.stream().limit(3).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 3. 第二个队伍只要姓张的成员姓名；存储到一个新集合中。 two.stream().filter(s -&gt; s.startsWith(\"张\")).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 4. 第二个队伍筛选之后不要前2个人；存储到一个新集合中。 two.stream().skip(2).collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 5. 将两个队伍合并为一个队伍；存储到一个新集合中。 Stream&lt;String&gt; stream = Stream.concat(one.stream(), two.stream());// stream.collect(Collectors.toList()).forEach(s -&gt; System.out.println(s)); System.out.println(\"------------\");// 6. 根据姓名创建`Person`对象；存储到一个新集合中。// 7. 打印整个队伍的Person对象信息。 stream.map(s -&gt; &#123; return new Person(s); &#125;).collect(Collectors.toList()).forEach(person -&gt; System.out.println(person.toString())); //8. 补充, 将list映射为map final Map&lt;String, Person&gt; map = Stream.concat(one.stream(), two.stream()).collect(Collectors.toMap(s -&gt; s, s -&gt; new Person(s))); final Set&lt;Map.Entry&lt;String, Person&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;String, Person&gt; entry : entries) &#123; System.out.print(entry.getKey()); System.out.println(\" : \" + entry.getValue().toString()); &#125; &#125;&#125; 2.5. 函数式接口 有且仅有一个抽象方法的接口 2.5.1. Supplier 生产一个数据 T get() 2.5.2. Consumer 是消费一个数据 void accept(T t) 默认方法：andThen 2.5.3. Predicate 对某种类型的数据进行判断 boolean test(T t) 默认方法：and or negate 2.5.4. Function&lt;T,R&gt; 根据一个类型的数据得到另一个类型的数据 R apply(T t) 默认方法：andThen 2.6. 函数式接口方法练习2.6.1. 比较器123456789101112131415161718192021package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.Arrays;/** * 通过lambda表达式 作为比较器 * @author jhmarryme.cn * @date 2019/7/22 9:43 */public class LambdaForComparatorDemo &#123; public static void main(String[] args) &#123; String[] array = &#123; \"abc\", \"ab\", \"abcd\" &#125;; System.out.println(Arrays.toString(array)); Arrays.sort(array, (a, b) -&gt; &#123; return a.length() - b.length(); &#125;); System.out.println(Arrays.toString(array)); &#125;&#125; 2.6.2. consumer1234567891011121314151617181920212223242526272829303132package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.function.Consumer;/** * 测试Consumer接口 * 消费一个指定泛型的数据, 无返回值 * 可通过andThen组合操作 * @author jhmarryme.cn * @date 2019/7/22 11:21 */public class LambdaForConsumerDemo &#123; public static void consumerString(String[] info, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2, Consumer&lt;String&gt; con3)&#123; for (String s : info) &#123; con1.andThen(con2).andThen(con3).accept(s); &#125; &#125; public static void main(String[] args) &#123; String[] array = &#123; \"迪丽热巴,女, 14\", \"古力娜扎,女, 12\", \"马尔扎哈,男, 121\" &#125;; consumerString(array, s -&gt; System.out.print(\"姓名: \" + s.split(\",\")[0]), s -&gt; System.out.print(\"性别: \" + s.split(\",\")[1]), s -&gt; System.out.println(\"年龄: \" + s.split(\",\")[2]) ); &#125;&#125; 2.6.3. supplier1234567891011121314151617181920212223242526272829303132333435363738394041424344package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.function.Supplier;/** * 测试Supplier接口 * 包含一个无参的方法, 用来获取一个泛型参数指定类型的对象数据 * @author jhmarryme.cn * @date 2019/7/22 9:52 */public class LambdaForSupplierDemo &#123; public static void main(String[] args) &#123; /*String msgA = \"Hello\"; String msgB = \"World\"; System.out.println(getString(() -&gt; msgA + msgB));*/ int arr[] = &#123;2,3,4,52,333,23&#125;; System.out.println(getMax(() -&gt; &#123; int max = arr[0]; for (int i : arr) &#123; max = i &gt; max ? i : max; &#125; return max; &#125;)); &#125; public static int getMax(Supplier&lt;Integer&gt; integerSupplier)&#123; return integerSupplier.get(); &#125; public static String getString(Supplier&lt;String&gt; stringSupplier)&#123; return stringSupplier.get(); &#125;&#125; 2.6.4. function123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.function.Function;/** * 通过函数式结构练习function接口 * 根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件 * @author jhmarryme.cn * @date 2019/7/22 13:15 */public class LambdaForFunctionDemo &#123; /** * 根据接口的泛型 * apply方法中参数类型为String, 返回Integer * @param integerFunction */ public static void method(Function&lt;String, Integer&gt; integerFunction)&#123; final Integer apply = integerFunction.apply(\"5\"); System.out.println(apply + 20); &#125; /** * 在前一个function的基础上再进行处理 * 第二个function的第一个泛型必须为前一个function的后一个泛型 * 相当于前一个的结果为Integer, 后一个就必须用Integer接收 * @param f1 * @param f2 */ public static void methood(Function&lt;String, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)&#123; final Integer apply = f1.andThen(f2).apply(\"1\"); System.out.println(apply); &#125; /** * 截取数字部分, 得到的结果加上100返回 * @param str * @param f1 * @param f2 * @return */ public static Integer getAgeNum(String str, Function&lt;String, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)&#123; return f1.andThen(f2).apply(str); &#125; public static void main(String[] args) &#123;// method((s) -&gt; Integer.parseInt(s));// methood(s -&gt; Integer.parseInt(s)+1, i -&gt; i = ((int)Math.pow(i, 10))); String str = \"赵丽颖,20\"; final Integer ageNum = getAgeNum(str, s -&gt; Integer.parseInt(s.split(\",\")[1]), i -&gt; i = i + 100 ); System.out.println(ageNum); &#125;&#125; 2.6.5. predicate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package javaBase.functionalInterface.functionalInterfaceDemo;import java.util.ArrayList;import java.util.List;import java.util.function.Predicate;/** * 通过函数式接口练习predicate相关的方法 * 对泛型指定数据类型进行判断, 得到一个布尔值. * 包含与或非and, or, negate * @author jhmarryme.cn * @date 2019/7/22 12:54 */public class LambdaForPredicateDemo &#123; public static Boolean method( Predicate&lt;String&gt; stringPredicate)&#123; return stringPredicate.test(\"helloWorld\"); &#125; public static void method(Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2)&#123; final boolean helloWorld = p1.or(p2).test(\"HelloWorld\"); System.out.println(helloWorld); &#125; public static ArrayList&lt;String&gt; filterString(String[] arr, Predicate&lt;String&gt; stringPredicate)&#123; final ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String s : arr) &#123; if (stringPredicate.test(s)) &#123; list.add(s); &#125; &#125; return list; &#125; public static void main(String[] args) &#123; /*System.out.println(method(s -&gt; &#123; return s.length() &gt; 5; &#125;));*/// method(s -&gt; s.contains(\"el\"), s -&gt; s.length() &gt; 10); /** * 筛选条件: * 必须为女生； * 姓名为4个字。 */ String[] array = &#123; \"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\", \"赵丽颖,女\" &#125;; final ArrayList&lt;String&gt; arrayList = filterString(array, s -&gt; &#123; return s.split(\",\")[1].equals(\"女\") &amp;&amp; s.split(\",\")[0].length() == 4; &#125;); for (String s : arrayList) &#123; System.out.println(s); &#125; &#125;&#125; 2.6.6. lambda延迟加载12345678910111213141516171819202122232425262728293031323334353637383940414243444546package javaBase.functionalInterface.DelayForLambda;import static javaBase.functionalInterface.DelayForLambda.MessageBuilder.MAX_NUM;/** * 测试lambda表达式的延迟执行 * 优化性能, 在不符合条件时, 不会执行lambda的内容 * @author jhmarryme.cn * @date 2019/7/22 9:32 */public class DelayForLambdaDemo &#123; public static void log(int level, MessageBuilder builder)&#123; if (level == 1) &#123; System.out.println(builder.messageBuilder()); &#125; &#125; public static void main(String[] args) &#123; String msgA = \"Hello\"; String msgB = \"World\"; String msgC = \"Java\"; //这里的拼接字符串 在条件不成立时不会执行 log(1, () -&gt; msgA + msgB + msgC ); &#125;&#125;package javaBase.functionalInterface.DelayForLambda;/** * @author jhmarryme.cn * @date 2019/7/22 9:33 */@FunctionalInterfacepublic interface MessageBuilder &#123; int MAX_NUM = 97; /** * 测试lambda延迟加载 * @return */ String messageBuilder();&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"socket网络编程","slug":"note/cyc2018/socket/socket网络编程","date":"2019-07-21T19:37:33.000Z","updated":"2019-07-21T14:05:39.825Z","comments":true,"path":"2019/07/22/note/cyc2018/socket/socket网络编程/","link":"","permalink":"https://wangdaye7.github.io/2019/07/22/note/cyc2018/socket/socket网络编程/","excerpt":"","text":"1. socket编程 1.1. 面向TCP的网络编程 1.2. 简单的本地通信 1.3. 简单的文件上传 2. 总结 1. socket编程1.1. 面向TCP的网络编程今天学完socket编程, 发现其实java中的socket编程是非常简单的, 当然今天只接触了本地通信, 没有涉及到远端通信的问题. 不知道会不会牵扯到更多的东西. 其实只要把步骤理解清楚, 是非常容易的. 今天也没有接触到更深的关于tcp的东西, 所以学起来很简单. 主要记录的也是编程的一些步骤, 具体查阅API即可. 【服务端】启动,创建ServerSocket对象，等待连接。 【客户端】启动,创建Socket对象，请求连接。 【服务端】接收连接,调用accept方法，并返回一个Socket对象。 【客户端】Socket对象，获取OutputStream，向服务端写出数据。 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。 【服务端】Socket对象，获取OutputStream，向客户端回写数据。 【客户端】Scoket对象，获取InputStream，解析回写数据。 【客户端】释放资源，断开连接。 1.2. 简单的本地通信为了方便, 在这里把客户端服务端写到了一起, 两个线程启用. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package javaBase.socket;import java.io.InputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;/** * @author jhmarryme.cn * @date 2019/7/21 20:01 */public class TcpCommunication &#123; static int count = 0; public static void main(String[] args) &#123; //创建服务端线程 new Thread(() -&gt; &#123; System.out.print(++count); System.out.println(\"服务器正在启动, 等待连接中\"); try &#123; //1. 创建serverSocket对象, 等待连接 ServerSocket serverSocket = new ServerSocket(6666); //2. 连接成功, 返回Socket对象 Socket accept = serverSocket.accept(); //3. 通过连接的socket获取输入流 InputStream inputStream = accept.getInputStream(); //4. 解析输入流中数据 byte[] b = new byte[1024]; final int len = inputStream.read(b); System.out.print(++count); System.out.println(new String(b, 0, len)); //5. 通过socket获取输出流 final OutputStream outputStream = accept.getOutputStream(); //6. 发送数据到客户端 System.out.print(++count); outputStream.write(\"这是服务端发送的数据\".getBytes()); outputStream.close(); inputStream.close(); serverSocket.close(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;).start(); //创建客户端线程 new Thread(() -&gt; &#123; try&#123; System.out.print(++count); System.out.println(\"客户端启动成功\"); //1. 创建socket连接 Socket socket = new Socket(\"localhost\", 6666); //2. 获取输出流 final OutputStream outputStream = socket.getOutputStream(); //3. 发出数据 System.out.print(++count); outputStream.write(\"这是客户端发送的数据: hello\".getBytes()); //4. 获取输入流 final InputStream inputStream = socket.getInputStream(); //5. 显示接受到的数据 byte[] bytes = new byte[1024]; final int len = inputStream.read(bytes); System.out.print(++count); System.out.println(new String(bytes, 0, len)); inputStream.close(); outputStream.close(); socket.close(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125; 1.3. 简单的文件上传 【客户端】输入流，从硬盘读取文件数据到程序中。 【客户端】输出流，写出文件数据到服务端。 【服务端】输入流，读取文件数据到服务端程序。 【服务端】输出流，写出文件数据到服务器硬盘中。 客户端实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package javaBase.socket.fileUpload;import java.io.*;import java.net.Socket;/** * @author jhmarryme.cn * @date 2019/7/21 20:34 */public class FileUploadClient &#123; public static void main(String[] args) throws IOException &#123; //1. 连接服务器 final Socket socket = new Socket(\"localhost\", 6666); //2. 发送文件 //2.1 读取本地文件 final BufferedInputStream localBufferedIn = new BufferedInputStream( new FileInputStream(\"C:\\\\Users\\\\jhmarryme\\\\Downloads\\\\未命名文件.png\") ); //2.2 创建远程输出流 final BufferedOutputStream remoteBufferedOut = new BufferedOutputStream(socket.getOutputStream()); //2.3 缓冲区 int len = -1; byte[] bytes = new byte[8 * 1024]; //2.4 上传到服务器 while ( (len = localBufferedIn.read(bytes)) != -1 )&#123; remoteBufferedOut.write(bytes, 0, len);// remoteBufferedOut.flush(); // 采用关闭输出流的方式通知服务端, 因此不需要这个了 &#125; socket.shutdownOutput(); System.out.println(\"文件发送完毕\"); //接收来自服务端的信息 final InputStream remoteIn = socket.getInputStream(); byte[] back = new byte[100]; remoteIn.read(back); System.out.println(new String(back)); remoteIn.close(); //释放资源 socket.close(); localBufferedIn.close(); &#125;&#125; 服务端实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package javaBase.socket.fileUpload;import java.io.*;import java.net.ServerSocket;import java.net.Socket;/** * @author jhmarryme.cn * @date 2019/7/21 20:34 */public class FileUploadServer &#123; public static void main(String[] args) throws IOException &#123;//1. 创建服务器, 等待连接 final ServerSocket serverSocket = new ServerSocket(6666); String parent = \"D:\\\\develop\\\\folderForDevelop\\\\\"; while (true)&#123; //2. 连接成功 final Socket accept = serverSocket.accept(); // 如果连接成功的话会继续进行. new Thread(() -&gt; &#123; try ( //3.1 获取远程输入流 BufferedInputStream in = new BufferedInputStream(accept.getInputStream()); //3.2 获取本地输出流 final BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(new File(parent + System.currentTimeMillis() + \".txt\"))); )&#123; //4. 保存文件到本地 //4.1 缓冲区 byte[] bytes = new byte[1024 * 8]; int len = -1; //4.2 保存 while( (len = in.read(bytes)) != -1 )&#123; out.write(bytes, 0, len); &#125; //5. 回写数据 final OutputStream remoteOut = accept.getOutputStream(); remoteOut.write(\"上传成功\".getBytes()); //关闭资源 accept.close(); remoteOut.close(); System.out.println(\"文件已保存\"); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;).start(); &#125; &#125;&#125; 2. 总结重点就是分清步骤, 其实总体来说很简单.今天接触的知识比较浅, 没有做更深入的学习, 等以后学习了再进行补充.","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"几个简单的递归练习","slug":"note/cyc2018/recursion/几个简单的递归练习","date":"2019-07-21T14:40:28.000Z","updated":"2019-07-21T06:41:51.872Z","comments":true,"path":"2019/07/21/note/cyc2018/recursion/几个简单的递归练习/","link":"","permalink":"https://wangdaye7.github.io/2019/07/21/note/cyc2018/recursion/几个简单的递归练习/","excerpt":"","text":"打印当前目录下所有文件及目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package javaBase.recursion;import java.io.File;import java.util.*;/** * @author jhmarryme.cn * @date 2019/7/21 11:17 */public class PrintAllDirs &#123; private static Map&lt;String, List&lt;String&gt;&gt; map; /** * 测试打印当前目录下所有文件及目录 * @param args */ public static void main(String[] args) &#123; map = new HashMap&lt;&gt;(); File dir = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\"); printDir(dir); for (Map.Entry&lt;String, List&lt;String&gt;&gt; stringListEntry : map.entrySet()) &#123; String key = stringListEntry.getKey(); System.out.println(key + \": \"); List&lt;String&gt; value = stringListEntry.getValue(); for (String s : value) &#123; System.out.println(s); &#125; System.out.println(); &#125; &#125; /** * 将当前目录下所有文件名及目录名 一一对应显示出来 * @param dir */ public static void printDir(File dir) &#123; //先获取所有文件及目录 File[] files = dir.listFiles(); for (File file : files) &#123; //如果是文件则直接存入 if (file.isFile())&#123; String parent = file.getParent(); List&lt;String&gt; strings = map.get(parent); if (strings == null) &#123; strings = new ArrayList&lt;&gt;(); map.put(parent, strings); &#125; strings.add(file.getName()); &#125; else &#123; printDir(file); &#125; &#125; &#125;&#125; 递归求和, 阶乘1234567891011121314151617181920212223242526272829303132333435363738394041424344package javaBase.recursion;/** * @author jhmarryme.cn * @date 2019/7/21 11:07 */public class SimpleRecursionTest &#123; /** * 测试 * @param args */ public static void main(String[] args) &#123; System.out.println(getSumByRecursion(10)); System.out.println(getFactorial(5L)); &#125; /** * 递归求1~n的和 * @param n * @return */ public static int getSumByRecursion(int n)&#123; if (n == 1)&#123; return n; &#125; return n + getSumByRecursion(n - 1); &#125; /** * 递归求阶乘 * @param n * @return */ public static Long getFactorial(Long n)&#123; if (n == 1) &#123; return n; &#125; return n * getFactorial(n - 1); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"","slug":"note/疑问","date":"2019-07-21T01:58:47.142Z","updated":"2019-06-27T07:30:08.178Z","comments":true,"path":"2019/07/21/note/疑问/","link":"","permalink":"https://wangdaye7.github.io/2019/07/21/note/疑问/","excerpt":"","text":"ArrayList 与 List equals与==== 比较对象地址, equals比较值","categories":[],"tags":[]},{"title":"通用异常处理","slug":"note/temp/通用异常处理","date":"2019-07-18T16:14:19.000Z","updated":"2019-09-08T14:23:31.851Z","comments":true,"path":"2019/07/19/note/temp/通用异常处理/","link":"","permalink":"https://wangdaye7.github.io/2019/07/19/note/temp/通用异常处理/","excerpt":"","text":"通用异常处理处理异常信息时, 通过SpringMVC的AOP拦截异常, 返回错误信息 环境依赖: (不引用启动器, 版本由父工程管理) 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 自定义枚举类用于异常信息 12345678910@Getter@AllArgsConstructor@NoArgsConstructorpublic enum ExceptionEnum &#123; //价格不能为空 PRICE_CANNOT_BE_NULL(400, \"价格不能为空\") ; private int code; private String message;&#125; 自定义信息类 12345678910111213@Datapublic class ExceptionResult &#123; private int status; private String message; private Long timestamp; public ExceptionResult(ExceptionEnum exceptionEnum) &#123; this.status = exceptionEnum.getCode(); this.message = exceptionEnum.getMessage(); this.timestamp = System.currentTimeMillis(); &#125;&#125; 自定义异常类 1234567@AllArgsConstructor@NoArgsConstructor@Getterpublic class LyException extends RuntimeException &#123; //接受枚举作为参数 private ExceptionEnum exceptionEnum;&#125; 自定义通用异常拦截器 12345678910//要想该类被扫描到, 必须和应用启动器的类处于同一个包下 @ControllerAdvicepublic class CommonExceptionHandler &#123; @ExceptionHandler(LyException.class) public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; //返回的是整个响应消息, 其中主要配置错误码和响应体 return ResponseEntity.status(e.getExceptionEnum().getCode()).body(new ExceptionResult(e.getExceptionEnum())); &#125;&#125; 应用 123456789101112131415@RestController@RequestMapping(\"item\")public class ItemController &#123; @Autowired private ItemService itemService; @PostMapping public ResponseEntity&lt;Item&gt; saveItem(Item item)&#123; //校验价格 if (item.getPrice() == null) &#123; //传递一个枚举变量 throw new LyException(ExceptionEnum.PRICE_CANNOT_BE_NULL); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(item); &#125;&#125; 补充","categories":[{"name":"待整理","slug":"待整理","permalink":"https://wangdaye7.github.io/categories/待整理/"}],"tags":[]},{"title":"命令备忘","slug":"note/temp/命令备忘","date":"2019-07-18T15:42:19.000Z","updated":"2019-09-08T14:23:21.084Z","comments":true,"path":"2019/07/18/note/temp/命令备忘/","link":"","permalink":"https://wangdaye7.github.io/2019/07/18/note/temp/命令备忘/","excerpt":"","text":"rabbitmq-server startnginx -s reload./elasticsearch","categories":[{"name":"待整理","slug":"待整理","permalink":"https://wangdaye7.github.io/categories/待整理/"}],"tags":[]},{"title":"File与流","slug":"note/cyc2018/File/File及基本流学习记录","date":"2019-07-17T11:52:41.000Z","updated":"2019-07-24T13:30:35.958Z","comments":true,"path":"2019/07/17/note/cyc2018/File/File及基本流学习记录/","link":"","permalink":"https://wangdaye7.github.io/2019/07/17/note/cyc2018/File/File及基本流学习记录/","excerpt":"","text":"1. 思维导图 2. File类 2.1. 新建/打开文件 3. IO流 3.1. 字节流 3.1.1. 通过字节流复制文件 3.2. 字符流 3.3. IO异常的处理 4. 缓冲流 4.1. 字节缓冲流和字符缓冲流 4.1.1. 字符缓冲流特有方法 4.1.2. 复制大文件 5. 转换流 6. 序列化 6.1. ObjectOutputStream类和ObjectInputStream类 6.1.1. 主要方法 7. 打印流 8. 总结 1. 思维导图 2. File类以前对文件流的认识比较浅, 只是偶尔用到的时候查一下, 不懂的用法看一下. 但总归是经常需要使用到的东西, 这次就特地好好来学一下. 2.1. 新建/打开文件这里的我的主要学习点在新建文件和打开已有的文件上, 知道常用的方法就够了, 至于很多的方法在使用的时候总结归纳一下, 翻阅API就够用了. new File()的使用方法有很多种, 可以通过绝对路径创建和结合File与相对路径使用等等, 无论文件是否存在都能新建成功, 所以最好先用exists()方法确认文件是否存在再进行下一步操作.当文件不存在时, 通过createNewFile()创建. 下面是代码练习: 12345678910111213141516171819202122232425262728293031package javaBase.File;import java.io.*;/** * @author jhmarryme.cn * @date 2019/7/17 11:57 */public class CreateFileDemo &#123; public static void main(String[] args) throws IOException &#123; File file = new File(\"D:\\\\\", \"WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\"); System.out.println(file.isDirectory()); if (file.isDirectory()) &#123; File hello = new File(file, \"hellWorld.java\"); if (!hello.exists()) &#123; System.out.println(hello.exists()); hello.createNewFile(); System.out.println(hello.exists()); &#125; &#125; //查看 for (String s : file.list()) &#123; System.out.println(s); &#125; for (File listFile : file.listFiles()) &#123; System.out.println(listFile.getAbsolutePath()); &#125; &#125;&#125; 3. IO流3.1. 字节流字节流的使用很简单, 感觉平常使用的也不多, 所以就简单测试了一下用法。 重点也就是两个常用的输入输出流：OutputStream InputStream 使用的也是两个子类 FileInputStream FileOutputStream 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package javaBase.File;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;/** * @author jhmarryme.cn * @date 2019/7/21 13:46 */public class FileReadAndWrite &#123; public static void main(String[] args) &#123;// testFileWrite(); testReadFile(); &#125; public static void testReadFile()&#123; File file = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld.txt\"); try &#123; FileInputStream inputStream = new FileInputStream(file); int read;/* //无参read 返回的是int类型的数据, 转换为char可以显示 while( (read = inputStream.read()) != -1 )&#123; System.out.print( ( char)read); &#125;*/ //用byte数组作为read的参数时, 返回的是读取的长度 byte[] bytes = new byte[2]; while ((read = inputStream.read(bytes) ) != -1)&#123; System.out.print(new String(bytes,0, read)); &#125; inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 文件写入 */ public static void testFileWrite()&#123; File file = new File(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld.txt\"); if (!file.isDirectory()) &#123; System.out.println(file.getAbsolutePath()); try &#123; //为true代表追加写入, 为false或不写则清空文件 FileOutputStream outputStream = new FileOutputStream(file,true); outputStream.write(\"helloWorld\".getBytes()); outputStream.write(\"\\r\\n\".getBytes()); outputStream.write(97); outputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.1.1. 通过字节流复制文件 打开文件流 -&gt; 循环读写 -&gt; 关闭文件 123456789101112131415161718192021/** * 测试复制文件 */public static void testCopyFile() throws IOException &#123; //打开源文件 FileInputStream source = new FileInputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld.txt\"); //打开目标文件, 不存在 FileOutputStream target = new FileOutputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\hellWorld-back.txt\"); //指定缓冲数组大小 byte[] b = new byte[1024]; int len = -1; while ( (len = source.read(b)) != -1 )&#123; target.write(b, 0, len); &#125; source.close(); target.close();&#125; 3.2. 字符流使用基本和字节流一致. 3.3. IO异常的处理JDK9的改进,无需手动close :123456789// 被final修饰的对象final Resource resource1 = new Resource(\"resource1\");// 普通对象Resource resource2 = new Resource(\"resource2\");// 引入方式：直接引入try (resource1; resource2) &#123; // 使用对象&#125; 4. 缓冲流4.1. 字节缓冲流和字符缓冲流 字节缓冲流：BufferedInputStream，BufferedOutputStream 字符缓冲流：BufferedReader，BufferedWriter 使用方法很简单, 就是在已有的IO流上继续构建一个缓冲流相比于普通的IO流, 缓冲流处理的速度非常快 4.1.1. 字符缓冲流特有方法 BufferedReader：public String readLine(): 读一行文字。 BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 4.1.2. 复制大文件测试用法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package javaBase.File;import java.io.*;/** * @author jhmarryme.cn * @date 2019/7/21 15:27 */public class FileReadByBufferdStream &#123; public static void main(String[] args) &#123; copyFileByBufferedStream(); &#125; /** * 通过缓冲流复制大文件 */ public static void copyFileByBufferedStream() &#123; String parent = \"C:\\\\Users\\\\jhmarryme\\\\Downloads\"; long length = 0; long currentTimeMillis = System.currentTimeMillis(); try ( BufferedInputStream inputStream = new BufferedInputStream( new FileInputStream(parent + \"\\\\我是大哥大.Kyou.kara.Ore.wa.Ep08.Chi_Jap.HDTVrip.1280X720-ZhuixinFan.mp4\")); BufferedOutputStream outputStream = new BufferedOutputStream( new FileOutputStream(parent + \"\\\\dageda.mp4\")); )&#123; byte[] bytes = new byte[8 * 1024]; int len = -1; while ( (len = inputStream.read(bytes)) != -1 )&#123; outputStream.write(bytes, 0, len); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(\"复制所花费的时间\" + (System.currentTimeMillis() - currentTimeMillis)); &#125;&#125; 5. 转换流 InputStreamReaderOutputStreamWriter 主要用来处理编码格式问题. 123456789101112131415161718192021222324252627282930313233343536package javaBase.File;import java.io.FileInputStream;import java.io.FileReader;import java.io.InputStreamReader;/** * @author jhmarryme.cn * @date 2019/7/21 15:56 */public class FileReadAndWriteByConversionStream &#123; public static void main(String[] args) &#123; testRead(); &#125; /** * 读取GB2312格式的文件 */ public static void testRead()&#123; try (// FileReader reader = new FileReader(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\test.txt\"); InputStreamReader reader = new InputStreamReader( new FileInputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\test.txt\"), \"GB2312\" ); )&#123; int read; while ((read = reader.read()) != -1)&#123; System.out.print((char)read); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 6. 序列化 Java 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 6.1. ObjectOutputStream类和ObjectInputStream类6.1.1. 主要方法 public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。 public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。 public final void writeObject (Object obj) : 将指定的对象写出。 public final Object readObject () : 读取一个对象。 实体类:1234567891011121314151617package javaBase.File;import lombok.Data;import java.io.Serializable;@Datapublic class Employee implements Serializable &#123; private static final long serialVersionUID = 8915532794959050340L; public String name; public String address; public transient int age; // transient瞬态修饰成员,不会被序列化 public void addressCheck() &#123; System.out.println(\"Address check : \" + name + \" -- \" + address); &#125;&#125; 测试代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package javaBase.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;/** * @author jhmarryme.cn * @date 2019/7/21 16:24 */public class ObjectSerializable &#123; public static void main(String[] args) &#123; testSerializable(); testDeserializable(); &#125; /** * 反序列化对象 */ public static void testDeserializable()&#123; Employee employee = null; try ( final ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\employee.txt\")); )&#123; employee = (Employee) inputStream.readObject(); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(employee.getAge()); &#125; /** * 序列化对象 */ public static void testSerializable()&#123; Employee employee = new Employee(); employee.setAge(23); employee.setName(\"王豪\"); employee.setAddress(\"荣昌\"); try ( //序列化流对象 final ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\employee.txt\")); )&#123; outputStream.writeObject(employee); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 7. 打印流可以用来改变打印流向, 从控制台转向文件. 1234567891011121314151617package javaBase.File;import java.io.FileNotFoundException;import java.io.PrintStream;/** * @author jhmarryme.cn * @date 2019/7/21 16:41 */public class TestPrintStream &#123; public static void main(String[] args) throws Exception &#123; final PrintStream printStream = new PrintStream(\"D:\\\\WJH-workSpace\\\\code\\\\java\\\\new\\\\reading\\\\cyc2018\\\\src\\\\main\\\\java\\\\javaBase\\\\File\\\\test.txt\"); System.setOut(printStream); System.out.println(\"hello\"); &#125;&#125; 8. 总结不管是字节流和字符流, 构造方法的参数可以为 路径或File对象. 字符流主要用来处理文本文件.使用字符流的时候如果 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。 字节流则不会. 但是可以通过flush方法强制刷新缓冲区.字符流可以很方便的处理字符串.字符流，只能操作文本文件，不能操作图片，视频等非文本文件。缓冲流效率最佳. 学习完这些基本流后, 大概对文件的操作有了初步的认识. 合理的选择要使用的流. 在需要效率的时候选择缓冲流. 当文件格式需要处理的时候, 选择转换流进行处理. 正确的选择要使用的格式很重要.","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"生产者消费者问题简单模拟","slug":"note/cyc2018/thread/生产者消费者问题简单模拟","date":"2019-07-15T11:34:56.000Z","updated":"2019-07-24T06:34:11.869Z","comments":true,"path":"2019/07/15/note/cyc2018/thread/生产者消费者问题简单模拟/","link":"","permalink":"https://wangdaye7.github.io/2019/07/15/note/cyc2018/thread/生产者消费者问题简单模拟/","excerpt":"","text":"一次简单的测试. 产品: 1234567891011package javaBase.thread.producerAndConsumer;/** * @author jhmarryme.cn * @date 2019/7/15 11:17 */public class Product &#123; String color; String size; boolean flag = false;&#125; 消费者:123456789101112131415161718192021222324252627282930313233343536package javaBase.thread.producerAndConsumer;/** * 消费者 * @author jhmarryme.cn * @date 2019/7/15 11:24 */public class Consumer extends Thread &#123; Product product; public Consumer(String name, Product product) &#123; super(name); this.product = product; &#125; @Override public void run() &#123; while (true)&#123; synchronized (product)&#123; String name = Thread.currentThread().getName(); if (!product.flag) &#123; try &#123; product.wait(); System.out.println(name + \" : 产品未生产, 正在等待\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + \"正在消费产品\" + product.color + product.size); product.flag = false; product.notify(); &#125; &#125; &#125;&#125; 生产者: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package javaBase.thread.producerAndConsumer;/** * 生产者 * @author jhmarryme.cn * @date 2019/7/15 11:18 */public class Producer extends Thread &#123; Product product; public Producer(String name, Product product) &#123; super(name); this.product = product; &#125; @Override public void run() &#123; int count = 0; while(true)&#123; synchronized (product)&#123; //存在未被消费的商品 String name = Thread.currentThread().getName(); if (product.flag)&#123; try &#123; System.out.println(name + \": 存在未被消费的商品, 正在等待\"); product.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(name + \"开始生产产品\"); if (count % 2 == 0) &#123; product.color = \"绿色\"; product.size = \"大号\"; &#125; else &#123; product.color = \"红色\"; product.size = \"小号\"; &#125; product.flag = true; System.out.println(name + \"生产商品成功\"); System.out.println(name + \"正在等待消费\"); product.notify(); &#125; &#125; &#125;&#125; 测试类: 12345678910111213141516171819package javaBase.thread.producerAndConsumer;/** * @author jhmarryme.cn * @date 2019/7/15 11:29 */public class PCDemo &#123; /** * 测试生产者消费者问题 * @param args */ public static void main(String[] args) &#123; Product product = new Product(); new Producer(\"生产者\", product).start(); new Consumer(\"消费者\", product).start(); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"lambda简单使用","slug":"note/cyc2018/lambda/lambda简单使用","date":"2019-07-15T11:11:23.000Z","updated":"2019-07-24T06:34:32.303Z","comments":true,"path":"2019/07/15/note/cyc2018/lambda/lambda简单使用/","link":"","permalink":"https://wangdaye7.github.io/2019/07/15/note/cyc2018/lambda/lambda简单使用/","excerpt":"","text":"用法记录Lambda表达式的标准格式为 (参数类型 参数名称) -&gt; { 代码语句 } 省略规则在Lambda标准格式的基础上，使用省略写法的规则为： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 Lambda的使用前提 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。无论是JDK内置的Runnable、Comparator接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。 使用Lambda必须具有上下文推断。也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。 备注：有且仅有一个抽象方法的接口，称为“函数式接口”。","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"Linux补充","slug":"linux/Linux补充","date":"2019-07-14T20:34:03.000Z","updated":"2019-09-08T14:25:18.107Z","comments":true,"path":"2019/07/15/linux/Linux补充/","link":"","permalink":"https://wangdaye7.github.io/2019/07/15/linux/Linux补充/","excerpt":"","text":"Linux体系结构 查看当前系统shell版本echo $SHELL 查看支持的所有shellcat /etc/shells 切换shell版本chsh -s 版本 实际切换无效. 查找特定的文件 find path [options] params 123find ~ -name \"JsonToString*\" 从用户家目录下查找find / -name \"JsonToString*\" 从根目录下查找find -name \"JsonToString*\" 从当前目录下 参数-iname 则表示忽略大小写 检索文件内容 grep [options] pattern file 全称: Global Regular Expression Print作用: 查找文件里符合条件的字符串 | 可以结合管道操作符使用 123456789101112131415grep \"moo\" targe* 查找以targe开头的文件并内容包含moo的文件find ~ | grep \"target\" 等同于 find ~ -name \"target*\"grep \"partial\\[ture\\]\" log.info 查看日志中包含\"partial[true]\"的行 其中[] 需要转义grep \"partial\\[true\\]\" log.info | grep -o \"engine\\[[[:alnum:]]*\\]\" 再次进行过滤, 只显示\"partial[true]\"并且包含\"engine[任意数字字母]\"的行的 engine[xxxx] 部分, -o 表示只显示匹配的部分grep \"partial\\[true\\]\" log.info | grep -o \"engine\\[[0-9a-z]*\\]\"ps -ef | grep tomcat 查看tomcat信息 但是因为本条指令也在查询tomcat, 所以本条查询进程也会显示出来ps -ef | grep tomcat | grep -v \"grep\" 过滤掉该指令本身 对内容做统计 awk [options] ‘cmd’ file 一次读取一行文本, 按分隔符进行切片切片保存在内建的变量中 $1 $2 … $0为整行单引号 1234567# 先从/var/log目录下copy一份日志文件 这里选择的是dpkg.log# 查看第一, 四列的数据awk '&#123;print $1 $4&#125;' dpkg.log# 查看 第二列满足条件 或 第一行的数据awk '($2==\"14:42:45\") || NR==1 &#123;print $0&#125;' dpkg.log# 根据第二列的值统计出现过的次数awk '&#123;arr[$2]++&#125;END&#123;for(i in arr) print i \"\\t\" arr[i]&#125;' dpkg.log","categories":[],"tags":[]},{"title":"线程","slug":"note/cyc2018/thread/线程","date":"2019-07-09T11:27:02.000Z","updated":"2019-09-08T14:24:07.649Z","comments":true,"path":"2019/07/09/note/cyc2018/thread/线程/","link":"","permalink":"https://wangdaye7.github.io/2019/07/09/note/cyc2018/thread/线程/","excerpt":"","text":"1. 概念 1.1. 基本概念 1.2. 线程的状态 2. 基本方法 3. 线程的应用 3.1. 线程的创建 3.1.1. 两种创建的方式 3.1.2. 测试代码 3.1.3. Thread和Runnable的区别 3.2. 多线程 3.3. 线程的安全问题 3.3.1. 出现问题的代码 3.3.2. 线程同步 4. 线程池的使用 1. 概念1.1. 基本概念1个程序至少有一个进程,一个进程至少有一个线程. 程序 程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体 进程 是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。 进程是”活的”. 线程 线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程 中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 1.2. 线程的状态在API中java.lang.Thread.State这个枚举中给出了六种线程状态： 线程状态 导致状态发生条件 NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 Runnable(可运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。 Blocked(锁阻塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 Waiting(无限等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。 Timed Waiting(计时等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 Teminated(被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 2. 基本方法java.lang.Thread类： 构造方法： public Thread():分配一个新的线程对象。 public Thread(String name):分配一个指定名字的新的线程对象。 public Thread(Runnable target):分配一个带有指定目标新的线程对象。 public Thread(Runnable target,String name):分配一个带有指定目标新的线程对象并指定名字。 常用方法： public String getName():获取当前线程名称。 public void start():导致此线程开始执行; Java虚拟机调用此线程的run方法。 public void run():此线程要执行的任务在此处定义代码。 public static void sleep(long millis):使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。 public static Thread currentThread():返回对当前正在执行的线程对象的引用。 3. 线程的应用3.1. 线程的创建3.1.1. 两种创建的方式 继承Thead并重写run方法 实现Runnable接口作为参数传递给Thead 可以使用匿名内部类或函数式编程 3.1.2. 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package javaBase.thread;/** * @author jhmarryme.cn * @date 2019/7/14 9:55 */public class CreateThreadFinalTest &#123; public static void main(String[] args) &#123; /*Thread th1 = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"thread1 -&gt; i = \" + i); &#125; &#125; &#125;);*/ Thread th1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"thread1 -&gt; i = \" + i); &#125; &#125;); th1.start(); Thread2 th2 = new Thread2(\"thread2\"); th2.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"main thread -&gt; i = \" + i); &#125; &#125;&#125;class Thread2 extends Thread&#123; public Thread2(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"thread2 -&gt; i = \" + i); &#125; &#125;&#125; 3.1.3. Thread和Runnable的区别一个类继承Thread，不适合资源共享。实现了Runable接口的话，很容易的实现资源共享。 实现Runnable接口比继承Thread类所具有的优势： 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。 3.2. 多线程多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈。 3.3. 线程的安全问题3.3.1. 出现问题的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package javaBase.thread;/** * @author jhmarryme.cn * @date 2019/7/14 10:17 */public class ThreadSafeFinalTest &#123; public static void main(String[] args) &#123; Tickets tickets = new Tickets(); Thread th1 = new Thread(tickets, \"窗口1\"); Thread th3 = new Thread(tickets, \"窗口3\"); Thread th2 = new Thread(tickets, \"窗口2\"); th1.start(); th2.start(); th3.start(); &#125;&#125;class Tickets implements Runnable&#123; private int tickets = 100; @Override public void run() &#123; while(true)&#123; if (tickets&gt;0) &#123; //模拟出票时间 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"正在卖第\" + (tickets--) + \"张票\"); &#125; &#125; &#125;&#125; 出现了票重复买和不存在的票的情况 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。 3.3.2. 线程同步 同步代码块 同步代码块：synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 格式: 123synchronized(同步锁)&#123; 需要同步操作的代码&#125; 同步锁: 对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. 锁对象 可以是任意类型。 多个线程对象 要使用同一把锁。 在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着(BLOCKED)。任意new一个Object对象, 作为同步锁即可 同步方法 同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 对于非static方法,同步锁就是this。对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 格式： 123public synchronized void method()&#123; 可能会产生线程安全问题的代码&#125; 锁机制 java.util.concurrent.locks.Lock机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下： public void lock():加同步锁。 public void unlock():释放同步锁。 Lock lock = new ReentrantLock()即可 4. 线程池的使用Java里面线程池的顶级接口是java.util.concurrent.Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。 要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在java.util.concurrent.Executors线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。 Executors类中有个创建线程池的方法如下： public static ExecutorService newFixedThreadPool(int nThreads)：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量) 一个使用线程池对象的方法如下： public Future&lt;?&gt; submit(Runnable task):获取线程池中的某一个线程对象，并执行 Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。 使用线程池中线程对象的步骤： 创建线程池对象。 创建Runnable接口子类对象。(task) 提交Runnable接口子类对象。(take task) 关闭线程池(一般不做)。 Runnable实现类代码： 12345678910111213141516171819package javaBase.thread.ThreadPool;/** * @author jhmarryme.cn * @date 2019/7/17 11:05 */public class RunnableForPool implements Runnable&#123; @Override public void run() &#123; System.out.println(\"线程准备\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" : 正在使用\"); System.out.println(Thread.currentThread().getName() + \"使用完毕\"); &#125;&#125; 线程池测试类： 123456789101112131415161718192021222324package javaBase.thread.ThreadPool;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author jhmarryme.cn * @date 2019/7/17 11:06 */public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService service = Executors.newFixedThreadPool(3); // 创建Runnable实例对象 RunnableForPool r = new RunnableForPool(); // 从线程池中获取线程对象,然后调用MyRunnable中的run() service.submit(r); // 再获取1个线程对象，调用MyRunnable中的run() service.submit(r); service.submit(r); // 注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。 &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"异常学习及简单应用","slug":"note/cyc2018/exception/异常学习及简单应用","date":"2019-07-09T11:27:02.000Z","updated":"2019-07-24T13:13:45.812Z","comments":true,"path":"2019/07/09/note/cyc2018/exception/异常学习及简单应用/","link":"","permalink":"https://wangdaye7.github.io/2019/07/09/note/cyc2018/exception/异常学习及简单应用/","excerpt":"","text":"1. 异常 1.1. 异常概念 1.2. 异常体系 1.3. 异常分类 1.4. 异常的处理 1.5. 自定义异常 2. 异常补充 2.1. 通用异常处理 1. 异常1.1. 异常概念 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2. 异常体系异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，一般来说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免。 Exception:表示异常，可做处理。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 1.3. 异常分类异常(Exception)的分类: 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.4. 异常的处理Java异常处理的五个关键字：try、catch、ﬁnally、throw、throws 1.5. 自定义异常异常类定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 2. 异常补充2.1. 通用异常处理处理异常信息时, 通过SpringMVC的AOP拦截异常, 返回错误信息 环境 123456// 依赖: (不引用启动器, 版本由父工程管理)``` yml&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;&lt;/dependency&gt; 自定义枚举类用于异常信息 12345678910@Getter@AllArgsConstructor@NoArgsConstructorpublic enum ExceptionEnum &#123; //价格不能为空 PRICE_CANNOT_BE_NULL(400, \"价格不能为空\") ; private int code; private String message;&#125; 自定义信息类 12345678910111213@Datapublic class ExceptionResult &#123; private int status; private String message; private Long timestamp; public ExceptionResult(ExceptionEnum exceptionEnum) &#123; this.status = exceptionEnum.getCode(); this.message = exceptionEnum.getMessage(); this.timestamp = System.currentTimeMillis(); &#125;&#125; 自定义异常类 1234567@AllArgsConstructor@NoArgsConstructor@Getterpublic class LyException extends RuntimeException &#123; //接受枚举作为参数 private ExceptionEnum exceptionEnum;&#125; 自定义通用异常拦截器 12345678910//要想该类被扫描到, 必须和应用启动器的类处于同一个包下 @ControllerAdvicepublic class CommonExceptionHandler &#123; @ExceptionHandler(LyException.class) public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; //返回的是整个响应消息, 其中主要配置错误码和响应体 return ResponseEntity.status(e.getExceptionEnum().getCode()).body(new ExceptionResult(e.getExceptionEnum())); &#125;&#125; 应用 123456789101112131415@RestController@RequestMapping(\"item\")public class ItemController &#123; @Autowired private ItemService itemService; @PostMapping public ResponseEntity&lt;Item&gt; saveItem(Item item)&#123; //校验价格 if (item.getPrice() == null) &#123; //传递一个枚举变量 throw new LyException(ExceptionEnum.PRICE_CANNOT_BE_NULL); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(item); &#125;&#125;","categories":[{"name":"java基础","slug":"java基础","permalink":"https://wangdaye7.github.io/categories/java基础/"}],"tags":[]},{"title":"绪论","slug":"note/dataStructure/绪论","date":"2019-06-20T20:03:19.000Z","updated":"2019-09-08T14:23:57.637Z","comments":true,"path":"2019/06/21/note/dataStructure/绪论/","link":"","permalink":"https://wangdaye7.github.io/2019/06/21/note/dataStructure/绪论/","excerpt":"","text":"数据结构和算法的简单认识数据结构 基本概念 数据描述客观事物的符号. 可以输入, 可被处理. 数据元素组成数据的, 有一定意义的基本单位. 也被称为记录. 由若干个数据项构成. 数据项数据项是数据不可分割的最小单位. 数据对象性质相同的数据元素的集合, 是数据的子集. 数据结构相互之间存在一种或多种特定关系的数据元素的集合. 逻辑结构与物理结构 逻辑结构数据对象中数据元素之间的相互关系. 集合结构 线性结构 树形结构 图形结构 物理结构数据的逻辑结构在计算机中的存储形式 顺序存储结构 链式存储结构 数据类型 指一组性质相同的值得结合及定义在此集合上的一些操作的总称. 原子类型不可再分解. 结构类型若干个类型组合. 抽象数据类型 Abstract Data Type ADT, 指一个数学模型及定义在该模型上的一组操作. 总结 数据 -&gt; 数据对象 -&gt; 数据元素 -&gt; 数据项 算法 定义 是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令 特性 输入输入 可行性 确定性 有穷性 设计要求 正确性 可读性 健壮性 时间效率高和存储量低 函数的渐进增长 主要关心的是最高阶项的阶数 数据规模不同, 优劣性不同 时间复杂度 定义用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。 推导大O阶只要高阶项, 不要低阶项, 也不要高阶项系数 常数阶 线性阶 对数阶 平方阶 常见时间复杂度 -最坏情况与平均情况 空间复杂度","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://wangdaye7.github.io/categories/数据结构/"}],"tags":[]},{"title":"HeadFirst设计模式读书笔记","slug":"note/designPattern/HFDesignPattern1","date":"2019-06-20T16:48:57.000Z","updated":"2019-07-04T01:42:00.926Z","comments":true,"path":"2019/06/21/note/designPattern/HFDesignPattern1/","link":"","permalink":"https://wangdaye7.github.io/2019/06/21/note/designPattern/HFDesignPattern1/","excerpt":"","text":"设计原则 类应该对扩展开放, 对修改关闭. 策略模式观察者模式装饰者模式记录 继承设计-&gt;编译时静态决定, 组合-&gt;运行时动态扩展","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://wangdaye7.github.io/categories/设计模式/"}],"tags":[]},{"title":"记录一次jdk编译-ubuntu16.04编译JDK7","slug":"note/jvm/记录一次jdk编译","date":"2019-06-19T20:23:15.000Z","updated":"2019-07-24T13:39:55.578Z","comments":true,"path":"2019/06/20/note/jvm/记录一次jdk编译/","link":"","permalink":"https://wangdaye7.github.io/2019/06/20/note/jvm/记录一次jdk编译/","excerpt":"","text":"0.1. 获取源码 0.2. 配置 0.3. 编译源码 0.4. 错误参考 0.5. 至此 编译成功 0.6. 编译完成之后 0.7. 总结 ubuntu16 环境下: 0.1. 获取源码 依赖 先安装一些依赖: 书上给出的依赖如下: 1sudo apt-get install build-essential gawk m4 openjdk-6-jdk libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif3 libmotif-dev ant 其中，openjdk-6-jdk 是不能直接apt-get 的，google以后Github-bmaupin给出了一个解决方案，我们可以直接去到openjdk，选择合适的包下载。下载前还需要注册一个Oracle帐号。下载好jdk-6u45-linux-x64.bin后复制到想要的目录并运行，相同目录下就会创建一个包含有jdk的文件夹。 libmotif3也不能直接安装，需要从libmotif3下载, 但是我是通过这种方式安装一直失败, 报错. 后来通过ubuntu的应用商店安装. 网上查阅的依赖如下: 12sudo apt-get updatesudo apt-get install build-essential gawk m4 libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif-common ant 这里我两种依赖都运行过, 书上给的依赖问题比较多, 所以随后我又安装这个依赖 这里通过下载好的源码进行: 首先是openjdk: 1234cd /home/jhmarryme/workspacesudo apt-get install unarsudo unar openjdk-7-fcs-src-b147-27_jun_2011.zipsudo mv openjdk /usr/openjdk 运行jdk.bin: 123456sudo chmod u+x jdk-6u45-linux-x64.binsudo ./jdk-6u45-linux-x64.bincd /usrsudo mkdir javacd -sudo mv jdk1.6.0_45 /usr/java/ 0.2. 配置配置文件: 1sudo vim /etc/profile 在后面追加如下内容: 12345678910111213141516171819202122232425262728293031323334##export LANG=C#BootStrap-JDKexport ALT_BOOTDIR=/usr/java/jdk1.6.0_45#OracleJDKexport ALT_JDK_IMPORT_PATH=/usr/java/jdk1.6.0_45#export ALLOW_DOWNLOADS=true#与你的CPU核数对应即可export HOTSPOT_BUILD_JOBS=1export ALT_PARALLEL_COMPILE_JOBS=1#export USE_PRECOMPILED_HEADER=true#export BUILD_LANGTOOLS=trueexport BUILD_JAXWS=false#export BUILD_JAXP=false#export BUILD_CORBA=falseexport BUILD_HOTSPOT=trueexport BUILD_JDK=trueexport SKIP_COMPARE_IMAGES=true#BUILD_DEPLOY=false#BUILD_INSTALL=false#export ALT_OUTPUTDIR=/usr/openjdk/build#unset JAVA_HOMEunset CLASSPATH#make 2&gt;&amp;1 | tee $ALT_OUTPUTDIR/build.log 0.3. 编译源码12cd /usr/openjdk/make sanity 末尾出现Sanity check passed. 则验证通过. 12source /etc/profilemake 0.4. 错误参考编译期间遇到一大堆错误, 逐个解决, 参考如下:主要安装参考1参考2参考3 需要注意的是 1234#错误error:\"__LEAF\"redefined [-Werror]#define __LEAF(result_type, header) \\^ 网上都说是在openjdk/hotspot/src/share/vm/runtime/interfaceSupport.hpp文件后追加, 但我修改之后没有效果, 我选择的是在该文件430行左右开始, 替换掉原本的定义. 不再报错. 12345678// LEAF routines do not lock, GC or throw exceptions #ifdef __LEAF #undef __LEAF #define __LEAF(result_type, header) \\TRACE_CALL(result_type, header) \\debug_only(NoHandleMark __hm;) \\/* begin of body */ #endif 1234567#错误/usr/openjdk/hotspot/src/share/vm/oops/constantPoolOop.cpp:272:39: error: converting 'false' to pointer type 'methodOop &#123;aka methodOopDesc*&#125;' [-Werror=conversion-null] if (cpool-&gt;cache() == NULL) return false; // nothing to load yet#错误/usr/openjdk/hotspot/src/share/vm/opto/loopnode.cpp:896:49: error: converting 'false' to pointer type 'Node*' [-Werror=conversion-null] if (expr == NULL || expr-&gt;req() != 3) return false; 0.5. 至此 编译成功 0.6. 编译完成之后 相关设置: 编译完成之后,进入OpenJDK源码下的build/j2sdk-image目录(或者build-debug、build- fastdebug这两个目录),这是整个JDK的完整编译结果,复制到JAVA_HOME目录,就可以作为一个完整的JDK使用,编译出来的虚拟机,在-version命令中带有用户的机器名。 操作如下: 12345678cd /usr/binln -s -f /usr/openjdk/build/j2sdk-image/bin/javaln -s -f /usr/openjdk/build/j2sdk-image/bin/javacjava -version#此时显示openjdk version \"1.7.0-internal\"OpenJDK Runtime Environment (build 1.7.0-internal-root_2019_06_20_02_16-b00)OpenJDK 64-Bit Server VM (build 21.0-b17, mixed mode) 运行虚拟机 在product下边（看网上都是在jvmg下边，我的jvmg下边没有gamma）的env.sh下加入, 完整路径/usr/openjdk/build/hotspot/outputdir/linux_amd64_compiler2/product 123LD_LIBRARY_PATH=.:$&#123;JAVA_HOME&#125;/jre/lib/amd64/native_threads:$&#123;JAVA_HOME&#125;/jre/lib/amd64:export LD_LIBRARY_PATH 我的是存在上述代码, 将export多余内容删除 1234567source ./env.sh./gamma -version#出现内容如下Using java runtime at: /usr/openjdk/build/j2sdk-image//jreopenjdk version \"1.7.0-internal\"OpenJDK Runtime Environment (build 1.7.0-internal-root_2019_06_20_02_16-b00)OpenJDK 64-Bit Server VM (build 21.0-b17, mixed mode) 0.7. 总结在选择获取jdk和openjdk源码时, 使用打包好的文件进行安装最为方便, 之前选用在线下载的方式时, 遇到了很多问题, 随后改为压缩包安装. 在整个编译的过程中, make的时候出现了很多问题, 我是一个一个去解决的, 其实这样太花时间了, 应该按照参考的错误解决方式全部修改后, 再次make. 会节约很多的时间. 最好是不要修改/etc/profile文件, 容易产生很多问题, 而是通过用户的sh完成. 但这里我还是修改的profile文件.","categories":[{"name":"java虚拟机读书笔记","slug":"java虚拟机读书笔记","permalink":"https://wangdaye7.github.io/categories/java虚拟机读书笔记/"}],"tags":[]},{"title":"深入理解java虚拟机读书笔记","slug":"note/jvm/深入理解java虚拟机读书笔记","date":"2019-06-17T08:49:40.000Z","updated":"2019-06-20T08:40:45.333Z","comments":true,"path":"2019/06/17/note/jvm/深入理解java虚拟机读书笔记/","link":"","permalink":"https://wangdaye7.github.io/2019/06/17/note/jvm/深入理解java虚拟机读书笔记/","excerpt":"","text":"走近java Java技术体系 sun官方定义Java包括以下组成部分: java程序设计语言 各种硬件平台上的java虚拟机 Class文件格式 JavaApi类库 第三方Java类库JDK: 支持java程序开发最小环境.(语言, 虚拟机, API)JRE: 支持java程序运行标准环境.(虚拟机, SE API子集)","categories":[],"tags":[]},{"title":"牛客算法学习part1","slug":"note/algorithm/牛客算法学习","date":"2019-06-16T20:59:43.000Z","updated":"2019-07-28T11:34:26.083Z","comments":true,"path":"2019/06/17/note/algorithm/牛客算法学习/","link":"","permalink":"https://wangdaye7.github.io/2019/06/17/note/algorithm/牛客算法学习/","excerpt":"","text":"1. 概念 1.1. 时间复杂度 1.2. 空间复杂度 1.3. 最优解 1.4. 排序的稳定性 2. 数组排序 2.1. 时间复杂度O(N^2),空间复杂度O(1) 2.1.1. 冒泡排序 2.1.2. 选择排序 2.1.3. 插入排序 2.2. 时间复杂度O(NlogN) 2.2.1. 归并排序 2.2.2. 快速排序 2.2.3. 堆排序 2.2.4. 桶排序 3. 延伸题型 3.1. 区别 3.1.1. merge与quick的区别 3.2. 归并延伸 3.2.1. 求小和 3.2.2. 降序对 3.3. 桶排序 3.3.1. 排序之后的相邻最大差值 1. 概念1.1. 时间复杂度 概念 时间复杂度为一个算法流程中, 常数操作数量的指标, 这个指标叫做O, big O.只要高阶项, 不要低阶项, 也不要高阶项系数, 剩下部分记为f(N), 时间复杂度为O(f(N)) 常数操作完成操作的时间与数据量无关 例子 寻找数组(长度N)中最大值变量max = 系统最小值, 遍历数组, 时间复杂度为O(N) 有序数组二分查找时间复杂度为O(logN) 默认以2为底 两个有序数组寻找相同的部分, 长度为N, M 循环遍历两个数组O(N * M) 遍历左边数组, 在右边数组二分查找O(N * logM) 外排, 假定无重复取两个数组的起始索引为P1, P2, 因为是寻找公共的部分且两个数组有序, 所以只有当a[P1] == a[p2]时指针才同时动, 如果当谁的值更小, 就单独移动谁的指针, 一直移动到两端值相等为止.O(N + M)最优解要根据实际的数据量进行确定, 当N的长度远小于M的时候, 通过第二种方法时间复杂度更小, 具体情况具体分析. 1.2. 空间复杂度 概念 空间复杂度一般指额外空间复杂度, 不算上输入输出需要的空间. 例子 数组中分成两个部分, 左右两个部分交换, 总长度为N 如12345 67, 交换为67 12345 通过一个辅助空间先存入67, 存入12345 空间复杂度为O(N) 直接在原数组中进行操作 通过一个辅助变量进行数组逆序, 得到7654321, 再对67单独逆序, 54321单独逆序, 得到结果6712345, 也可以先单独逆序, 再进行整体逆序 这里的空间复杂度为O(1) 1.3. 最优解一般情况下 先满足时间复杂度最优, 再满足空间复杂度最优. 1.4. 排序的稳定性无序数组中值相同的部分 排成有序之后相对次序保持不变 可以做到稳定 冒泡 插入 归并 不可以做到稳定 选择 快速 (可以做到, 论文级别, 很难 01 stable sort) 2. 数组排序2.1. 时间复杂度O(N^2),空间复杂度O(1)2.1.1. 冒泡排序123456789101112public static void bubbleSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int end = arr.length - 1; end &gt; 0; end--)&#123; for (int i = 0; i &lt; end; i ++)&#123; if (arr[i] &gt; arr[i + 1]) &#123; DigitalArrayUtil.swap(arr, i , i + 1); &#125; &#125; &#125;&#125; 2.1.2. 选择排序12345678910public static void selectionSort(int[] arr)&#123; int minIndex; for (int i = 0; i &lt; arr.length - 1; i++) &#123; minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; minIndex = (arr[minIndex] &lt; arr[j]) ? minIndex : j; &#125; DigitalArrayUtil.swap(arr, minIndex, i); &#125;&#125; 2.1.3. 插入排序 时间复杂度最好O(N), 最差O(N^2) 1234567public static void insertionSort(int[] arr)&#123;for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1] ; j--) &#123; DigitalArrayUtil.swap(arr, j, j + 1); &#125;&#125;&#125; 2.2. 时间复杂度O(NlogN)2.2.1. 归并排序 例如7 9 8 4 6 2, 先划分为798 462两个部分, 左边再划分成 79 8 , 左边再到7 9, 最后左边到7, 此时只剩一个数了, 不用再划分, 再依次与右边的进行有序合并的, 一直递归向上, 最后排序完成. 其实就是一个划分, 合并的过程.空间复杂度O(N)归并排序内部缓存法实现空间复杂度O(1)时间复杂度的计算过程$$T(n)=aT(\\frac{n}{b}) +O(n^{d})$$其中:$$ \\log _b a &gt; d \\Rightarrow O(n^{log _b a})$$$$ \\log _b a &lt; d \\Rightarrow O(n^d)$$$$ \\log _b a = d \\Rightarrow O(n^d * \\log n)$$a 为递归中子递归个数， n/b 为子递归的数据规模。这里a = 2, b = 2, d = 1其实就是 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; sortProcess(arr, 0, arr.length - 1);&#125;/** * 归并 * @param arr * @param L * @param R */public static void sortProcess(int[] arr, int L, int R)&#123; if (L == R)&#123; return; &#125; int mid = (R - L) / 2 + L; sortProcess(arr, L, mid); sortProcess(arr, mid + 1, R); merge(arr, L, mid, R);&#125;/** * 外排合并 * @param arr * @param L * @param mid * @param R */public static void merge(int[] arr, int L, int mid, int R)&#123; int[] help = new int[R - L + 1]; int p1 = L; int p2 = mid + 1; int i = 0; while (p1 &lt;= mid &amp;&amp; p2 &lt;= R)&#123; help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; //只会有一个越界, 只会处理一个while循环 while(p1 &lt;= mid)&#123; help[i++] = arr[p1++]; &#125; while(p2 &lt;= R)&#123; help[i++] = arr[p2++]; &#125; for (int j = 0; j &lt; help.length; j++) &#123; arr[L + j] = help[j]; &#125;&#125; 2.2.2. 快速排序 快速排序的思想基本上还是将问题划分, 然后递归进行.总体上划分为三个区域, 大于区, 小于区, 等于区.再接着在大于区和小于区上进行同样的划分, 最后排序成功 最好的时间复杂度为O(NlogN), 最差为O(N²), 空间复杂度O(logN) 123456789101112131415161718192021222324252627282930313233private static void quickSort(int[] arr, int L, int R)&#123; if (L &lt; R)&#123; //随机快速排序 DigitalArrayUtil.swap(arr, L + (int)(Math.random() * (R - L + 1)), R); //划分区域 int[] partition = partition(arr, L, R); quickSort(arr, L, partition[0] - 1); quickSort(arr, partition[1] + 1, R); &#125;&#125;private static int[] partition(int[] arr, int L, int R)&#123; int less = L - 1; //为了少用一个变量, 这里大于区域直接指向最后一位, 就避免了最后被改变, 但要在最后进行交换 int more = R; //一直循环到大于区域为止 while(L &lt; more)&#123; if (arr[L] &lt; arr[R]) &#123; //如果属于小于区域 DigitalArrayUtil.swap(arr, L++, ++less); &#125; else if (arr[L] &gt; arr[R])&#123; //如果属于大于区域, 因为此时所在的位置是等于区, 所以指针不动, 接着比较, 直到进入正确的大于区域 DigitalArrayUtil.swap(arr, L, --more); &#125; else&#123; //属于等于区域, 不做改变 L++; &#125; &#125; //为之前的准备 做交换 DigitalArrayUtil.swap(arr, more, R); // 值得注意的是这里等于区域到more为止, 因为之前最后一位作为保留, 后又进行了交换, 所以大于区域的第一位实际是等于区的数 return new int[]&#123;less + 1, more&#125;;&#125; 2.2.3. 堆排序时间复杂度O(N*logN)，额外空间复杂度O(1) 堆可以看成一个二叉树，所以可以考虑使用二叉树的表示方法来表示堆。但是因为堆中元素按照一定的优先顺序排列，因此可以使用更简单的方法——数组——来表示，这样可以节省子节点指针空间，并且可以快速访问每个节点。 如果只是建立堆的过程，时间复杂度为O(N) 堆排序其实就是一个建立大根堆之后进行循环处理的过程, 在简单理解了堆的结构之后理解堆排序其实不难. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package chapter2;import utils.DigitalArrayUtil;import java.util.Arrays;/** * @author jhmarryme.cn * @date 2019/7/4 10:42 */public class Code_05_HeapSort &#123; /** * 堆排序 * 1. 建立大根堆 * 2. 堆循环处理 * 2.1 首尾交换 * 2.2 调整位置 * @param arr */ public static void heapSort(int[] arr)&#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; //建立大根堆 for (int i = 0; i &lt; arr.length; i++) &#123; heapInsert(arr, i); &#125; int size = arr.length; while (--size &gt; 0)&#123; DigitalArrayUtil.swap(arr, 0, size); heapfiy(arr, 0, size); &#125; &#125; /** * 交换首尾后的 堆排序处理 * @param arr * @param index * @param heapSize */ private static void heapfiy(int[] arr, int index, int heapSize) &#123; int left = index * 2 + 1; while (left &lt; heapSize)&#123; // 当右节点存在且大于左节点时 取右节点 int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; largest = arr[index] &gt; arr[largest] ? index :largest; if (largest == index) &#123; // 代表子节点没有比自己大的了 break; &#125; DigitalArrayUtil.swap(arr, index, largest); index = largest; left = index * 2 + 1; &#125; &#125; /** * 建立大根堆 * @param arr * @param index */ private static void heapInsert(int[] arr, int index) &#123; while(arr[index] &gt; arr[(index - 1) / 2])&#123; DigitalArrayUtil.swap(arr, index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; /** * 测试堆排序 * @param args */ public static void main(String[] args) &#123; int testTime = 50000; int size = 100; int value = 100; boolean success = true; long l = System.currentTimeMillis(); for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = DigitalArrayUtil.generateRandomArray(size, value); int[] arr2 = Arrays.copyOf(arr1, arr1.length); heapSort(arr1); DigitalArrayUtil.comparator(arr2); if (!DigitalArrayUtil.isEqual(arr1, arr2)) &#123; success = false; break; &#125; &#125; long l2 = System.currentTimeMillis(); System.out.println(\"success = \" + success); System.out.println(\"运行时间 = \" + (l2 - l)); &#125;&#125; 2.2.4. 桶排序 不是基于比较的算法 例如有几亿个数, 范围是0~200, 那么只需要准备201个桶, 遍历一遍数组把对应的数字放入桶内, 最后再将桶内的数字依次倒出来组成新的数组. 但是虽然很快, 但实际用的不多. 实际应用中一般需要排序的很少是基本类型, 都是自定义的类型. 而桶排序需要分析数据的状况, 不具备通用性. 容器类型决定稳定性, 使用队列结构作为容器是稳定的, 栈结构就不稳定 计数排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package chapter2;import utils.DigitalArrayUtil;import java.util.Arrays;import java.util.stream.Stream;/** * @author jhmarryme.cn * @date 2019/7/28 10:35 */public class Code_06_BucketSort &#123; /** * 计数排序 * @param arr */ private static void bucketSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2)&#123; return; &#125; int max = Integer.MIN_VALUE; for (int i : arr) &#123; max = Math.max(i, max); &#125; int[] bucket = new int[max + 1]; for (int i : arr) &#123; bucket[i]++; &#125; int index = 0; for (int i = 0; i &lt; bucket.length; i++) &#123; while(bucket[i]-- &gt; 0)&#123; arr[index++] = i; &#125; &#125; &#125; /** * 测试桶排序 * @param args */ public static void main(String[] args) &#123; int testTime = 50000; int size = 100; int value = 100; boolean success = true; long l = System.currentTimeMillis(); for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = new int[(int) ((size + 1) * Math.random())]; for (int j = 0; j &lt; arr1.length; j++) &#123; arr1[j] = ((int)(Math.random() * 201)); &#125; int[] arr2 = Arrays.copyOf(arr1, arr1.length); bucketSort(arr1); DigitalArrayUtil.comparator(arr2); if (!DigitalArrayUtil.isEqual(arr1, arr2)) &#123; success = false; break; &#125; &#125; long l2 = System.currentTimeMillis(); System.out.println(\"success = \" + success); System.out.println(\"运行时间 = \" + (l2 - l)); &#125;&#125; 基数排序 3. 延伸题型3.1. 区别3.1.1. merge与quick的区别 系统中基础类型使用quick, 自定义class类型用merge类型 稳定性, 基础类型排序不考虑稳定性所以用quick, merge是稳定的. 3.2. 归并延伸3.2.1. 求小和 利用归并排序的特点, 在进行排序过程中计算小和的总和. 3.2.2. 降序对 也是利用归并排序, 求降序对. 3.3. 桶排序3.3.1. 排序之后的相邻最大差值 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时 间复杂度O(N)，且要求不能用非基于比较的排序","categories":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/categories/算法/"}],"tags":[]},{"title":"EffectiveJava读书笔记","slug":"note/effectiveJava/EffectiveJava读书笔记","date":"2019-05-23T08:59:37.000Z","updated":"2019-09-08T14:23:50.249Z","comments":true,"path":"2019/05/23/note/effectiveJava/EffectiveJava读书笔记/","link":"","permalink":"https://wangdaye7.github.io/2019/05/23/note/effectiveJava/EffectiveJava读书笔记/","excerpt":"","text":"1.引言 侧重点: 熟悉如何用习惯和高效的方式来构建代码而不是理解语言的核心, 词汇表。 书中内容不讨论性能， 更偏向于编写出清晰， 正确， 可用， 简装， 灵活和可维护的程序。 java支持的四种类型： 接口（包活注释）， 类（包括enum）, 数组, 基本类型 前三种为引用类型. 类实例和数组为对象. 类的成员由它的域, 方法, 成员类, 成员接口组成. 2.创建和销毁对象","categories":[{"name":"EffectiveJava读书笔记","slug":"EffectiveJava读书笔记","permalink":"https://wangdaye7.github.io/categories/EffectiveJava读书笔记/"}],"tags":[]},{"title":"linux基础命令","slug":"linux/linux基础命令","date":"2019-05-13T23:47:55.000Z","updated":"2019-09-08T14:25:24.505Z","comments":true,"path":"2019/05/14/linux/linux基础命令/","link":"","permalink":"https://wangdaye7.github.io/2019/05/14/linux/linux基础命令/","excerpt":"","text":"快乐的命令行学习记录 简单命令跳转 pwd - rint name of current working directory cd - change directory ls - list directory contents cd cd 更改工作目录到你的家目录。 cd - 更改工作目录到先前的工作目录。 cd ˜user name 更改工作目录到用户家目录。 ls -a –all List all ﬁles, even those with names that begin with a period, which are normally not listed(i.e.,hidden). -d –directory Ordinaryly,if a directory is speciﬁed, ls will list the contents of the directory, not the directory itself. Use this option in conjunction with the -F –classify This option will append an indicator character to the endofeachlistedname. Forexample,a’/’ifthename is a directory. -h –human-readable Inlongformatlistings,displayﬁlesizesinhumanreadable format rather than in bytes. -l Display results in long format. -r –reverse Display the results in reverse order. Normally, ls display its results in ascending alphabetical order. -S Sort results by ﬁle size. -t Sort by modiﬁcation time. 探究 file less more less f,b 下一页, 上一页 G,g 末行, 首行 /characters, n 查找, 之前查找-h, q 帮助, 退出 操作文件和目录 cp – Copy ﬁles and directories mv – Move/rename ﬁles and directories mkdir – Create directories rm – Remove ﬁles and directories ln – Create hard and symbolic link 通配符 需要注意的:[[:class:]] 匹配任意一个属于指定字符类中的字符:[:alnum:] Matches any alphanumeric character[:alpha:] Matches any alphabetic character[:digit:] Matches any numeral[:lower:] Matches any lowercase letter[:upper] Matches any uppercase letter mkdir cp -a 复制包括属性, 所有权等所有信息 -i 交互, 确认 -r 递归 -u 更新 mv 与cp共享 u, v, i rm -f 暴力删除 i, r, v尽量使用前用ls进行测试 ln -s 符号连接 GUI中Ctrl+Shift拖动创建链接 使用命令 type –说明怎样解释一个命令名 which –显示会执行哪个可执行程序 man –显示命令手册页 info –显示命令 info whatis –显示一个命令的简洁描述 alias –创建命令别名 apropos类似于搜索, 比如apropos directory 就是搜索和文件夹相关的命令 等同于man -k directory aliasalias foo=’cd /usr; ls; cd -‘ 注意不能习惯性的等式加空格使用之前先测试是否存在: type foo删除: unalias foo单独的alias 查看系统中的所有别名切换用户后 alias将消失,一次性 重定向 cat - Concatenate ﬁles sort - Sort lines of text uniq - Report or omit repeated lines grep - Print lines matching a pattern wc - Print newline, word, and byte counts for each ﬁle head - Output the ﬁrst part of a ﬁle tail - Output the last part of a ﬁle tee - Read from standard input and write to standard output and ﬁles 重定向的简单使用 >的使用中, 如果发生错误不会将错误信息重定向 新建(或清除)文件的方法 > test.txt 两次> 为追加 0, 1, 2 分别为标准输入, 输出, 和错误 123ll /bin/usr 2&gt; ll-error.txt //将错误信息重定向到ll-error.txt文件中ll /bin/usr &gt; ll-output.txt 2&amp;&gt;1 //重定向标准输出到文件中, 在重定向标准错误到标准输出, (顺序不能乱)ll /bin/usr &amp;&gt; ll-output.txt //简化写法 cat的简单使用 不具备分页的功能, 可用作查看简短的文件.还可以将多个分离的文件重新拼接成一个文件 如有文件:movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099 12cat movie.mpeg.0* &gt; movie.mpeg//这里的顺序会正确的安排, 因为通配符会以有序的方式展开 世界上最低能的文字处理器..zZ: 123cat &gt; lazy_dog.txtThe quick brown fox jumped over the lazy dog.//输入完成 Ctrl+d 告诉cat, 标准输入中, 已达到文件末尾(EOF) 仅输入cat, 会从标准输入读取数据, 会等待输入数据 管道线 将一个命令的输出 通过| 操作符 来作为另一个命令的输入, 理解为一根管子的两头, 一头作为输入, 一头作为输出. 可结合过滤器进行简单排序 可结合uniq 报道或忽略重复行 12345678//简单的管道使用ll /usr/bin | less//结合过滤器进行排序, 这里用ll无法得到想要的结果ls /bin /usr/bin | sort | less//再结合uniq,默认删除重复行 仅显示重复的数据列表加上-d选项ls /bin /usr/bin | sort | uniq -d | less wc 打印行, 单词数, 字节数 grep 打印匹配行 可以用于复杂的匹配模式, 结合正则使用. -i / -d 忽略大小写 / 只打印不匹配的行 head/tail 打印开头/结尾 当只需要开头或结尾的内容时, 通过-n选项调整打印的行数. -f 实时刷新文件, 观察日志文件的时候很有用. Ctrl+c停止 1tail -f /var/log/messages tee 结合管道的使用 一个安装在管道上的小工具. 从标准输入读入数据, 并且同时复制数据到标准输出（允许数据继续随着管道线流动）和一个或多个文件。在某个中间处理阶段来捕捉一个管道线的内容. 1ls /usr/bin | tee ls.txt | grep zip shell echo的展开 字符 1echo * 路径名 12345678910#查看echo /usr/*/shareecho [[:upper:]]*ls -d .[!.]?* 显示隐藏文件 不包含. ..ls -d .* 显示包含. ..的隐藏文件 ls -A 显示所有文件 ls -a 大A与小a有区别 大A 不会显示.和.. (当前目录与父目录) 小a则会 波浪线 12echo ~jhmarryme如果账号存在则展开为指定用户的家目录名, 单独的~为当前用户家目录 算数表达式展开格式:$((expression)) 只支持整数 花括号 1234类似于for循环, 空格相当于分割符, 有一个空格隔开时会拆分成两部分单独显示,嵌套使用时逗号也做拆分用.与非嵌套不同.&#123;2..4&#125; &#123;2..4&#125; 将执行3+3=6次 如果&#123;2..4&#125;,&#123;2..4&#125; 将执行3*3=9次 而嵌套中&#123;&#123;2..4&#125;,&#123;2..4&#125;&#125; 将执行3+3=6次 12echo &#123;2017..2019&#125;-&#123;1..9&#125; &#123;2017..2019&#125;-&#123;10..12&#125; 参数展开 1echo $USER ， “USER” 的变量包含你的用户名。唤醒参数展开，查看 USER 中的内 容 命令替换 123echo $(ls)ls -l $(which cp) 把 which cp 的执行结果作为一个参数传递给 ls 命令file $(ls /usr/bin/* | grep zip) 管道线的输出结果成为 ﬁle 命令的参数列表。 双引号双引号可以用来保留原来的格式 12345ls -l \"two words.txt\" 可以显示文件名带有空格的文件echo $(cal)echo \"$(cal)\" 没有引号的命令替换导致命令行包含38个参数。 加上引号命令行只有一个参数，参数中包括嵌入的空格和换行符 单引号 123456[me@linuxbox ~]$ echo text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USERtext /home/me/ls-output.txt a b foo 4 me[me@linuxbox ~]$ echo \"text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER\"text ~/*.txt &#123;a,b&#125; foo 4 me[me@linuxbox ~]$ echo 'text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER'text ~/*.txt &#123;a,b&#125; $(echo foo) $((2+2)) $USER 随着引用程度加强，越来越多的展开被禁止。 转义字符反斜杠\\ 1234echo 命令带上 ‘-e’ 选项，能够解释转义序列。你可以把转义序列放在 $’ ’ 里面。 以下例子，使用 sleep 命令，一个简单的程序，它会等待指定的秒数，然后退出。 我们可以创建一个简单的倒数计数器：sleep 10; echo -e ”Time’s up\\a”我们也可以这样做：sleep 10; echo ”Time’s up” $’\\a’","categories":[{"name":"linux","slug":"linux","permalink":"https://wangdaye7.github.io/categories/linux/"}],"tags":[]},{"title":"LeetCode记录","slug":"note/algorithm/LeetCode记录","date":"2019-03-17T12:46:21.000Z","updated":"2019-09-08T14:22:03.578Z","comments":true,"path":"2019/03/17/note/algorithm/LeetCode记录/","link":"","permalink":"https://wangdaye7.github.io/2019/03/17/note/algorithm/LeetCode记录/","excerpt":"","text":"leetCode清单解答HashMap相关 两数之和 题目:给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 思路从0开始遍历nums数组, 使用hashmap存放期望的值(target-nums[i])和索引值(i), 判断当前nums[i]是否是前面的需要的期望值, 如果是, 则代表找到了, 不是则继续下一次 123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; ans = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; if(ans.containsKey(nums[i]))&#123; return new int[]&#123;ans.get(nums[i]), i&#125;; &#125; ans.put(target - nums[i], i); &#125; return null; &#125;&#125; 和为k的子数组 题目给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。示例 1 :输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 思路建立map表用于存储每个连续子数组sum求和出现的次数，初始化为（0,1），表示和为0的连续子数组出现1次。 sum的值是在对nums数组的循环中不断累加当前元素的，res的值则需要查找map中是否已存在sum-k的元素，也就是在查找此前所有从0项开始累加的连续子项和中有没有sum-k。 如果有的话，则说明从该项到当前项的连续子数组和必定为k，那么res则可以和这个sum的对应值，即这个sum出现的次数，相加得到新的res。 对于当前sum如果已存在与map中则其对应值+1，不存在则添加新项，初始值为1。 123456789101112131415161718class Solution &#123; public int subarraySum(int[] nums, int k) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 1); int res = 0; int sum = 0; for(int i = 0; i &lt; nums.length; i++)&#123; sum += nums[i]; //如果k = 13 而此时sum = 20, 所以sum - k = 7, 查看是否有出现过7, 如果有则代表从该项到当前项的连续子数组和为13, 将出现过的次数加到结果 if(map.containsKey(sum - k))&#123; res += map.get(sum - k); &#125; //因为这是一个包含负数的数组, 所有存在和为20的情况有很多种, 需要处理 map.put(sum, map.getOrDefault(sum, 0) + 1); &#125; return res; &#125;&#125; ListNode相关 两数相加 题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 12345678910111213141516171819202122232425262728class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //定义一个进位标志 int flag = 0; ListNode p1 = l1; ListNode p2 = l2; ListNode res = new ListNode(-1); ListNode cur = res; while(p1 != null || p2 != null)&#123; int x = (p1 != null) ? p1.val : 0; int y = (p2 != null) ? p2.val : 0; int sum = x + y + flag; flag = sum / 10; cur.next = new ListNode(sum % 10); cur = cur.next; if(p1 != null)&#123; p1 = p1.next; &#125; if(p2 != null)&#123; p2 = p2.next; &#125; &#125; if(flag &gt; 0)&#123; cur.next = new ListNode(flag); &#125; return res.next; &#125;&#125; 两数相加2 -题目 给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 进阶: 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。 示例: 输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出: 7 -&gt; 8 -&gt; 0 -&gt; 7 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;(); Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;(); while(l1 != null || l2 != null)&#123; if(l1 != null)&#123; s1.push(l1.val); l1 = l1.next; &#125; if(l2 != null)&#123; s2.push(l2.val); l2 = l2.next; &#125; &#125; int flag = 0; ListNode head = null; ListNode temp = null; while(!s1.empty() || !s2.empty())&#123; int x = (!s1.empty()) ? s1.pop() : 0; int y = (!s2.empty()) ? s2.pop() : 0; int sum = x + y + flag; ListNode node = new ListNode(sum % 10); temp = head; head = node; head.next = temp; head = node; flag = sum / 10; &#125; if(flag &gt; 0)&#123; temp = head; head = new ListNode(1); head.next = temp; &#125; return head; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangdaye7.github.io/tags/算法/"}]}]}